
spi_lcd.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   0000013c  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00002b78  0800013c  0800013c  0001013c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000674  08002cb4  08002cb4  00012cb4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM          00000008  08003328  08003328  00013328  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .init_array   00000004  08003330  08003330  00013330  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .fini_array   00000004  08003334  08003334  00013334  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .data         00000068  20000000  08003338  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .bss          00000040  20000068  080033a0  00020068  2**3
                  ALLOC
  8 ._user_heap_stack 00000400  200000a8  080033a0  000200a8  2**0
                  ALLOC
  9 .ARM.attributes 00000029  00000000  00000000  00020068  2**0
                  CONTENTS, READONLY
 10 .debug_info   000075a2  00000000  00000000  00020091  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 00001535  00000000  00000000  00027633  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_aranges 00000a70  00000000  00000000  00028b68  2**3
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000978  00000000  00000000  000295d8  2**3
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_line   000037de  00000000  00000000  00029f50  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    00002bcc  00000000  00000000  0002d72e  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .comment      0000007e  00000000  00000000  000302fa  2**0
                  CONTENTS, READONLY
 17 .debug_frame  00002db4  00000000  00000000  00030378  2**2
                  CONTENTS, READONLY, DEBUGGING
 18 .stabstr      0000003f  00000000  00000000  0003312c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

0800013c <__do_global_dtors_aux>:
 800013c:	b510      	push	{r4, lr}
 800013e:	4c05      	ldr	r4, [pc, #20]	; (8000154 <__do_global_dtors_aux+0x18>)
 8000140:	7823      	ldrb	r3, [r4, #0]
 8000142:	b933      	cbnz	r3, 8000152 <__do_global_dtors_aux+0x16>
 8000144:	4b04      	ldr	r3, [pc, #16]	; (8000158 <__do_global_dtors_aux+0x1c>)
 8000146:	b113      	cbz	r3, 800014e <__do_global_dtors_aux+0x12>
 8000148:	4804      	ldr	r0, [pc, #16]	; (800015c <__do_global_dtors_aux+0x20>)
 800014a:	f3af 8000 	nop.w
 800014e:	2301      	movs	r3, #1
 8000150:	7023      	strb	r3, [r4, #0]
 8000152:	bd10      	pop	{r4, pc}
 8000154:	20000068 	.word	0x20000068
 8000158:	00000000 	.word	0x00000000
 800015c:	08002c9c 	.word	0x08002c9c

08000160 <frame_dummy>:
 8000160:	b508      	push	{r3, lr}
 8000162:	4b03      	ldr	r3, [pc, #12]	; (8000170 <frame_dummy+0x10>)
 8000164:	b11b      	cbz	r3, 800016e <frame_dummy+0xe>
 8000166:	4903      	ldr	r1, [pc, #12]	; (8000174 <frame_dummy+0x14>)
 8000168:	4803      	ldr	r0, [pc, #12]	; (8000178 <frame_dummy+0x18>)
 800016a:	f3af 8000 	nop.w
 800016e:	bd08      	pop	{r3, pc}
 8000170:	00000000 	.word	0x00000000
 8000174:	2000006c 	.word	0x2000006c
 8000178:	08002c9c 	.word	0x08002c9c

0800017c <strlen>:
 800017c:	4603      	mov	r3, r0
 800017e:	f813 2b01 	ldrb.w	r2, [r3], #1
 8000182:	2a00      	cmp	r2, #0
 8000184:	d1fb      	bne.n	800017e <strlen+0x2>
 8000186:	1a18      	subs	r0, r3, r0
 8000188:	3801      	subs	r0, #1
 800018a:	4770      	bx	lr

0800018c <__aeabi_uldivmod>:
 800018c:	b953      	cbnz	r3, 80001a4 <__aeabi_uldivmod+0x18>
 800018e:	b94a      	cbnz	r2, 80001a4 <__aeabi_uldivmod+0x18>
 8000190:	2900      	cmp	r1, #0
 8000192:	bf08      	it	eq
 8000194:	2800      	cmpeq	r0, #0
 8000196:	bf1c      	itt	ne
 8000198:	f04f 31ff 	movne.w	r1, #4294967295
 800019c:	f04f 30ff 	movne.w	r0, #4294967295
 80001a0:	f000 b982 	b.w	80004a8 <__aeabi_idiv0>
 80001a4:	f1ad 0c08 	sub.w	ip, sp, #8
 80001a8:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 80001ac:	f000 f806 	bl	80001bc <__udivmoddi4>
 80001b0:	f8dd e004 	ldr.w	lr, [sp, #4]
 80001b4:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 80001b8:	b004      	add	sp, #16
 80001ba:	4770      	bx	lr

080001bc <__udivmoddi4>:
 80001bc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80001c0:	468c      	mov	ip, r1
 80001c2:	460c      	mov	r4, r1
 80001c4:	4605      	mov	r5, r0
 80001c6:	9e09      	ldr	r6, [sp, #36]	; 0x24
 80001c8:	2b00      	cmp	r3, #0
 80001ca:	d14f      	bne.n	800026c <__udivmoddi4+0xb0>
 80001cc:	428a      	cmp	r2, r1
 80001ce:	4617      	mov	r7, r2
 80001d0:	d96b      	bls.n	80002aa <__udivmoddi4+0xee>
 80001d2:	fab2 fe82 	clz	lr, r2
 80001d6:	f1be 0f00 	cmp.w	lr, #0
 80001da:	d00b      	beq.n	80001f4 <__udivmoddi4+0x38>
 80001dc:	f1ce 0520 	rsb	r5, lr, #32
 80001e0:	fa20 f505 	lsr.w	r5, r0, r5
 80001e4:	fa01 f30e 	lsl.w	r3, r1, lr
 80001e8:	ea45 0c03 	orr.w	ip, r5, r3
 80001ec:	fa02 f70e 	lsl.w	r7, r2, lr
 80001f0:	fa00 f50e 	lsl.w	r5, r0, lr
 80001f4:	0c39      	lsrs	r1, r7, #16
 80001f6:	fbbc f0f1 	udiv	r0, ip, r1
 80001fa:	b2ba      	uxth	r2, r7
 80001fc:	fb01 c310 	mls	r3, r1, r0, ip
 8000200:	fb00 f802 	mul.w	r8, r0, r2
 8000204:	ea4f 4c15 	mov.w	ip, r5, lsr #16
 8000208:	ea4c 4403 	orr.w	r4, ip, r3, lsl #16
 800020c:	45a0      	cmp	r8, r4
 800020e:	d909      	bls.n	8000224 <__udivmoddi4+0x68>
 8000210:	19e4      	adds	r4, r4, r7
 8000212:	f100 33ff 	add.w	r3, r0, #4294967295
 8000216:	f080 8128 	bcs.w	800046a <__udivmoddi4+0x2ae>
 800021a:	45a0      	cmp	r8, r4
 800021c:	f240 8125 	bls.w	800046a <__udivmoddi4+0x2ae>
 8000220:	3802      	subs	r0, #2
 8000222:	443c      	add	r4, r7
 8000224:	ebc8 0404 	rsb	r4, r8, r4
 8000228:	fbb4 f3f1 	udiv	r3, r4, r1
 800022c:	fb01 4c13 	mls	ip, r1, r3, r4
 8000230:	fb03 f202 	mul.w	r2, r3, r2
 8000234:	b2ac      	uxth	r4, r5
 8000236:	ea44 410c 	orr.w	r1, r4, ip, lsl #16
 800023a:	428a      	cmp	r2, r1
 800023c:	d909      	bls.n	8000252 <__udivmoddi4+0x96>
 800023e:	19c9      	adds	r1, r1, r7
 8000240:	f103 34ff 	add.w	r4, r3, #4294967295
 8000244:	f080 810f 	bcs.w	8000466 <__udivmoddi4+0x2aa>
 8000248:	428a      	cmp	r2, r1
 800024a:	f240 810c 	bls.w	8000466 <__udivmoddi4+0x2aa>
 800024e:	3b02      	subs	r3, #2
 8000250:	4439      	add	r1, r7
 8000252:	1a8a      	subs	r2, r1, r2
 8000254:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 8000258:	2100      	movs	r1, #0
 800025a:	2e00      	cmp	r6, #0
 800025c:	d063      	beq.n	8000326 <__udivmoddi4+0x16a>
 800025e:	fa22 f20e 	lsr.w	r2, r2, lr
 8000262:	2300      	movs	r3, #0
 8000264:	e886 000c 	stmia.w	r6, {r2, r3}
 8000268:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800026c:	428b      	cmp	r3, r1
 800026e:	d907      	bls.n	8000280 <__udivmoddi4+0xc4>
 8000270:	2e00      	cmp	r6, #0
 8000272:	d056      	beq.n	8000322 <__udivmoddi4+0x166>
 8000274:	2100      	movs	r1, #0
 8000276:	e886 0011 	stmia.w	r6, {r0, r4}
 800027a:	4608      	mov	r0, r1
 800027c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8000280:	fab3 f183 	clz	r1, r3
 8000284:	2900      	cmp	r1, #0
 8000286:	f040 8093 	bne.w	80003b0 <__udivmoddi4+0x1f4>
 800028a:	42a3      	cmp	r3, r4
 800028c:	d302      	bcc.n	8000294 <__udivmoddi4+0xd8>
 800028e:	4282      	cmp	r2, r0
 8000290:	f200 80fe 	bhi.w	8000490 <__udivmoddi4+0x2d4>
 8000294:	1a85      	subs	r5, r0, r2
 8000296:	eb64 0303 	sbc.w	r3, r4, r3
 800029a:	469c      	mov	ip, r3
 800029c:	2001      	movs	r0, #1
 800029e:	2e00      	cmp	r6, #0
 80002a0:	d041      	beq.n	8000326 <__udivmoddi4+0x16a>
 80002a2:	e886 1020 	stmia.w	r6, {r5, ip}
 80002a6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80002aa:	b912      	cbnz	r2, 80002b2 <__udivmoddi4+0xf6>
 80002ac:	2701      	movs	r7, #1
 80002ae:	fbb7 f7f2 	udiv	r7, r7, r2
 80002b2:	fab7 fe87 	clz	lr, r7
 80002b6:	f1be 0f00 	cmp.w	lr, #0
 80002ba:	d136      	bne.n	800032a <__udivmoddi4+0x16e>
 80002bc:	1be4      	subs	r4, r4, r7
 80002be:	ea4f 4817 	mov.w	r8, r7, lsr #16
 80002c2:	fa1f f987 	uxth.w	r9, r7
 80002c6:	2101      	movs	r1, #1
 80002c8:	fbb4 f3f8 	udiv	r3, r4, r8
 80002cc:	fb08 4413 	mls	r4, r8, r3, r4
 80002d0:	fb09 f203 	mul.w	r2, r9, r3
 80002d4:	ea4f 4c15 	mov.w	ip, r5, lsr #16
 80002d8:	ea4c 4404 	orr.w	r4, ip, r4, lsl #16
 80002dc:	42a2      	cmp	r2, r4
 80002de:	d907      	bls.n	80002f0 <__udivmoddi4+0x134>
 80002e0:	19e4      	adds	r4, r4, r7
 80002e2:	f103 30ff 	add.w	r0, r3, #4294967295
 80002e6:	d202      	bcs.n	80002ee <__udivmoddi4+0x132>
 80002e8:	42a2      	cmp	r2, r4
 80002ea:	f200 80d3 	bhi.w	8000494 <__udivmoddi4+0x2d8>
 80002ee:	4603      	mov	r3, r0
 80002f0:	1aa4      	subs	r4, r4, r2
 80002f2:	fbb4 f0f8 	udiv	r0, r4, r8
 80002f6:	fb08 4810 	mls	r8, r8, r0, r4
 80002fa:	fb09 f900 	mul.w	r9, r9, r0
 80002fe:	b2ac      	uxth	r4, r5
 8000300:	ea44 4208 	orr.w	r2, r4, r8, lsl #16
 8000304:	4591      	cmp	r9, r2
 8000306:	d907      	bls.n	8000318 <__udivmoddi4+0x15c>
 8000308:	19d2      	adds	r2, r2, r7
 800030a:	f100 34ff 	add.w	r4, r0, #4294967295
 800030e:	d202      	bcs.n	8000316 <__udivmoddi4+0x15a>
 8000310:	4591      	cmp	r9, r2
 8000312:	f200 80ba 	bhi.w	800048a <__udivmoddi4+0x2ce>
 8000316:	4620      	mov	r0, r4
 8000318:	ebc9 0202 	rsb	r2, r9, r2
 800031c:	ea40 4003 	orr.w	r0, r0, r3, lsl #16
 8000320:	e79b      	b.n	800025a <__udivmoddi4+0x9e>
 8000322:	4631      	mov	r1, r6
 8000324:	4630      	mov	r0, r6
 8000326:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800032a:	fa07 f70e 	lsl.w	r7, r7, lr
 800032e:	f1ce 0c20 	rsb	ip, lr, #32
 8000332:	fa24 f30c 	lsr.w	r3, r4, ip
 8000336:	ea4f 4817 	mov.w	r8, r7, lsr #16
 800033a:	fbb3 faf8 	udiv	sl, r3, r8
 800033e:	fa1f f987 	uxth.w	r9, r7
 8000342:	fb08 351a 	mls	r5, r8, sl, r3
 8000346:	fa20 fc0c 	lsr.w	ip, r0, ip
 800034a:	fa04 f40e 	lsl.w	r4, r4, lr
 800034e:	fb0a fb09 	mul.w	fp, sl, r9
 8000352:	ea4c 0c04 	orr.w	ip, ip, r4
 8000356:	ea4f 421c 	mov.w	r2, ip, lsr #16
 800035a:	ea42 4305 	orr.w	r3, r2, r5, lsl #16
 800035e:	459b      	cmp	fp, r3
 8000360:	fa00 f50e 	lsl.w	r5, r0, lr
 8000364:	d90a      	bls.n	800037c <__udivmoddi4+0x1c0>
 8000366:	19db      	adds	r3, r3, r7
 8000368:	f10a 32ff 	add.w	r2, sl, #4294967295
 800036c:	f080 808b 	bcs.w	8000486 <__udivmoddi4+0x2ca>
 8000370:	459b      	cmp	fp, r3
 8000372:	f240 8088 	bls.w	8000486 <__udivmoddi4+0x2ca>
 8000376:	f1aa 0a02 	sub.w	sl, sl, #2
 800037a:	443b      	add	r3, r7
 800037c:	ebcb 0303 	rsb	r3, fp, r3
 8000380:	fbb3 f0f8 	udiv	r0, r3, r8
 8000384:	fb08 3310 	mls	r3, r8, r0, r3
 8000388:	fb00 f409 	mul.w	r4, r0, r9
 800038c:	fa1f fc8c 	uxth.w	ip, ip
 8000390:	ea4c 4303 	orr.w	r3, ip, r3, lsl #16
 8000394:	429c      	cmp	r4, r3
 8000396:	d907      	bls.n	80003a8 <__udivmoddi4+0x1ec>
 8000398:	19db      	adds	r3, r3, r7
 800039a:	f100 32ff 	add.w	r2, r0, #4294967295
 800039e:	d26e      	bcs.n	800047e <__udivmoddi4+0x2c2>
 80003a0:	429c      	cmp	r4, r3
 80003a2:	d96c      	bls.n	800047e <__udivmoddi4+0x2c2>
 80003a4:	3802      	subs	r0, #2
 80003a6:	443b      	add	r3, r7
 80003a8:	1b1c      	subs	r4, r3, r4
 80003aa:	ea40 410a 	orr.w	r1, r0, sl, lsl #16
 80003ae:	e78b      	b.n	80002c8 <__udivmoddi4+0x10c>
 80003b0:	f1c1 0e20 	rsb	lr, r1, #32
 80003b4:	408b      	lsls	r3, r1
 80003b6:	fa22 fc0e 	lsr.w	ip, r2, lr
 80003ba:	ea4c 0c03 	orr.w	ip, ip, r3
 80003be:	fa24 f70e 	lsr.w	r7, r4, lr
 80003c2:	ea4f 491c 	mov.w	r9, ip, lsr #16
 80003c6:	fbb7 faf9 	udiv	sl, r7, r9
 80003ca:	fa1f f38c 	uxth.w	r3, ip
 80003ce:	fb09 771a 	mls	r7, r9, sl, r7
 80003d2:	fa20 f80e 	lsr.w	r8, r0, lr
 80003d6:	408c      	lsls	r4, r1
 80003d8:	fb0a f503 	mul.w	r5, sl, r3
 80003dc:	ea48 0404 	orr.w	r4, r8, r4
 80003e0:	ea4f 4814 	mov.w	r8, r4, lsr #16
 80003e4:	ea48 4707 	orr.w	r7, r8, r7, lsl #16
 80003e8:	42bd      	cmp	r5, r7
 80003ea:	fa02 f201 	lsl.w	r2, r2, r1
 80003ee:	fa00 fb01 	lsl.w	fp, r0, r1
 80003f2:	d909      	bls.n	8000408 <__udivmoddi4+0x24c>
 80003f4:	eb17 070c 	adds.w	r7, r7, ip
 80003f8:	f10a 30ff 	add.w	r0, sl, #4294967295
 80003fc:	d241      	bcs.n	8000482 <__udivmoddi4+0x2c6>
 80003fe:	42bd      	cmp	r5, r7
 8000400:	d93f      	bls.n	8000482 <__udivmoddi4+0x2c6>
 8000402:	f1aa 0a02 	sub.w	sl, sl, #2
 8000406:	4467      	add	r7, ip
 8000408:	1b7f      	subs	r7, r7, r5
 800040a:	fbb7 f5f9 	udiv	r5, r7, r9
 800040e:	fb09 7715 	mls	r7, r9, r5, r7
 8000412:	fb05 f303 	mul.w	r3, r5, r3
 8000416:	b2a4      	uxth	r4, r4
 8000418:	ea44 4707 	orr.w	r7, r4, r7, lsl #16
 800041c:	42bb      	cmp	r3, r7
 800041e:	d908      	bls.n	8000432 <__udivmoddi4+0x276>
 8000420:	eb17 070c 	adds.w	r7, r7, ip
 8000424:	f105 30ff 	add.w	r0, r5, #4294967295
 8000428:	d227      	bcs.n	800047a <__udivmoddi4+0x2be>
 800042a:	42bb      	cmp	r3, r7
 800042c:	d925      	bls.n	800047a <__udivmoddi4+0x2be>
 800042e:	3d02      	subs	r5, #2
 8000430:	4467      	add	r7, ip
 8000432:	ea45 400a 	orr.w	r0, r5, sl, lsl #16
 8000436:	fba0 8902 	umull	r8, r9, r0, r2
 800043a:	1aff      	subs	r7, r7, r3
 800043c:	454f      	cmp	r7, r9
 800043e:	4645      	mov	r5, r8
 8000440:	464c      	mov	r4, r9
 8000442:	d314      	bcc.n	800046e <__udivmoddi4+0x2b2>
 8000444:	d029      	beq.n	800049a <__udivmoddi4+0x2de>
 8000446:	b366      	cbz	r6, 80004a2 <__udivmoddi4+0x2e6>
 8000448:	ebbb 0305 	subs.w	r3, fp, r5
 800044c:	eb67 0704 	sbc.w	r7, r7, r4
 8000450:	fa07 fe0e 	lsl.w	lr, r7, lr
 8000454:	40cb      	lsrs	r3, r1
 8000456:	40cf      	lsrs	r7, r1
 8000458:	ea4e 0303 	orr.w	r3, lr, r3
 800045c:	e886 0088 	stmia.w	r6, {r3, r7}
 8000460:	2100      	movs	r1, #0
 8000462:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8000466:	4623      	mov	r3, r4
 8000468:	e6f3      	b.n	8000252 <__udivmoddi4+0x96>
 800046a:	4618      	mov	r0, r3
 800046c:	e6da      	b.n	8000224 <__udivmoddi4+0x68>
 800046e:	ebb8 0502 	subs.w	r5, r8, r2
 8000472:	eb69 040c 	sbc.w	r4, r9, ip
 8000476:	3801      	subs	r0, #1
 8000478:	e7e5      	b.n	8000446 <__udivmoddi4+0x28a>
 800047a:	4605      	mov	r5, r0
 800047c:	e7d9      	b.n	8000432 <__udivmoddi4+0x276>
 800047e:	4610      	mov	r0, r2
 8000480:	e792      	b.n	80003a8 <__udivmoddi4+0x1ec>
 8000482:	4682      	mov	sl, r0
 8000484:	e7c0      	b.n	8000408 <__udivmoddi4+0x24c>
 8000486:	4692      	mov	sl, r2
 8000488:	e778      	b.n	800037c <__udivmoddi4+0x1c0>
 800048a:	3802      	subs	r0, #2
 800048c:	443a      	add	r2, r7
 800048e:	e743      	b.n	8000318 <__udivmoddi4+0x15c>
 8000490:	4608      	mov	r0, r1
 8000492:	e704      	b.n	800029e <__udivmoddi4+0xe2>
 8000494:	3b02      	subs	r3, #2
 8000496:	443c      	add	r4, r7
 8000498:	e72a      	b.n	80002f0 <__udivmoddi4+0x134>
 800049a:	45c3      	cmp	fp, r8
 800049c:	d3e7      	bcc.n	800046e <__udivmoddi4+0x2b2>
 800049e:	463c      	mov	r4, r7
 80004a0:	e7d1      	b.n	8000446 <__udivmoddi4+0x28a>
 80004a2:	4631      	mov	r1, r6
 80004a4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080004a8 <__aeabi_idiv0>:
 80004a8:	4770      	bx	lr
 80004aa:	bf00      	nop

080004ac <NVIC_PriorityGroupConfig>:
  *     @arg NVIC_PriorityGroup_4: 4 bits for preemption priority.
  *                                0 bits for subpriority.
  * @retval None
  */
void NVIC_PriorityGroupConfig(uint32_t NVIC_PriorityGroup)
{
 80004ac:	b480      	push	{r7}
 80004ae:	b083      	sub	sp, #12
 80004b0:	af00      	add	r7, sp, #0
 80004b2:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to NVIC_PriorityGroup value */
  SCB->AIRCR = AIRCR_VECTKEY_MASK | NVIC_PriorityGroup;
 80004b4:	4a05      	ldr	r2, [pc, #20]	; (80004cc <NVIC_PriorityGroupConfig+0x20>)
 80004b6:	687b      	ldr	r3, [r7, #4]
 80004b8:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 80004bc:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 80004c0:	60d3      	str	r3, [r2, #12]
}
 80004c2:	bf00      	nop
 80004c4:	370c      	adds	r7, #12
 80004c6:	46bd      	mov	sp, r7
 80004c8:	bc80      	pop	{r7}
 80004ca:	4770      	bx	lr
 80004cc:	e000ed00 	.word	0xe000ed00

080004d0 <NVIC_Init>:
  * @param  NVIC_InitStruct: pointer to a NVIC_InitTypeDef structure that contains
  *         the configuration information for the specified NVIC peripheral.
  * @retval None
  */
void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct)
{
 80004d0:	b480      	push	{r7}
 80004d2:	b085      	sub	sp, #20
 80004d4:	af00      	add	r7, sp, #0
 80004d6:	6078      	str	r0, [r7, #4]
  uint8_t tmppriority = 0x00, tmppre = 0x00, tmpsub = 0x0F;
 80004d8:	2300      	movs	r3, #0
 80004da:	73fb      	strb	r3, [r7, #15]
 80004dc:	2300      	movs	r3, #0
 80004de:	73bb      	strb	r3, [r7, #14]
 80004e0:	230f      	movs	r3, #15
 80004e2:	737b      	strb	r3, [r7, #13]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NVIC_InitStruct->NVIC_IRQChannelCmd));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority));  
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
 80004e4:	687b      	ldr	r3, [r7, #4]
 80004e6:	78db      	ldrb	r3, [r3, #3]
 80004e8:	2b00      	cmp	r3, #0
 80004ea:	d038      	beq.n	800055e <NVIC_Init+0x8e>
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
 80004ec:	4b26      	ldr	r3, [pc, #152]	; (8000588 <NVIC_Init+0xb8>)
 80004ee:	68db      	ldr	r3, [r3, #12]
 80004f0:	43db      	mvns	r3, r3
 80004f2:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 80004f6:	0a1b      	lsrs	r3, r3, #8
 80004f8:	73fb      	strb	r3, [r7, #15]
    tmppre = (0x4 - tmppriority);
 80004fa:	7bfb      	ldrb	r3, [r7, #15]
 80004fc:	f1c3 0304 	rsb	r3, r3, #4
 8000500:	73bb      	strb	r3, [r7, #14]
    tmpsub = tmpsub >> tmppriority;
 8000502:	7b7a      	ldrb	r2, [r7, #13]
 8000504:	7bfb      	ldrb	r3, [r7, #15]
 8000506:	fa42 f303 	asr.w	r3, r2, r3
 800050a:	737b      	strb	r3, [r7, #13]

    tmppriority = (uint32_t)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 800050c:	687b      	ldr	r3, [r7, #4]
 800050e:	785b      	ldrb	r3, [r3, #1]
 8000510:	461a      	mov	r2, r3
 8000512:	7bbb      	ldrb	r3, [r7, #14]
 8000514:	fa02 f303 	lsl.w	r3, r2, r3
 8000518:	73fb      	strb	r3, [r7, #15]
    tmppriority |=  (uint8_t)(NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub);
 800051a:	687b      	ldr	r3, [r7, #4]
 800051c:	789a      	ldrb	r2, [r3, #2]
 800051e:	7b7b      	ldrb	r3, [r7, #13]
 8000520:	4013      	ands	r3, r2
 8000522:	b2da      	uxtb	r2, r3
 8000524:	7bfb      	ldrb	r3, [r7, #15]
 8000526:	4313      	orrs	r3, r2
 8000528:	73fb      	strb	r3, [r7, #15]
    tmppriority = tmppriority << 0x04;
 800052a:	7bfb      	ldrb	r3, [r7, #15]
 800052c:	011b      	lsls	r3, r3, #4
 800052e:	73fb      	strb	r3, [r7, #15]
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
 8000530:	4a16      	ldr	r2, [pc, #88]	; (800058c <NVIC_Init+0xbc>)
 8000532:	687b      	ldr	r3, [r7, #4]
 8000534:	781b      	ldrb	r3, [r3, #0]
 8000536:	4413      	add	r3, r2
 8000538:	7bfa      	ldrb	r2, [r7, #15]
 800053a:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
    
    /* Enable the Selected IRQ Channels --------------------------------------*/
    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 800053e:	4a13      	ldr	r2, [pc, #76]	; (800058c <NVIC_Init+0xbc>)
 8000540:	687b      	ldr	r3, [r7, #4]
 8000542:	781b      	ldrb	r3, [r3, #0]
 8000544:	095b      	lsrs	r3, r3, #5
 8000546:	b2db      	uxtb	r3, r3
 8000548:	4618      	mov	r0, r3
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 800054a:	687b      	ldr	r3, [r7, #4]
 800054c:	781b      	ldrb	r3, [r3, #0]
 800054e:	f003 031f 	and.w	r3, r3, #31
 8000552:	2101      	movs	r1, #1
 8000554:	fa01 f303 	lsl.w	r3, r1, r3
    tmppriority = tmppriority << 0x04;
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
    
    /* Enable the Selected IRQ Channels --------------------------------------*/
    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8000558:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
}
 800055c:	e00f      	b.n	800057e <NVIC_Init+0xae>
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 800055e:	490b      	ldr	r1, [pc, #44]	; (800058c <NVIC_Init+0xbc>)
 8000560:	687b      	ldr	r3, [r7, #4]
 8000562:	781b      	ldrb	r3, [r3, #0]
 8000564:	095b      	lsrs	r3, r3, #5
 8000566:	b2db      	uxtb	r3, r3
 8000568:	4618      	mov	r0, r3
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 800056a:	687b      	ldr	r3, [r7, #4]
 800056c:	781b      	ldrb	r3, [r3, #0]
 800056e:	f003 031f 	and.w	r3, r3, #31
 8000572:	2201      	movs	r2, #1
 8000574:	409a      	lsls	r2, r3
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8000576:	f100 0320 	add.w	r3, r0, #32
 800057a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
}
 800057e:	bf00      	nop
 8000580:	3714      	adds	r7, #20
 8000582:	46bd      	mov	sp, r7
 8000584:	bc80      	pop	{r7}
 8000586:	4770      	bx	lr
 8000588:	e000ed00 	.word	0xe000ed00
 800058c:	e000e100 	.word	0xe000e100

08000590 <ADC_Init>:
  * @param  ADC_InitStruct: pointer to an ADC_InitTypeDef structure that contains 
  *         the configuration information for the specified ADC peripheral.
  * @retval None
  */
void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)               
{
 8000590:	b480      	push	{r7}
 8000592:	b085      	sub	sp, #20
 8000594:	af00      	add	r7, sp, #0
 8000596:	6078      	str	r0, [r7, #4]
 8000598:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg1 = 0;
 800059a:	2300      	movs	r3, #0
 800059c:	60fb      	str	r3, [r7, #12]
  uint8_t tmpreg2 = 0;
 800059e:	2300      	movs	r3, #0
 80005a0:	72fb      	strb	r3, [r7, #11]
  assert_param(IS_ADC_DATA_ALIGN(ADC_InitStruct->ADC_DataAlign)); 
  assert_param(IS_ADC_REGULAR_LENGTH(ADC_InitStruct->ADC_NbrOfConversion));
  
  /*---------------------------- ADCx CR1 Configuration -----------------*/
  /* Get the ADCx CR1 value */
  tmpreg1 = ADCx->CR1;
 80005a2:	687b      	ldr	r3, [r7, #4]
 80005a4:	685b      	ldr	r3, [r3, #4]
 80005a6:	60fb      	str	r3, [r7, #12]
  /* Clear RES and SCAN bits */ 
  tmpreg1 &= CR1_CLEAR_MASK;
 80005a8:	68fb      	ldr	r3, [r7, #12]
 80005aa:	f023 7340 	bic.w	r3, r3, #50331648	; 0x3000000
 80005ae:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 80005b2:	60fb      	str	r3, [r7, #12]
  /* Configure ADCx: scan conversion mode and resolution */
  /* Set SCAN bit according to ADC_ScanConvMode value */
  /* Set RES bit according to ADC_Resolution value */ 
  tmpreg1 |= (uint32_t)(((uint32_t)ADC_InitStruct->ADC_ScanConvMode << 8) | ADC_InitStruct->ADC_Resolution);
 80005b4:	683b      	ldr	r3, [r7, #0]
 80005b6:	791b      	ldrb	r3, [r3, #4]
 80005b8:	021a      	lsls	r2, r3, #8
 80005ba:	683b      	ldr	r3, [r7, #0]
 80005bc:	681b      	ldr	r3, [r3, #0]
 80005be:	4313      	orrs	r3, r2
 80005c0:	68fa      	ldr	r2, [r7, #12]
 80005c2:	4313      	orrs	r3, r2
 80005c4:	60fb      	str	r3, [r7, #12]
  /* Write to ADCx CR1 */
  ADCx->CR1 = tmpreg1;
 80005c6:	687b      	ldr	r3, [r7, #4]
 80005c8:	68fa      	ldr	r2, [r7, #12]
 80005ca:	605a      	str	r2, [r3, #4]
  
  /*---------------------------- ADCx CR2 Configuration -----------------*/
  /* Get the ADCx CR2 value */
  tmpreg1 = ADCx->CR2;
 80005cc:	687b      	ldr	r3, [r7, #4]
 80005ce:	689b      	ldr	r3, [r3, #8]
 80005d0:	60fb      	str	r3, [r7, #12]
  /* Clear CONT, ALIGN, EXTEN and EXTSEL bits */
  tmpreg1 &= CR2_CLEAR_MASK;
 80005d2:	68fa      	ldr	r2, [r7, #12]
 80005d4:	4b17      	ldr	r3, [pc, #92]	; (8000634 <ADC_Init+0xa4>)
 80005d6:	4013      	ands	r3, r2
 80005d8:	60fb      	str	r3, [r7, #12]
  /* Configure ADCx: external trigger event and edge, data alignment and continuous conversion mode */
  /* Set ALIGN bit according to ADC_DataAlign value */
  /* Set EXTEN bits according to ADC_ExternalTrigConvEdge value */ 
  /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
  /* Set CONT bit according to ADC_ContinuousConvMode value */
  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | ADC_InitStruct->ADC_ExternalTrigConv | 
 80005da:	683b      	ldr	r3, [r7, #0]
 80005dc:	691a      	ldr	r2, [r3, #16]
 80005de:	683b      	ldr	r3, [r7, #0]
 80005e0:	68db      	ldr	r3, [r3, #12]
 80005e2:	431a      	orrs	r2, r3
              ADC_InitStruct->ADC_ExternalTrigConvEdge | ((uint32_t)ADC_InitStruct->ADC_ContinuousConvMode << 1));
 80005e4:	683b      	ldr	r3, [r7, #0]
 80005e6:	689b      	ldr	r3, [r3, #8]
  /* Configure ADCx: external trigger event and edge, data alignment and continuous conversion mode */
  /* Set ALIGN bit according to ADC_DataAlign value */
  /* Set EXTEN bits according to ADC_ExternalTrigConvEdge value */ 
  /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
  /* Set CONT bit according to ADC_ContinuousConvMode value */
  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | ADC_InitStruct->ADC_ExternalTrigConv | 
 80005e8:	431a      	orrs	r2, r3
              ADC_InitStruct->ADC_ExternalTrigConvEdge | ((uint32_t)ADC_InitStruct->ADC_ContinuousConvMode << 1));
 80005ea:	683b      	ldr	r3, [r7, #0]
 80005ec:	795b      	ldrb	r3, [r3, #5]
 80005ee:	005b      	lsls	r3, r3, #1
  /* Configure ADCx: external trigger event and edge, data alignment and continuous conversion mode */
  /* Set ALIGN bit according to ADC_DataAlign value */
  /* Set EXTEN bits according to ADC_ExternalTrigConvEdge value */ 
  /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
  /* Set CONT bit according to ADC_ContinuousConvMode value */
  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | ADC_InitStruct->ADC_ExternalTrigConv | 
 80005f0:	4313      	orrs	r3, r2
 80005f2:	68fa      	ldr	r2, [r7, #12]
 80005f4:	4313      	orrs	r3, r2
 80005f6:	60fb      	str	r3, [r7, #12]
              ADC_InitStruct->ADC_ExternalTrigConvEdge | ((uint32_t)ADC_InitStruct->ADC_ContinuousConvMode << 1));
  /* Write to ADCx CR2 */
  ADCx->CR2 = tmpreg1;
 80005f8:	687b      	ldr	r3, [r7, #4]
 80005fa:	68fa      	ldr	r2, [r7, #12]
 80005fc:	609a      	str	r2, [r3, #8]
  
  /*---------------------------- ADCx SQR1 Configuration -----------------*/
  /* Get the ADCx SQR1 value */
  tmpreg1 = ADCx->SQR1;
 80005fe:	687b      	ldr	r3, [r7, #4]
 8000600:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000602:	60fb      	str	r3, [r7, #12]
  /* Clear L bits */
  tmpreg1 &= SQR1_L_RESET;
 8000604:	68fb      	ldr	r3, [r7, #12]
 8000606:	f023 73f8 	bic.w	r3, r3, #32505856	; 0x1f00000
 800060a:	60fb      	str	r3, [r7, #12]
  /* Configure ADCx: regular channel sequence length */
  /* Set L bits according to ADC_NbrOfConversion value */ 
  tmpreg2 |= (uint8_t)(ADC_InitStruct->ADC_NbrOfConversion - (uint8_t)1);
 800060c:	683b      	ldr	r3, [r7, #0]
 800060e:	7d1b      	ldrb	r3, [r3, #20]
 8000610:	3b01      	subs	r3, #1
 8000612:	b2da      	uxtb	r2, r3
 8000614:	7afb      	ldrb	r3, [r7, #11]
 8000616:	4313      	orrs	r3, r2
 8000618:	72fb      	strb	r3, [r7, #11]
  tmpreg1 |= ((uint32_t)tmpreg2 << 20);
 800061a:	7afb      	ldrb	r3, [r7, #11]
 800061c:	051b      	lsls	r3, r3, #20
 800061e:	68fa      	ldr	r2, [r7, #12]
 8000620:	4313      	orrs	r3, r2
 8000622:	60fb      	str	r3, [r7, #12]
  /* Write to ADCx SQR1 */
  ADCx->SQR1 = tmpreg1;
 8000624:	687b      	ldr	r3, [r7, #4]
 8000626:	68fa      	ldr	r2, [r7, #12]
 8000628:	631a      	str	r2, [r3, #48]	; 0x30
}
 800062a:	bf00      	nop
 800062c:	3714      	adds	r7, #20
 800062e:	46bd      	mov	sp, r7
 8000630:	bc80      	pop	{r7}
 8000632:	4770      	bx	lr
 8000634:	c0fff7fd 	.word	0xc0fff7fd

08000638 <ADC_StructInit>:
  * @param  ADC_InitStruct: pointer to an ADC_InitTypeDef structure which will 
  *         be initialized.
  * @retval None
  */
void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)                            
{
 8000638:	b480      	push	{r7}
 800063a:	b083      	sub	sp, #12
 800063c:	af00      	add	r7, sp, #0
 800063e:	6078      	str	r0, [r7, #4]
  /* Reset ADC init structure parameters values */
  /* Initialize the ADC_Resolution member */
  ADC_InitStruct->ADC_Resolution = ADC_Resolution_12b;
 8000640:	687b      	ldr	r3, [r7, #4]
 8000642:	2200      	movs	r2, #0
 8000644:	601a      	str	r2, [r3, #0]

  /* Initialize the ADC_ScanConvMode member */
  ADC_InitStruct->ADC_ScanConvMode = DISABLE;
 8000646:	687b      	ldr	r3, [r7, #4]
 8000648:	2200      	movs	r2, #0
 800064a:	711a      	strb	r2, [r3, #4]

  /* Initialize the ADC_ContinuousConvMode member */
  ADC_InitStruct->ADC_ContinuousConvMode = DISABLE;
 800064c:	687b      	ldr	r3, [r7, #4]
 800064e:	2200      	movs	r2, #0
 8000650:	715a      	strb	r2, [r3, #5]

  /* Initialize the ADC_ExternalTrigConvEdge member */
  ADC_InitStruct->ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;
 8000652:	687b      	ldr	r3, [r7, #4]
 8000654:	2200      	movs	r2, #0
 8000656:	609a      	str	r2, [r3, #8]

  /* Initialize the ADC_ExternalTrigConv member */
  ADC_InitStruct->ADC_ExternalTrigConv = ADC_ExternalTrigConv_T2_CC2;
 8000658:	687b      	ldr	r3, [r7, #4]
 800065a:	f04f 7240 	mov.w	r2, #50331648	; 0x3000000
 800065e:	60da      	str	r2, [r3, #12]

  /* Initialize the ADC_DataAlign member */
  ADC_InitStruct->ADC_DataAlign = ADC_DataAlign_Right;
 8000660:	687b      	ldr	r3, [r7, #4]
 8000662:	2200      	movs	r2, #0
 8000664:	611a      	str	r2, [r3, #16]

  /* Initialize the ADC_NbrOfConversion member */
  ADC_InitStruct->ADC_NbrOfConversion = 1;
 8000666:	687b      	ldr	r3, [r7, #4]
 8000668:	2201      	movs	r2, #1
 800066a:	751a      	strb	r2, [r3, #20]
}
 800066c:	bf00      	nop
 800066e:	370c      	adds	r7, #12
 8000670:	46bd      	mov	sp, r7
 8000672:	bc80      	pop	{r7}
 8000674:	4770      	bx	lr
 8000676:	bf00      	nop

08000678 <ADC_Cmd>:
  * @param  NewState: new state of the ADCx peripheral.
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
 8000678:	b480      	push	{r7}
 800067a:	b083      	sub	sp, #12
 800067c:	af00      	add	r7, sp, #0
 800067e:	6078      	str	r0, [r7, #4]
 8000680:	460b      	mov	r3, r1
 8000682:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8000684:	78fb      	ldrb	r3, [r7, #3]
 8000686:	2b00      	cmp	r3, #0
 8000688:	d006      	beq.n	8000698 <ADC_Cmd+0x20>
  {
    /* Set the ADON bit to wake up the ADC from power down mode */
    ADCx->CR2 |= (uint32_t)ADC_CR2_ADON;
 800068a:	687b      	ldr	r3, [r7, #4]
 800068c:	689b      	ldr	r3, [r3, #8]
 800068e:	f043 0201 	orr.w	r2, r3, #1
 8000692:	687b      	ldr	r3, [r7, #4]
 8000694:	609a      	str	r2, [r3, #8]
  else
  {
    /* Disable the selected ADC peripheral */
    ADCx->CR2 &= (uint32_t)(~ADC_CR2_ADON);
  }
}
 8000696:	e005      	b.n	80006a4 <ADC_Cmd+0x2c>
    ADCx->CR2 |= (uint32_t)ADC_CR2_ADON;
  }
  else
  {
    /* Disable the selected ADC peripheral */
    ADCx->CR2 &= (uint32_t)(~ADC_CR2_ADON);
 8000698:	687b      	ldr	r3, [r7, #4]
 800069a:	689b      	ldr	r3, [r3, #8]
 800069c:	f023 0201 	bic.w	r2, r3, #1
 80006a0:	687b      	ldr	r3, [r7, #4]
 80006a2:	609a      	str	r2, [r3, #8]
  }
}
 80006a4:	bf00      	nop
 80006a6:	370c      	adds	r7, #12
 80006a8:	46bd      	mov	sp, r7
 80006aa:	bc80      	pop	{r7}
 80006ac:	4770      	bx	lr
 80006ae:	bf00      	nop

080006b0 <ADC_RegularChannelConfig>:
  *     @arg ADC_SampleTime_192Cycles: Sample time equal to 192 cycles	
  *     @arg ADC_SampleTime_384Cycles: Sample time equal to 384 cycles	
  * @retval None
  */
void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
{
 80006b0:	b480      	push	{r7}
 80006b2:	b085      	sub	sp, #20
 80006b4:	af00      	add	r7, sp, #0
 80006b6:	6078      	str	r0, [r7, #4]
 80006b8:	4608      	mov	r0, r1
 80006ba:	4611      	mov	r1, r2
 80006bc:	461a      	mov	r2, r3
 80006be:	4603      	mov	r3, r0
 80006c0:	70fb      	strb	r3, [r7, #3]
 80006c2:	460b      	mov	r3, r1
 80006c4:	70bb      	strb	r3, [r7, #2]
 80006c6:	4613      	mov	r3, r2
 80006c8:	707b      	strb	r3, [r7, #1]
  uint32_t tmpreg1 = 0, tmpreg2 = 0;
 80006ca:	2300      	movs	r3, #0
 80006cc:	60fb      	str	r3, [r7, #12]
 80006ce:	2300      	movs	r3, #0
 80006d0:	60bb      	str	r3, [r7, #8]
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  assert_param(IS_ADC_REGULAR_RANK(Rank));
  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));

  /* If ADC_Channel_30 or ADC_Channel_31 is selected */
  if (ADC_Channel > ADC_Channel_29)
 80006d2:	78fb      	ldrb	r3, [r7, #3]
 80006d4:	2b1d      	cmp	r3, #29
 80006d6:	d923      	bls.n	8000720 <ADC_RegularChannelConfig+0x70>
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR0;
 80006d8:	687b      	ldr	r3, [r7, #4]
 80006da:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 80006dc:	60fb      	str	r3, [r7, #12]
    /* Calculate the mask to clear */
    tmpreg2 = SMPR0_SMP_SET << (3 * (ADC_Channel - 30));
 80006de:	78fb      	ldrb	r3, [r7, #3]
 80006e0:	f1a3 021e 	sub.w	r2, r3, #30
 80006e4:	4613      	mov	r3, r2
 80006e6:	005b      	lsls	r3, r3, #1
 80006e8:	4413      	add	r3, r2
 80006ea:	2207      	movs	r2, #7
 80006ec:	fa02 f303 	lsl.w	r3, r2, r3
 80006f0:	60bb      	str	r3, [r7, #8]
    /* Clear the old sample time */
    tmpreg1 &= ~tmpreg2;
 80006f2:	68bb      	ldr	r3, [r7, #8]
 80006f4:	43db      	mvns	r3, r3
 80006f6:	68fa      	ldr	r2, [r7, #12]
 80006f8:	4013      	ands	r3, r2
 80006fa:	60fb      	str	r3, [r7, #12]
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 30));
 80006fc:	7879      	ldrb	r1, [r7, #1]
 80006fe:	78fb      	ldrb	r3, [r7, #3]
 8000700:	f1a3 021e 	sub.w	r2, r3, #30
 8000704:	4613      	mov	r3, r2
 8000706:	005b      	lsls	r3, r3, #1
 8000708:	4413      	add	r3, r2
 800070a:	fa01 f303 	lsl.w	r3, r1, r3
 800070e:	60bb      	str	r3, [r7, #8]
    /* Set the new sample time */
    tmpreg1 |= tmpreg2;
 8000710:	68fa      	ldr	r2, [r7, #12]
 8000712:	68bb      	ldr	r3, [r7, #8]
 8000714:	4313      	orrs	r3, r2
 8000716:	60fb      	str	r3, [r7, #12]
    /* Store the new register value */
    ADCx->SMPR0 = tmpreg1;
 8000718:	687b      	ldr	r3, [r7, #4]
 800071a:	68fa      	ldr	r2, [r7, #12]
 800071c:	65da      	str	r2, [r3, #92]	; 0x5c
 800071e:	e06c      	b.n	80007fa <ADC_RegularChannelConfig+0x14a>
  }
  /* If ADC_Channel_20 ... ADC_Channel_29 is selected */
  else if (ADC_Channel > ADC_Channel_19)
 8000720:	78fb      	ldrb	r3, [r7, #3]
 8000722:	2b13      	cmp	r3, #19
 8000724:	d923      	bls.n	800076e <ADC_RegularChannelConfig+0xbe>
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR1;
 8000726:	687b      	ldr	r3, [r7, #4]
 8000728:	68db      	ldr	r3, [r3, #12]
 800072a:	60fb      	str	r3, [r7, #12]
    /* Calculate the mask to clear */
    tmpreg2 = SMPR1_SMP_SET << (3 * (ADC_Channel - 20));
 800072c:	78fb      	ldrb	r3, [r7, #3]
 800072e:	f1a3 0214 	sub.w	r2, r3, #20
 8000732:	4613      	mov	r3, r2
 8000734:	005b      	lsls	r3, r3, #1
 8000736:	4413      	add	r3, r2
 8000738:	2207      	movs	r2, #7
 800073a:	fa02 f303 	lsl.w	r3, r2, r3
 800073e:	60bb      	str	r3, [r7, #8]
    /* Clear the old sample time */
    tmpreg1 &= ~tmpreg2;
 8000740:	68bb      	ldr	r3, [r7, #8]
 8000742:	43db      	mvns	r3, r3
 8000744:	68fa      	ldr	r2, [r7, #12]
 8000746:	4013      	ands	r3, r2
 8000748:	60fb      	str	r3, [r7, #12]
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 20));
 800074a:	7879      	ldrb	r1, [r7, #1]
 800074c:	78fb      	ldrb	r3, [r7, #3]
 800074e:	f1a3 0214 	sub.w	r2, r3, #20
 8000752:	4613      	mov	r3, r2
 8000754:	005b      	lsls	r3, r3, #1
 8000756:	4413      	add	r3, r2
 8000758:	fa01 f303 	lsl.w	r3, r1, r3
 800075c:	60bb      	str	r3, [r7, #8]
    /* Set the new sample time */
    tmpreg1 |= tmpreg2;
 800075e:	68fa      	ldr	r2, [r7, #12]
 8000760:	68bb      	ldr	r3, [r7, #8]
 8000762:	4313      	orrs	r3, r2
 8000764:	60fb      	str	r3, [r7, #12]
    /* Store the new register value */
    ADCx->SMPR1 = tmpreg1;
 8000766:	687b      	ldr	r3, [r7, #4]
 8000768:	68fa      	ldr	r2, [r7, #12]
 800076a:	60da      	str	r2, [r3, #12]
 800076c:	e045      	b.n	80007fa <ADC_RegularChannelConfig+0x14a>
  }
  /* If ADC_Channel_10 ... ADC_Channel_19 is selected */
  else if (ADC_Channel > ADC_Channel_9)
 800076e:	78fb      	ldrb	r3, [r7, #3]
 8000770:	2b09      	cmp	r3, #9
 8000772:	d923      	bls.n	80007bc <ADC_RegularChannelConfig+0x10c>
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR2;
 8000774:	687b      	ldr	r3, [r7, #4]
 8000776:	691b      	ldr	r3, [r3, #16]
 8000778:	60fb      	str	r3, [r7, #12]
    /* Calculate the mask to clear */
    tmpreg2 = SMPR2_SMP_SET << (3 * (ADC_Channel - 10));
 800077a:	78fb      	ldrb	r3, [r7, #3]
 800077c:	f1a3 020a 	sub.w	r2, r3, #10
 8000780:	4613      	mov	r3, r2
 8000782:	005b      	lsls	r3, r3, #1
 8000784:	4413      	add	r3, r2
 8000786:	2207      	movs	r2, #7
 8000788:	fa02 f303 	lsl.w	r3, r2, r3
 800078c:	60bb      	str	r3, [r7, #8]
    /* Clear the old sample time */
    tmpreg1 &= ~tmpreg2;
 800078e:	68bb      	ldr	r3, [r7, #8]
 8000790:	43db      	mvns	r3, r3
 8000792:	68fa      	ldr	r2, [r7, #12]
 8000794:	4013      	ands	r3, r2
 8000796:	60fb      	str	r3, [r7, #12]
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 10));
 8000798:	7879      	ldrb	r1, [r7, #1]
 800079a:	78fb      	ldrb	r3, [r7, #3]
 800079c:	f1a3 020a 	sub.w	r2, r3, #10
 80007a0:	4613      	mov	r3, r2
 80007a2:	005b      	lsls	r3, r3, #1
 80007a4:	4413      	add	r3, r2
 80007a6:	fa01 f303 	lsl.w	r3, r1, r3
 80007aa:	60bb      	str	r3, [r7, #8]
    /* Set the new sample time */
    tmpreg1 |= tmpreg2;
 80007ac:	68fa      	ldr	r2, [r7, #12]
 80007ae:	68bb      	ldr	r3, [r7, #8]
 80007b0:	4313      	orrs	r3, r2
 80007b2:	60fb      	str	r3, [r7, #12]
    /* Store the new register value */
    ADCx->SMPR2 = tmpreg1;
 80007b4:	687b      	ldr	r3, [r7, #4]
 80007b6:	68fa      	ldr	r2, [r7, #12]
 80007b8:	611a      	str	r2, [r3, #16]
 80007ba:	e01e      	b.n	80007fa <ADC_RegularChannelConfig+0x14a>
  }
  else /* ADC_Channel include in ADC_Channel_[0..9] */
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR3;
 80007bc:	687b      	ldr	r3, [r7, #4]
 80007be:	695b      	ldr	r3, [r3, #20]
 80007c0:	60fb      	str	r3, [r7, #12]
    /* Calculate the mask to clear */
    tmpreg2 = SMPR3_SMP_SET << (3 * ADC_Channel);
 80007c2:	78fa      	ldrb	r2, [r7, #3]
 80007c4:	4613      	mov	r3, r2
 80007c6:	005b      	lsls	r3, r3, #1
 80007c8:	4413      	add	r3, r2
 80007ca:	2207      	movs	r2, #7
 80007cc:	fa02 f303 	lsl.w	r3, r2, r3
 80007d0:	60bb      	str	r3, [r7, #8]
    /* Clear the old sample time */
    tmpreg1 &= ~tmpreg2;
 80007d2:	68bb      	ldr	r3, [r7, #8]
 80007d4:	43db      	mvns	r3, r3
 80007d6:	68fa      	ldr	r2, [r7, #12]
 80007d8:	4013      	ands	r3, r2
 80007da:	60fb      	str	r3, [r7, #12]
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
 80007dc:	7879      	ldrb	r1, [r7, #1]
 80007de:	78fa      	ldrb	r2, [r7, #3]
 80007e0:	4613      	mov	r3, r2
 80007e2:	005b      	lsls	r3, r3, #1
 80007e4:	4413      	add	r3, r2
 80007e6:	fa01 f303 	lsl.w	r3, r1, r3
 80007ea:	60bb      	str	r3, [r7, #8]
    /* Set the new sample time */
    tmpreg1 |= tmpreg2;
 80007ec:	68fa      	ldr	r2, [r7, #12]
 80007ee:	68bb      	ldr	r3, [r7, #8]
 80007f0:	4313      	orrs	r3, r2
 80007f2:	60fb      	str	r3, [r7, #12]
    /* Store the new register value */
    ADCx->SMPR3 = tmpreg1;
 80007f4:	687b      	ldr	r3, [r7, #4]
 80007f6:	68fa      	ldr	r2, [r7, #12]
 80007f8:	615a      	str	r2, [r3, #20]
  }
  /* For Rank 1 to 6 */
  if (Rank < 7)
 80007fa:	78bb      	ldrb	r3, [r7, #2]
 80007fc:	2b06      	cmp	r3, #6
 80007fe:	d821      	bhi.n	8000844 <ADC_RegularChannelConfig+0x194>
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR5;
 8000800:	687b      	ldr	r3, [r7, #4]
 8000802:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8000804:	60fb      	str	r3, [r7, #12]
    /* Calculate the mask to clear */
    tmpreg2 = SQR5_SQ_SET << (5 * (Rank - 1));
 8000806:	78bb      	ldrb	r3, [r7, #2]
 8000808:	1e5a      	subs	r2, r3, #1
 800080a:	4613      	mov	r3, r2
 800080c:	009b      	lsls	r3, r3, #2
 800080e:	4413      	add	r3, r2
 8000810:	221f      	movs	r2, #31
 8000812:	fa02 f303 	lsl.w	r3, r2, r3
 8000816:	60bb      	str	r3, [r7, #8]
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
 8000818:	68bb      	ldr	r3, [r7, #8]
 800081a:	43db      	mvns	r3, r3
 800081c:	68fa      	ldr	r2, [r7, #12]
 800081e:	4013      	ands	r3, r2
 8000820:	60fb      	str	r3, [r7, #12]
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 1));
 8000822:	78f9      	ldrb	r1, [r7, #3]
 8000824:	78bb      	ldrb	r3, [r7, #2]
 8000826:	1e5a      	subs	r2, r3, #1
 8000828:	4613      	mov	r3, r2
 800082a:	009b      	lsls	r3, r3, #2
 800082c:	4413      	add	r3, r2
 800082e:	fa01 f303 	lsl.w	r3, r1, r3
 8000832:	60bb      	str	r3, [r7, #8]
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
 8000834:	68fa      	ldr	r2, [r7, #12]
 8000836:	68bb      	ldr	r3, [r7, #8]
 8000838:	4313      	orrs	r3, r2
 800083a:	60fb      	str	r3, [r7, #12]
    /* Store the new register value */
    ADCx->SQR5 = tmpreg1;
 800083c:	687b      	ldr	r3, [r7, #4]
 800083e:	68fa      	ldr	r2, [r7, #12]
 8000840:	641a      	str	r2, [r3, #64]	; 0x40
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
    /* Store the new register value */
    ADCx->SQR1 = tmpreg1;
  }
}
 8000842:	e095      	b.n	8000970 <ADC_RegularChannelConfig+0x2c0>
    tmpreg1 |= tmpreg2;
    /* Store the new register value */
    ADCx->SQR5 = tmpreg1;
  }
  /* For Rank 7 to 12 */
  else if (Rank < 13)
 8000844:	78bb      	ldrb	r3, [r7, #2]
 8000846:	2b0c      	cmp	r3, #12
 8000848:	d821      	bhi.n	800088e <ADC_RegularChannelConfig+0x1de>
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR4;
 800084a:	687b      	ldr	r3, [r7, #4]
 800084c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800084e:	60fb      	str	r3, [r7, #12]
    /* Calculate the mask to clear */
    tmpreg2 = SQR4_SQ_SET << (5 * (Rank - 7));
 8000850:	78bb      	ldrb	r3, [r7, #2]
 8000852:	1fda      	subs	r2, r3, #7
 8000854:	4613      	mov	r3, r2
 8000856:	009b      	lsls	r3, r3, #2
 8000858:	4413      	add	r3, r2
 800085a:	221f      	movs	r2, #31
 800085c:	fa02 f303 	lsl.w	r3, r2, r3
 8000860:	60bb      	str	r3, [r7, #8]
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
 8000862:	68bb      	ldr	r3, [r7, #8]
 8000864:	43db      	mvns	r3, r3
 8000866:	68fa      	ldr	r2, [r7, #12]
 8000868:	4013      	ands	r3, r2
 800086a:	60fb      	str	r3, [r7, #12]
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 7));
 800086c:	78f9      	ldrb	r1, [r7, #3]
 800086e:	78bb      	ldrb	r3, [r7, #2]
 8000870:	1fda      	subs	r2, r3, #7
 8000872:	4613      	mov	r3, r2
 8000874:	009b      	lsls	r3, r3, #2
 8000876:	4413      	add	r3, r2
 8000878:	fa01 f303 	lsl.w	r3, r1, r3
 800087c:	60bb      	str	r3, [r7, #8]
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
 800087e:	68fa      	ldr	r2, [r7, #12]
 8000880:	68bb      	ldr	r3, [r7, #8]
 8000882:	4313      	orrs	r3, r2
 8000884:	60fb      	str	r3, [r7, #12]
    /* Store the new register value */
    ADCx->SQR4 = tmpreg1;
 8000886:	687b      	ldr	r3, [r7, #4]
 8000888:	68fa      	ldr	r2, [r7, #12]
 800088a:	63da      	str	r2, [r3, #60]	; 0x3c
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
    /* Store the new register value */
    ADCx->SQR1 = tmpreg1;
  }
}
 800088c:	e070      	b.n	8000970 <ADC_RegularChannelConfig+0x2c0>
    tmpreg1 |= tmpreg2;
    /* Store the new register value */
    ADCx->SQR4 = tmpreg1;
  }  
  /* For Rank 13 to 18 */
  else if (Rank < 19)
 800088e:	78bb      	ldrb	r3, [r7, #2]
 8000890:	2b12      	cmp	r3, #18
 8000892:	d823      	bhi.n	80008dc <ADC_RegularChannelConfig+0x22c>
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR3;
 8000894:	687b      	ldr	r3, [r7, #4]
 8000896:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8000898:	60fb      	str	r3, [r7, #12]
    /* Calculate the mask to clear */
    tmpreg2 = SQR3_SQ_SET << (5 * (Rank - 13));
 800089a:	78bb      	ldrb	r3, [r7, #2]
 800089c:	f1a3 020d 	sub.w	r2, r3, #13
 80008a0:	4613      	mov	r3, r2
 80008a2:	009b      	lsls	r3, r3, #2
 80008a4:	4413      	add	r3, r2
 80008a6:	221f      	movs	r2, #31
 80008a8:	fa02 f303 	lsl.w	r3, r2, r3
 80008ac:	60bb      	str	r3, [r7, #8]
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
 80008ae:	68bb      	ldr	r3, [r7, #8]
 80008b0:	43db      	mvns	r3, r3
 80008b2:	68fa      	ldr	r2, [r7, #12]
 80008b4:	4013      	ands	r3, r2
 80008b6:	60fb      	str	r3, [r7, #12]
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 13));
 80008b8:	78f9      	ldrb	r1, [r7, #3]
 80008ba:	78bb      	ldrb	r3, [r7, #2]
 80008bc:	f1a3 020d 	sub.w	r2, r3, #13
 80008c0:	4613      	mov	r3, r2
 80008c2:	009b      	lsls	r3, r3, #2
 80008c4:	4413      	add	r3, r2
 80008c6:	fa01 f303 	lsl.w	r3, r1, r3
 80008ca:	60bb      	str	r3, [r7, #8]
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
 80008cc:	68fa      	ldr	r2, [r7, #12]
 80008ce:	68bb      	ldr	r3, [r7, #8]
 80008d0:	4313      	orrs	r3, r2
 80008d2:	60fb      	str	r3, [r7, #12]
    /* Store the new register value */
    ADCx->SQR3 = tmpreg1;
 80008d4:	687b      	ldr	r3, [r7, #4]
 80008d6:	68fa      	ldr	r2, [r7, #12]
 80008d8:	639a      	str	r2, [r3, #56]	; 0x38
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
    /* Store the new register value */
    ADCx->SQR1 = tmpreg1;
  }
}
 80008da:	e049      	b.n	8000970 <ADC_RegularChannelConfig+0x2c0>
    /* Store the new register value */
    ADCx->SQR3 = tmpreg1;
  }
    
  /* For Rank 19 to 24 */
  else if (Rank < 25)
 80008dc:	78bb      	ldrb	r3, [r7, #2]
 80008de:	2b18      	cmp	r3, #24
 80008e0:	d823      	bhi.n	800092a <ADC_RegularChannelConfig+0x27a>
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR2;
 80008e2:	687b      	ldr	r3, [r7, #4]
 80008e4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80008e6:	60fb      	str	r3, [r7, #12]
    /* Calculate the mask to clear */
    tmpreg2 = SQR2_SQ_SET << (5 * (Rank - 19));
 80008e8:	78bb      	ldrb	r3, [r7, #2]
 80008ea:	f1a3 0213 	sub.w	r2, r3, #19
 80008ee:	4613      	mov	r3, r2
 80008f0:	009b      	lsls	r3, r3, #2
 80008f2:	4413      	add	r3, r2
 80008f4:	221f      	movs	r2, #31
 80008f6:	fa02 f303 	lsl.w	r3, r2, r3
 80008fa:	60bb      	str	r3, [r7, #8]
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
 80008fc:	68bb      	ldr	r3, [r7, #8]
 80008fe:	43db      	mvns	r3, r3
 8000900:	68fa      	ldr	r2, [r7, #12]
 8000902:	4013      	ands	r3, r2
 8000904:	60fb      	str	r3, [r7, #12]
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 19));
 8000906:	78f9      	ldrb	r1, [r7, #3]
 8000908:	78bb      	ldrb	r3, [r7, #2]
 800090a:	f1a3 0213 	sub.w	r2, r3, #19
 800090e:	4613      	mov	r3, r2
 8000910:	009b      	lsls	r3, r3, #2
 8000912:	4413      	add	r3, r2
 8000914:	fa01 f303 	lsl.w	r3, r1, r3
 8000918:	60bb      	str	r3, [r7, #8]
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
 800091a:	68fa      	ldr	r2, [r7, #12]
 800091c:	68bb      	ldr	r3, [r7, #8]
 800091e:	4313      	orrs	r3, r2
 8000920:	60fb      	str	r3, [r7, #12]
    /* Store the new register value */
    ADCx->SQR2 = tmpreg1;
 8000922:	687b      	ldr	r3, [r7, #4]
 8000924:	68fa      	ldr	r2, [r7, #12]
 8000926:	635a      	str	r2, [r3, #52]	; 0x34
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
    /* Store the new register value */
    ADCx->SQR1 = tmpreg1;
  }
}
 8000928:	e022      	b.n	8000970 <ADC_RegularChannelConfig+0x2c0>
  
  /* For Rank 25 to 28 */
  else
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR1;
 800092a:	687b      	ldr	r3, [r7, #4]
 800092c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800092e:	60fb      	str	r3, [r7, #12]
    /* Calculate the mask to clear */
    tmpreg2 = SQR1_SQ_SET << (5 * (Rank - 25));
 8000930:	78bb      	ldrb	r3, [r7, #2]
 8000932:	f1a3 0219 	sub.w	r2, r3, #25
 8000936:	4613      	mov	r3, r2
 8000938:	009b      	lsls	r3, r3, #2
 800093a:	4413      	add	r3, r2
 800093c:	221f      	movs	r2, #31
 800093e:	fa02 f303 	lsl.w	r3, r2, r3
 8000942:	60bb      	str	r3, [r7, #8]
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
 8000944:	68bb      	ldr	r3, [r7, #8]
 8000946:	43db      	mvns	r3, r3
 8000948:	68fa      	ldr	r2, [r7, #12]
 800094a:	4013      	ands	r3, r2
 800094c:	60fb      	str	r3, [r7, #12]
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 25));
 800094e:	78f9      	ldrb	r1, [r7, #3]
 8000950:	78bb      	ldrb	r3, [r7, #2]
 8000952:	f1a3 0219 	sub.w	r2, r3, #25
 8000956:	4613      	mov	r3, r2
 8000958:	009b      	lsls	r3, r3, #2
 800095a:	4413      	add	r3, r2
 800095c:	fa01 f303 	lsl.w	r3, r1, r3
 8000960:	60bb      	str	r3, [r7, #8]
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
 8000962:	68fa      	ldr	r2, [r7, #12]
 8000964:	68bb      	ldr	r3, [r7, #8]
 8000966:	4313      	orrs	r3, r2
 8000968:	60fb      	str	r3, [r7, #12]
    /* Store the new register value */
    ADCx->SQR1 = tmpreg1;
 800096a:	687b      	ldr	r3, [r7, #4]
 800096c:	68fa      	ldr	r2, [r7, #12]
 800096e:	631a      	str	r2, [r3, #48]	; 0x30
  }
}
 8000970:	bf00      	nop
 8000972:	3714      	adds	r7, #20
 8000974:	46bd      	mov	sp, r7
 8000976:	bc80      	pop	{r7}
 8000978:	4770      	bx	lr
 800097a:	bf00      	nop

0800097c <ADC_SoftwareStartConv>:
  * @brief  Enables the selected ADC software start conversion of the regular channels.
  * @param  ADCx: where x can be 1 to select the ADC1 peripheral.
  * @retval None
  */
void ADC_SoftwareStartConv(ADC_TypeDef* ADCx)
{
 800097c:	b480      	push	{r7}
 800097e:	b083      	sub	sp, #12
 8000980:	af00      	add	r7, sp, #0
 8000982:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));

  /* Enable the selected ADC conversion for regular group */
  ADCx->CR2 |= (uint32_t)ADC_CR2_SWSTART;
 8000984:	687b      	ldr	r3, [r7, #4]
 8000986:	689b      	ldr	r3, [r3, #8]
 8000988:	f043 4280 	orr.w	r2, r3, #1073741824	; 0x40000000
 800098c:	687b      	ldr	r3, [r7, #4]
 800098e:	609a      	str	r2, [r3, #8]
}
 8000990:	bf00      	nop
 8000992:	370c      	adds	r7, #12
 8000994:	46bd      	mov	sp, r7
 8000996:	bc80      	pop	{r7}
 8000998:	4770      	bx	lr
 800099a:	bf00      	nop

0800099c <ADC_ITConfig>:
  * @param  NewState: new state of the specified ADC interrupts.
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ADC_ITConfig(ADC_TypeDef* ADCx, uint16_t ADC_IT, FunctionalState NewState)  
{
 800099c:	b480      	push	{r7}
 800099e:	b085      	sub	sp, #20
 80009a0:	af00      	add	r7, sp, #0
 80009a2:	6078      	str	r0, [r7, #4]
 80009a4:	460b      	mov	r3, r1
 80009a6:	807b      	strh	r3, [r7, #2]
 80009a8:	4613      	mov	r3, r2
 80009aa:	707b      	strb	r3, [r7, #1]
  uint32_t itmask = 0;
 80009ac:	2300      	movs	r3, #0
 80009ae:	60fb      	str	r3, [r7, #12]
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  assert_param(IS_ADC_IT(ADC_IT)); 

  /* Get the ADC IT index */
  itmask = (uint8_t)ADC_IT;
 80009b0:	887b      	ldrh	r3, [r7, #2]
 80009b2:	b2db      	uxtb	r3, r3
 80009b4:	60fb      	str	r3, [r7, #12]
  itmask = (uint32_t)0x01 << itmask;    
 80009b6:	2201      	movs	r2, #1
 80009b8:	68fb      	ldr	r3, [r7, #12]
 80009ba:	fa02 f303 	lsl.w	r3, r2, r3
 80009be:	60fb      	str	r3, [r7, #12]

  if (NewState != DISABLE)
 80009c0:	787b      	ldrb	r3, [r7, #1]
 80009c2:	2b00      	cmp	r3, #0
 80009c4:	d006      	beq.n	80009d4 <ADC_ITConfig+0x38>
  {
    /* Enable the selected ADC interrupts */
    ADCx->CR1 |= itmask;
 80009c6:	687b      	ldr	r3, [r7, #4]
 80009c8:	685a      	ldr	r2, [r3, #4]
 80009ca:	68fb      	ldr	r3, [r7, #12]
 80009cc:	431a      	orrs	r2, r3
 80009ce:	687b      	ldr	r3, [r7, #4]
 80009d0:	605a      	str	r2, [r3, #4]
  else
  {
    /* Disable the selected ADC interrupts */
    ADCx->CR1 &= (~(uint32_t)itmask);
  }
}
 80009d2:	e006      	b.n	80009e2 <ADC_ITConfig+0x46>
    ADCx->CR1 |= itmask;
  }
  else
  {
    /* Disable the selected ADC interrupts */
    ADCx->CR1 &= (~(uint32_t)itmask);
 80009d4:	687b      	ldr	r3, [r7, #4]
 80009d6:	685a      	ldr	r2, [r3, #4]
 80009d8:	68fb      	ldr	r3, [r7, #12]
 80009da:	43db      	mvns	r3, r3
 80009dc:	401a      	ands	r2, r3
 80009de:	687b      	ldr	r3, [r7, #4]
 80009e0:	605a      	str	r2, [r3, #4]
  }
}
 80009e2:	bf00      	nop
 80009e4:	3714      	adds	r7, #20
 80009e6:	46bd      	mov	sp, r7
 80009e8:	bc80      	pop	{r7}
 80009ea:	4770      	bx	lr

080009ec <ADC_GetFlagStatus>:
  *     @arg ADC_FLAG_RCNR: Regular channel not ready
  *     @arg ADC_FLAG_JCNR: Injected channel not ready
  * @retval The new state of ADC_FLAG (SET or RESET).
  */
FlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, uint16_t ADC_FLAG)
{
 80009ec:	b480      	push	{r7}
 80009ee:	b085      	sub	sp, #20
 80009f0:	af00      	add	r7, sp, #0
 80009f2:	6078      	str	r0, [r7, #4]
 80009f4:	460b      	mov	r3, r1
 80009f6:	807b      	strh	r3, [r7, #2]
  FlagStatus bitstatus = RESET;
 80009f8:	2300      	movs	r3, #0
 80009fa:	73fb      	strb	r3, [r7, #15]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_GET_FLAG(ADC_FLAG));

  /* Check the status of the specified ADC flag */
  if ((ADCx->SR & ADC_FLAG) != (uint8_t)RESET)
 80009fc:	687b      	ldr	r3, [r7, #4]
 80009fe:	681a      	ldr	r2, [r3, #0]
 8000a00:	887b      	ldrh	r3, [r7, #2]
 8000a02:	4013      	ands	r3, r2
 8000a04:	2b00      	cmp	r3, #0
 8000a06:	d002      	beq.n	8000a0e <ADC_GetFlagStatus+0x22>
  {
    /* ADC_FLAG is set */
    bitstatus = SET;
 8000a08:	2301      	movs	r3, #1
 8000a0a:	73fb      	strb	r3, [r7, #15]
 8000a0c:	e001      	b.n	8000a12 <ADC_GetFlagStatus+0x26>
  }
  else
  {
    /* ADC_FLAG is reset */
    bitstatus = RESET;
 8000a0e:	2300      	movs	r3, #0
 8000a10:	73fb      	strb	r3, [r7, #15]
  }
  /* Return the ADC_FLAG status */
  return  bitstatus;
 8000a12:	7bfb      	ldrb	r3, [r7, #15]
}
 8000a14:	4618      	mov	r0, r3
 8000a16:	3714      	adds	r7, #20
 8000a18:	46bd      	mov	sp, r7
 8000a1a:	bc80      	pop	{r7}
 8000a1c:	4770      	bx	lr
 8000a1e:	bf00      	nop

08000a20 <GPIO_Init>:
  *         peripheral.

  * @retval None
  */
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
{
 8000a20:	b480      	push	{r7}
 8000a22:	b087      	sub	sp, #28
 8000a24:	af00      	add	r7, sp, #0
 8000a26:	6078      	str	r0, [r7, #4]
 8000a28:	6039      	str	r1, [r7, #0]
  uint32_t pinpos = 0x00, pos = 0x00 , currentpin = 0x00;
 8000a2a:	2300      	movs	r3, #0
 8000a2c:	617b      	str	r3, [r7, #20]
 8000a2e:	2300      	movs	r3, #0
 8000a30:	613b      	str	r3, [r7, #16]
 8000a32:	2300      	movs	r3, #0
 8000a34:	60fb      	str	r3, [r7, #12]
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 8000a36:	2300      	movs	r3, #0
 8000a38:	617b      	str	r3, [r7, #20]
 8000a3a:	e07e      	b.n	8000b3a <GPIO_Init+0x11a>
  {
    pos = ((uint32_t)0x01) << pinpos;
 8000a3c:	2201      	movs	r2, #1
 8000a3e:	697b      	ldr	r3, [r7, #20]
 8000a40:	fa02 f303 	lsl.w	r3, r2, r3
 8000a44:	613b      	str	r3, [r7, #16]

    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 8000a46:	683b      	ldr	r3, [r7, #0]
 8000a48:	681a      	ldr	r2, [r3, #0]
 8000a4a:	693b      	ldr	r3, [r7, #16]
 8000a4c:	4013      	ands	r3, r2
 8000a4e:	60fb      	str	r3, [r7, #12]

    if (currentpin == pos)
 8000a50:	68fa      	ldr	r2, [r7, #12]
 8000a52:	693b      	ldr	r3, [r7, #16]
 8000a54:	429a      	cmp	r2, r3
 8000a56:	d16d      	bne.n	8000b34 <GPIO_Init+0x114>
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
 8000a58:	687b      	ldr	r3, [r7, #4]
 8000a5a:	681a      	ldr	r2, [r3, #0]
 8000a5c:	697b      	ldr	r3, [r7, #20]
 8000a5e:	005b      	lsls	r3, r3, #1
 8000a60:	2103      	movs	r1, #3
 8000a62:	fa01 f303 	lsl.w	r3, r1, r3
 8000a66:	43db      	mvns	r3, r3
 8000a68:	401a      	ands	r2, r3
 8000a6a:	687b      	ldr	r3, [r7, #4]
 8000a6c:	601a      	str	r2, [r3, #0]

      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 8000a6e:	687b      	ldr	r3, [r7, #4]
 8000a70:	681a      	ldr	r2, [r3, #0]
 8000a72:	683b      	ldr	r3, [r7, #0]
 8000a74:	791b      	ldrb	r3, [r3, #4]
 8000a76:	4619      	mov	r1, r3
 8000a78:	697b      	ldr	r3, [r7, #20]
 8000a7a:	005b      	lsls	r3, r3, #1
 8000a7c:	fa01 f303 	lsl.w	r3, r1, r3
 8000a80:	431a      	orrs	r2, r3
 8000a82:	687b      	ldr	r3, [r7, #4]
 8000a84:	601a      	str	r2, [r3, #0]

      if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
 8000a86:	683b      	ldr	r3, [r7, #0]
 8000a88:	791b      	ldrb	r3, [r3, #4]
 8000a8a:	2b01      	cmp	r3, #1
 8000a8c:	d003      	beq.n	8000a96 <GPIO_Init+0x76>
 8000a8e:	683b      	ldr	r3, [r7, #0]
 8000a90:	791b      	ldrb	r3, [r3, #4]
 8000a92:	2b02      	cmp	r3, #2
 8000a94:	d136      	bne.n	8000b04 <GPIO_Init+0xe4>
      {
        /* Check Speed mode parameters */
        assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));

        /* Speed mode configuration */
        GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (pinpos * 2));
 8000a96:	687b      	ldr	r3, [r7, #4]
 8000a98:	689a      	ldr	r2, [r3, #8]
 8000a9a:	697b      	ldr	r3, [r7, #20]
 8000a9c:	005b      	lsls	r3, r3, #1
 8000a9e:	2103      	movs	r1, #3
 8000aa0:	fa01 f303 	lsl.w	r3, r1, r3
 8000aa4:	43db      	mvns	r3, r3
 8000aa6:	401a      	ands	r2, r3
 8000aa8:	687b      	ldr	r3, [r7, #4]
 8000aaa:	609a      	str	r2, [r3, #8]
        GPIOx->OSPEEDR |= ((uint32_t)(GPIO_InitStruct->GPIO_Speed) << (pinpos * 2));
 8000aac:	687b      	ldr	r3, [r7, #4]
 8000aae:	689a      	ldr	r2, [r3, #8]
 8000ab0:	683b      	ldr	r3, [r7, #0]
 8000ab2:	795b      	ldrb	r3, [r3, #5]
 8000ab4:	4619      	mov	r1, r3
 8000ab6:	697b      	ldr	r3, [r7, #20]
 8000ab8:	005b      	lsls	r3, r3, #1
 8000aba:	fa01 f303 	lsl.w	r3, r1, r3
 8000abe:	431a      	orrs	r2, r3
 8000ac0:	687b      	ldr	r3, [r7, #4]
 8000ac2:	609a      	str	r2, [r3, #8]

        /*Check Output mode parameters */
        assert_param(IS_GPIO_OTYPE(GPIO_InitStruct->GPIO_OType));

        /* Output mode configuration */
        GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
 8000ac4:	687b      	ldr	r3, [r7, #4]
 8000ac6:	889b      	ldrh	r3, [r3, #4]
 8000ac8:	b29a      	uxth	r2, r3
 8000aca:	697b      	ldr	r3, [r7, #20]
 8000acc:	b29b      	uxth	r3, r3
 8000ace:	2101      	movs	r1, #1
 8000ad0:	fa01 f303 	lsl.w	r3, r1, r3
 8000ad4:	b29b      	uxth	r3, r3
 8000ad6:	43db      	mvns	r3, r3
 8000ad8:	b29b      	uxth	r3, r3
 8000ada:	4013      	ands	r3, r2
 8000adc:	b29a      	uxth	r2, r3
 8000ade:	687b      	ldr	r3, [r7, #4]
 8000ae0:	809a      	strh	r2, [r3, #4]
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
 8000ae2:	687b      	ldr	r3, [r7, #4]
 8000ae4:	889b      	ldrh	r3, [r3, #4]
 8000ae6:	b29b      	uxth	r3, r3
 8000ae8:	b21a      	sxth	r2, r3
 8000aea:	683b      	ldr	r3, [r7, #0]
 8000aec:	799b      	ldrb	r3, [r3, #6]
 8000aee:	4619      	mov	r1, r3
 8000af0:	697b      	ldr	r3, [r7, #20]
 8000af2:	b29b      	uxth	r3, r3
 8000af4:	fa01 f303 	lsl.w	r3, r1, r3
 8000af8:	b21b      	sxth	r3, r3
 8000afa:	4313      	orrs	r3, r2
 8000afc:	b21b      	sxth	r3, r3
 8000afe:	b29a      	uxth	r2, r3
 8000b00:	687b      	ldr	r3, [r7, #4]
 8000b02:	809a      	strh	r2, [r3, #4]
      }

      /* Pull-up Pull down resistor configuration */
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
 8000b04:	687b      	ldr	r3, [r7, #4]
 8000b06:	68da      	ldr	r2, [r3, #12]
 8000b08:	697b      	ldr	r3, [r7, #20]
 8000b0a:	b29b      	uxth	r3, r3
 8000b0c:	005b      	lsls	r3, r3, #1
 8000b0e:	2103      	movs	r1, #3
 8000b10:	fa01 f303 	lsl.w	r3, r1, r3
 8000b14:	43db      	mvns	r3, r3
 8000b16:	401a      	ands	r2, r3
 8000b18:	687b      	ldr	r3, [r7, #4]
 8000b1a:	60da      	str	r2, [r3, #12]
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
 8000b1c:	687b      	ldr	r3, [r7, #4]
 8000b1e:	68da      	ldr	r2, [r3, #12]
 8000b20:	683b      	ldr	r3, [r7, #0]
 8000b22:	79db      	ldrb	r3, [r3, #7]
 8000b24:	4619      	mov	r1, r3
 8000b26:	697b      	ldr	r3, [r7, #20]
 8000b28:	005b      	lsls	r3, r3, #1
 8000b2a:	fa01 f303 	lsl.w	r3, r1, r3
 8000b2e:	431a      	orrs	r2, r3
 8000b30:	687b      	ldr	r3, [r7, #4]
 8000b32:	60da      	str	r2, [r3, #12]
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 8000b34:	697b      	ldr	r3, [r7, #20]
 8000b36:	3301      	adds	r3, #1
 8000b38:	617b      	str	r3, [r7, #20]
 8000b3a:	697b      	ldr	r3, [r7, #20]
 8000b3c:	2b0f      	cmp	r3, #15
 8000b3e:	f67f af7d 	bls.w	8000a3c <GPIO_Init+0x1c>
      /* Pull-up Pull down resistor configuration */
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
    }
  }
}
 8000b42:	bf00      	nop
 8000b44:	371c      	adds	r7, #28
 8000b46:	46bd      	mov	sp, r7
 8000b48:	bc80      	pop	{r7}
 8000b4a:	4770      	bx	lr

08000b4c <GPIO_ReadInputDataBit>:
  * @param  GPIO_Pin: specifies the port bit to read.
  *   This parameter can be GPIO_Pin_x where x can be (0..15).
  * @retval The input port pin value.
  */
uint8_t GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 8000b4c:	b480      	push	{r7}
 8000b4e:	b085      	sub	sp, #20
 8000b50:	af00      	add	r7, sp, #0
 8000b52:	6078      	str	r0, [r7, #4]
 8000b54:	460b      	mov	r3, r1
 8000b56:	807b      	strh	r3, [r7, #2]
  uint8_t bitstatus = 0x00;
 8000b58:	2300      	movs	r3, #0
 8000b5a:	73fb      	strb	r3, [r7, #15]
  
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)Bit_RESET)
 8000b5c:	687b      	ldr	r3, [r7, #4]
 8000b5e:	8a1b      	ldrh	r3, [r3, #16]
 8000b60:	b29a      	uxth	r2, r3
 8000b62:	887b      	ldrh	r3, [r7, #2]
 8000b64:	4013      	ands	r3, r2
 8000b66:	b29b      	uxth	r3, r3
 8000b68:	2b00      	cmp	r3, #0
 8000b6a:	d002      	beq.n	8000b72 <GPIO_ReadInputDataBit+0x26>
  {
    bitstatus = (uint8_t)Bit_SET;
 8000b6c:	2301      	movs	r3, #1
 8000b6e:	73fb      	strb	r3, [r7, #15]
 8000b70:	e001      	b.n	8000b76 <GPIO_ReadInputDataBit+0x2a>
  }
  else
  {
    bitstatus = (uint8_t)Bit_RESET;
 8000b72:	2300      	movs	r3, #0
 8000b74:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
 8000b76:	7bfb      	ldrb	r3, [r7, #15]
}
 8000b78:	4618      	mov	r0, r3
 8000b7a:	3714      	adds	r7, #20
 8000b7c:	46bd      	mov	sp, r7
 8000b7e:	bc80      	pop	{r7}
 8000b80:	4770      	bx	lr
 8000b82:	bf00      	nop

08000b84 <GPIO_PinAFConfig>:
  *        alternate function I/O pins.  
  * @note EVENTOUT is not mapped on PH0, PH1 and PH2.  
  * @retval None
  */
void GPIO_PinAFConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_PinSource, uint8_t GPIO_AF)
{
 8000b84:	b480      	push	{r7}
 8000b86:	b085      	sub	sp, #20
 8000b88:	af00      	add	r7, sp, #0
 8000b8a:	6078      	str	r0, [r7, #4]
 8000b8c:	460b      	mov	r3, r1
 8000b8e:	807b      	strh	r3, [r7, #2]
 8000b90:	4613      	mov	r3, r2
 8000b92:	707b      	strb	r3, [r7, #1]
  uint32_t temp = 0x00;
 8000b94:	2300      	movs	r3, #0
 8000b96:	60fb      	str	r3, [r7, #12]
  uint32_t temp_2 = 0x00;
 8000b98:	2300      	movs	r3, #0
 8000b9a:	60bb      	str	r3, [r7, #8]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  assert_param(IS_GPIO_AF(GPIO_AF));
  
  temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 8000b9c:	787a      	ldrb	r2, [r7, #1]
 8000b9e:	887b      	ldrh	r3, [r7, #2]
 8000ba0:	f003 0307 	and.w	r3, r3, #7
 8000ba4:	009b      	lsls	r3, r3, #2
 8000ba6:	fa02 f303 	lsl.w	r3, r2, r3
 8000baa:	60fb      	str	r3, [r7, #12]
  GPIOx->AFR[GPIO_PinSource >> 0x03] &= ~((uint32_t)0xF << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 8000bac:	887b      	ldrh	r3, [r7, #2]
 8000bae:	08db      	lsrs	r3, r3, #3
 8000bb0:	b29b      	uxth	r3, r3
 8000bb2:	4618      	mov	r0, r3
 8000bb4:	887b      	ldrh	r3, [r7, #2]
 8000bb6:	08db      	lsrs	r3, r3, #3
 8000bb8:	b29b      	uxth	r3, r3
 8000bba:	461a      	mov	r2, r3
 8000bbc:	687b      	ldr	r3, [r7, #4]
 8000bbe:	3208      	adds	r2, #8
 8000bc0:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8000bc4:	887b      	ldrh	r3, [r7, #2]
 8000bc6:	f003 0307 	and.w	r3, r3, #7
 8000bca:	009b      	lsls	r3, r3, #2
 8000bcc:	210f      	movs	r1, #15
 8000bce:	fa01 f303 	lsl.w	r3, r1, r3
 8000bd2:	43db      	mvns	r3, r3
 8000bd4:	ea02 0103 	and.w	r1, r2, r3
 8000bd8:	687b      	ldr	r3, [r7, #4]
 8000bda:	f100 0208 	add.w	r2, r0, #8
 8000bde:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  temp_2 = GPIOx->AFR[GPIO_PinSource >> 0x03] | temp;
 8000be2:	887b      	ldrh	r3, [r7, #2]
 8000be4:	08db      	lsrs	r3, r3, #3
 8000be6:	b29b      	uxth	r3, r3
 8000be8:	461a      	mov	r2, r3
 8000bea:	687b      	ldr	r3, [r7, #4]
 8000bec:	3208      	adds	r2, #8
 8000bee:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8000bf2:	68fb      	ldr	r3, [r7, #12]
 8000bf4:	4313      	orrs	r3, r2
 8000bf6:	60bb      	str	r3, [r7, #8]
  GPIOx->AFR[GPIO_PinSource >> 0x03] = temp_2;
 8000bf8:	887b      	ldrh	r3, [r7, #2]
 8000bfa:	08db      	lsrs	r3, r3, #3
 8000bfc:	b29b      	uxth	r3, r3
 8000bfe:	461a      	mov	r2, r3
 8000c00:	687b      	ldr	r3, [r7, #4]
 8000c02:	3208      	adds	r2, #8
 8000c04:	68b9      	ldr	r1, [r7, #8]
 8000c06:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
 8000c0a:	bf00      	nop
 8000c0c:	3714      	adds	r7, #20
 8000c0e:	46bd      	mov	sp, r7
 8000c10:	bc80      	pop	{r7}
 8000c12:	4770      	bx	lr

08000c14 <RCC_HSICmd>:
  * @note   When the HSI is stopped, HSIRDY flag goes low after 6 HSI oscillator
  *         clock cycles.  
  * @retval None
  */
void RCC_HSICmd(FunctionalState NewState)
{
 8000c14:	b480      	push	{r7}
 8000c16:	b083      	sub	sp, #12
 8000c18:	af00      	add	r7, sp, #0
 8000c1a:	4603      	mov	r3, r0
 8000c1c:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) CR_HSION_BB = (uint32_t)NewState;
 8000c1e:	4a04      	ldr	r2, [pc, #16]	; (8000c30 <RCC_HSICmd+0x1c>)
 8000c20:	79fb      	ldrb	r3, [r7, #7]
 8000c22:	6013      	str	r3, [r2, #0]
}
 8000c24:	bf00      	nop
 8000c26:	370c      	adds	r7, #12
 8000c28:	46bd      	mov	sp, r7
 8000c2a:	bc80      	pop	{r7}
 8000c2c:	4770      	bx	lr
 8000c2e:	bf00      	nop
 8000c30:	42470000 	.word	0x42470000

08000c34 <RCC_AHBPeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)
{
 8000c34:	b480      	push	{r7}
 8000c36:	b083      	sub	sp, #12
 8000c38:	af00      	add	r7, sp, #0
 8000c3a:	6078      	str	r0, [r7, #4]
 8000c3c:	460b      	mov	r3, r1
 8000c3e:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8000c40:	78fb      	ldrb	r3, [r7, #3]
 8000c42:	2b00      	cmp	r3, #0
 8000c44:	d006      	beq.n	8000c54 <RCC_AHBPeriphClockCmd+0x20>
  {
    RCC->AHBENR |= RCC_AHBPeriph;
 8000c46:	4909      	ldr	r1, [pc, #36]	; (8000c6c <RCC_AHBPeriphClockCmd+0x38>)
 8000c48:	4b08      	ldr	r3, [pc, #32]	; (8000c6c <RCC_AHBPeriphClockCmd+0x38>)
 8000c4a:	69da      	ldr	r2, [r3, #28]
 8000c4c:	687b      	ldr	r3, [r7, #4]
 8000c4e:	4313      	orrs	r3, r2
 8000c50:	61cb      	str	r3, [r1, #28]
  }
  else
  {
    RCC->AHBENR &= ~RCC_AHBPeriph;
  }
}
 8000c52:	e006      	b.n	8000c62 <RCC_AHBPeriphClockCmd+0x2e>
  {
    RCC->AHBENR |= RCC_AHBPeriph;
  }
  else
  {
    RCC->AHBENR &= ~RCC_AHBPeriph;
 8000c54:	4905      	ldr	r1, [pc, #20]	; (8000c6c <RCC_AHBPeriphClockCmd+0x38>)
 8000c56:	4b05      	ldr	r3, [pc, #20]	; (8000c6c <RCC_AHBPeriphClockCmd+0x38>)
 8000c58:	69da      	ldr	r2, [r3, #28]
 8000c5a:	687b      	ldr	r3, [r7, #4]
 8000c5c:	43db      	mvns	r3, r3
 8000c5e:	4013      	ands	r3, r2
 8000c60:	61cb      	str	r3, [r1, #28]
  }
}
 8000c62:	bf00      	nop
 8000c64:	370c      	adds	r7, #12
 8000c66:	46bd      	mov	sp, r7
 8000c68:	bc80      	pop	{r7}
 8000c6a:	4770      	bx	lr
 8000c6c:	40023800 	.word	0x40023800

08000c70 <RCC_APB2PeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
 8000c70:	b480      	push	{r7}
 8000c72:	b083      	sub	sp, #12
 8000c74:	af00      	add	r7, sp, #0
 8000c76:	6078      	str	r0, [r7, #4]
 8000c78:	460b      	mov	r3, r1
 8000c7a:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8000c7c:	78fb      	ldrb	r3, [r7, #3]
 8000c7e:	2b00      	cmp	r3, #0
 8000c80:	d006      	beq.n	8000c90 <RCC_APB2PeriphClockCmd+0x20>
  {
    RCC->APB2ENR |= RCC_APB2Periph;
 8000c82:	4909      	ldr	r1, [pc, #36]	; (8000ca8 <RCC_APB2PeriphClockCmd+0x38>)
 8000c84:	4b08      	ldr	r3, [pc, #32]	; (8000ca8 <RCC_APB2PeriphClockCmd+0x38>)
 8000c86:	6a1a      	ldr	r2, [r3, #32]
 8000c88:	687b      	ldr	r3, [r7, #4]
 8000c8a:	4313      	orrs	r3, r2
 8000c8c:	620b      	str	r3, [r1, #32]
  }
  else
  {
    RCC->APB2ENR &= ~RCC_APB2Periph;
  }
}
 8000c8e:	e006      	b.n	8000c9e <RCC_APB2PeriphClockCmd+0x2e>
  {
    RCC->APB2ENR |= RCC_APB2Periph;
  }
  else
  {
    RCC->APB2ENR &= ~RCC_APB2Periph;
 8000c90:	4905      	ldr	r1, [pc, #20]	; (8000ca8 <RCC_APB2PeriphClockCmd+0x38>)
 8000c92:	4b05      	ldr	r3, [pc, #20]	; (8000ca8 <RCC_APB2PeriphClockCmd+0x38>)
 8000c94:	6a1a      	ldr	r2, [r3, #32]
 8000c96:	687b      	ldr	r3, [r7, #4]
 8000c98:	43db      	mvns	r3, r3
 8000c9a:	4013      	ands	r3, r2
 8000c9c:	620b      	str	r3, [r1, #32]
  }
}
 8000c9e:	bf00      	nop
 8000ca0:	370c      	adds	r7, #12
 8000ca2:	46bd      	mov	sp, r7
 8000ca4:	bc80      	pop	{r7}
 8000ca6:	4770      	bx	lr
 8000ca8:	40023800 	.word	0x40023800

08000cac <RCC_GetFlagStatus>:
  *     @arg RCC_FLAG_WWDGRST: Window Watchdog reset
  *     @arg RCC_FLAG_LPWRRST: Low Power reset
  * @retval The new state of RCC_FLAG (SET or RESET).
  */
FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG)
{
 8000cac:	b480      	push	{r7}
 8000cae:	b087      	sub	sp, #28
 8000cb0:	af00      	add	r7, sp, #0
 8000cb2:	4603      	mov	r3, r0
 8000cb4:	71fb      	strb	r3, [r7, #7]
  uint32_t tmp = 0;
 8000cb6:	2300      	movs	r3, #0
 8000cb8:	60fb      	str	r3, [r7, #12]
  uint32_t statusreg = 0;
 8000cba:	2300      	movs	r3, #0
 8000cbc:	617b      	str	r3, [r7, #20]
  FlagStatus bitstatus = RESET;
 8000cbe:	2300      	movs	r3, #0
 8000cc0:	74fb      	strb	r3, [r7, #19]

  /* Check the parameters */
  assert_param(IS_RCC_FLAG(RCC_FLAG));

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
 8000cc2:	79fb      	ldrb	r3, [r7, #7]
 8000cc4:	095b      	lsrs	r3, r3, #5
 8000cc6:	b2db      	uxtb	r3, r3
 8000cc8:	60fb      	str	r3, [r7, #12]

  if (tmp == 1)               /* The flag to check is in CR register */
 8000cca:	68fb      	ldr	r3, [r7, #12]
 8000ccc:	2b01      	cmp	r3, #1
 8000cce:	d103      	bne.n	8000cd8 <RCC_GetFlagStatus+0x2c>
  {
    statusreg = RCC->CR;
 8000cd0:	4b0e      	ldr	r3, [pc, #56]	; (8000d0c <RCC_GetFlagStatus+0x60>)
 8000cd2:	681b      	ldr	r3, [r3, #0]
 8000cd4:	617b      	str	r3, [r7, #20]
 8000cd6:	e002      	b.n	8000cde <RCC_GetFlagStatus+0x32>
  }
  else          /* The flag to check is in CSR register (tmp == 2) */
  {
    statusreg = RCC->CSR;
 8000cd8:	4b0c      	ldr	r3, [pc, #48]	; (8000d0c <RCC_GetFlagStatus+0x60>)
 8000cda:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8000cdc:	617b      	str	r3, [r7, #20]
  }

  /* Get the flag position */
  tmp = RCC_FLAG & FLAG_MASK;
 8000cde:	79fb      	ldrb	r3, [r7, #7]
 8000ce0:	f003 031f 	and.w	r3, r3, #31
 8000ce4:	60fb      	str	r3, [r7, #12]

  if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
 8000ce6:	697a      	ldr	r2, [r7, #20]
 8000ce8:	68fb      	ldr	r3, [r7, #12]
 8000cea:	fa22 f303 	lsr.w	r3, r2, r3
 8000cee:	f003 0301 	and.w	r3, r3, #1
 8000cf2:	2b00      	cmp	r3, #0
 8000cf4:	d002      	beq.n	8000cfc <RCC_GetFlagStatus+0x50>
  {
    bitstatus = SET;
 8000cf6:	2301      	movs	r3, #1
 8000cf8:	74fb      	strb	r3, [r7, #19]
 8000cfa:	e001      	b.n	8000d00 <RCC_GetFlagStatus+0x54>
  }
  else
  {
    bitstatus = RESET;
 8000cfc:	2300      	movs	r3, #0
 8000cfe:	74fb      	strb	r3, [r7, #19]
  }
  /* Return the flag status */
  return bitstatus;
 8000d00:	7cfb      	ldrb	r3, [r7, #19]
}
 8000d02:	4618      	mov	r0, r3
 8000d04:	371c      	adds	r7, #28
 8000d06:	46bd      	mov	sp, r7
 8000d08:	bc80      	pop	{r7}
 8000d0a:	4770      	bx	lr
 8000d0c:	40023800 	.word	0x40023800

08000d10 <SPI_Init>:
  * @param  SPI_InitStruct: pointer to a SPI_InitTypeDef structure that
  *         contains the configuration information for the specified SPI peripheral.
  * @retval None
  */
void SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct)
{
 8000d10:	b480      	push	{r7}
 8000d12:	b085      	sub	sp, #20
 8000d14:	af00      	add	r7, sp, #0
 8000d16:	6078      	str	r0, [r7, #4]
 8000d18:	6039      	str	r1, [r7, #0]
  uint16_t tmpreg = 0;
 8000d1a:	2300      	movs	r3, #0
 8000d1c:	81fb      	strh	r3, [r7, #14]
  assert_param(IS_SPI_FIRST_BIT(SPI_InitStruct->SPI_FirstBit));
  assert_param(IS_SPI_CRC_POLYNOMIAL(SPI_InitStruct->SPI_CRCPolynomial));

/*---------------------------- SPIx CR1 Configuration ------------------------*/
  /* Get the SPIx CR1 value */
  tmpreg = SPIx->CR1;
 8000d1e:	687b      	ldr	r3, [r7, #4]
 8000d20:	881b      	ldrh	r3, [r3, #0]
 8000d22:	81fb      	strh	r3, [r7, #14]
  /* Clear BIDIMode, BIDIOE, RxONLY, SSM, SSI, LSBFirst, BR, MSTR, CPOL and CPHA bits */
  tmpreg &= CR1_CLEAR_MASK;
 8000d24:	89fb      	ldrh	r3, [r7, #14]
 8000d26:	f403 5341 	and.w	r3, r3, #12352	; 0x3040
 8000d2a:	81fb      	strh	r3, [r7, #14]
  /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
  /* Set LSBFirst bit according to SPI_FirstBit value */
  /* Set BR bits according to SPI_BaudRatePrescaler value */
  /* Set CPOL bit according to SPI_CPOL value */
  /* Set CPHA bit according to SPI_CPHA value */
  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
 8000d2c:	683b      	ldr	r3, [r7, #0]
 8000d2e:	881a      	ldrh	r2, [r3, #0]
 8000d30:	683b      	ldr	r3, [r7, #0]
 8000d32:	885b      	ldrh	r3, [r3, #2]
 8000d34:	4313      	orrs	r3, r2
 8000d36:	b29a      	uxth	r2, r3
                  SPI_InitStruct->SPI_DataSize | SPI_InitStruct->SPI_CPOL |  
 8000d38:	683b      	ldr	r3, [r7, #0]
 8000d3a:	889b      	ldrh	r3, [r3, #4]
  /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
  /* Set LSBFirst bit according to SPI_FirstBit value */
  /* Set BR bits according to SPI_BaudRatePrescaler value */
  /* Set CPOL bit according to SPI_CPOL value */
  /* Set CPHA bit according to SPI_CPHA value */
  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
 8000d3c:	4313      	orrs	r3, r2
 8000d3e:	b29a      	uxth	r2, r3
                  SPI_InitStruct->SPI_DataSize | SPI_InitStruct->SPI_CPOL |  
 8000d40:	683b      	ldr	r3, [r7, #0]
 8000d42:	88db      	ldrh	r3, [r3, #6]
  /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
  /* Set LSBFirst bit according to SPI_FirstBit value */
  /* Set BR bits according to SPI_BaudRatePrescaler value */
  /* Set CPOL bit according to SPI_CPOL value */
  /* Set CPHA bit according to SPI_CPHA value */
  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
 8000d44:	4313      	orrs	r3, r2
 8000d46:	b29a      	uxth	r2, r3
                  SPI_InitStruct->SPI_DataSize | SPI_InitStruct->SPI_CPOL |  
                  SPI_InitStruct->SPI_CPHA | SPI_InitStruct->SPI_NSS |  
 8000d48:	683b      	ldr	r3, [r7, #0]
 8000d4a:	891b      	ldrh	r3, [r3, #8]
  /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
  /* Set LSBFirst bit according to SPI_FirstBit value */
  /* Set BR bits according to SPI_BaudRatePrescaler value */
  /* Set CPOL bit according to SPI_CPOL value */
  /* Set CPHA bit according to SPI_CPHA value */
  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
 8000d4c:	4313      	orrs	r3, r2
 8000d4e:	b29a      	uxth	r2, r3
                  SPI_InitStruct->SPI_DataSize | SPI_InitStruct->SPI_CPOL |  
                  SPI_InitStruct->SPI_CPHA | SPI_InitStruct->SPI_NSS |  
 8000d50:	683b      	ldr	r3, [r7, #0]
 8000d52:	895b      	ldrh	r3, [r3, #10]
  /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
  /* Set LSBFirst bit according to SPI_FirstBit value */
  /* Set BR bits according to SPI_BaudRatePrescaler value */
  /* Set CPOL bit according to SPI_CPOL value */
  /* Set CPHA bit according to SPI_CPHA value */
  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
 8000d54:	4313      	orrs	r3, r2
 8000d56:	b29a      	uxth	r2, r3
                  SPI_InitStruct->SPI_DataSize | SPI_InitStruct->SPI_CPOL |  
                  SPI_InitStruct->SPI_CPHA | SPI_InitStruct->SPI_NSS |  
                  SPI_InitStruct->SPI_BaudRatePrescaler | SPI_InitStruct->SPI_FirstBit);
 8000d58:	683b      	ldr	r3, [r7, #0]
 8000d5a:	899b      	ldrh	r3, [r3, #12]
  /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
  /* Set LSBFirst bit according to SPI_FirstBit value */
  /* Set BR bits according to SPI_BaudRatePrescaler value */
  /* Set CPOL bit according to SPI_CPOL value */
  /* Set CPHA bit according to SPI_CPHA value */
  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
 8000d5c:	4313      	orrs	r3, r2
 8000d5e:	b29a      	uxth	r2, r3
                  SPI_InitStruct->SPI_DataSize | SPI_InitStruct->SPI_CPOL |  
                  SPI_InitStruct->SPI_CPHA | SPI_InitStruct->SPI_NSS |  
                  SPI_InitStruct->SPI_BaudRatePrescaler | SPI_InitStruct->SPI_FirstBit);
 8000d60:	683b      	ldr	r3, [r7, #0]
 8000d62:	89db      	ldrh	r3, [r3, #14]
  /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
  /* Set LSBFirst bit according to SPI_FirstBit value */
  /* Set BR bits according to SPI_BaudRatePrescaler value */
  /* Set CPOL bit according to SPI_CPOL value */
  /* Set CPHA bit according to SPI_CPHA value */
  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
 8000d64:	4313      	orrs	r3, r2
 8000d66:	b29a      	uxth	r2, r3
 8000d68:	89fb      	ldrh	r3, [r7, #14]
 8000d6a:	4313      	orrs	r3, r2
 8000d6c:	81fb      	strh	r3, [r7, #14]
                  SPI_InitStruct->SPI_DataSize | SPI_InitStruct->SPI_CPOL |  
                  SPI_InitStruct->SPI_CPHA | SPI_InitStruct->SPI_NSS |  
                  SPI_InitStruct->SPI_BaudRatePrescaler | SPI_InitStruct->SPI_FirstBit);
  /* Write to SPIx CR1 */
  SPIx->CR1 = tmpreg;
 8000d6e:	687b      	ldr	r3, [r7, #4]
 8000d70:	89fa      	ldrh	r2, [r7, #14]
 8000d72:	801a      	strh	r2, [r3, #0]

  /* Activate the SPI mode (Reset I2SMOD bit in I2SCFGR register) */
  SPIx->I2SCFGR &= (uint16_t)~((uint16_t)SPI_I2SCFGR_I2SMOD);
 8000d74:	687b      	ldr	r3, [r7, #4]
 8000d76:	8b9b      	ldrh	r3, [r3, #28]
 8000d78:	b29b      	uxth	r3, r3
 8000d7a:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8000d7e:	b29a      	uxth	r2, r3
 8000d80:	687b      	ldr	r3, [r7, #4]
 8000d82:	839a      	strh	r2, [r3, #28]
/*---------------------------- SPIx CRCPOLY Configuration --------------------*/
  /* Write to SPIx CRCPOLY */
  SPIx->CRCPR = SPI_InitStruct->SPI_CRCPolynomial;
 8000d84:	683b      	ldr	r3, [r7, #0]
 8000d86:	8a1a      	ldrh	r2, [r3, #16]
 8000d88:	687b      	ldr	r3, [r7, #4]
 8000d8a:	821a      	strh	r2, [r3, #16]
}
 8000d8c:	bf00      	nop
 8000d8e:	3714      	adds	r7, #20
 8000d90:	46bd      	mov	sp, r7
 8000d92:	bc80      	pop	{r7}
 8000d94:	4770      	bx	lr
 8000d96:	bf00      	nop

08000d98 <SPI_Cmd>:
  * @param  NewState: new state of the SPIx peripheral. 
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
{
 8000d98:	b480      	push	{r7}
 8000d9a:	b083      	sub	sp, #12
 8000d9c:	af00      	add	r7, sp, #0
 8000d9e:	6078      	str	r0, [r7, #4]
 8000da0:	460b      	mov	r3, r1
 8000da2:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8000da4:	78fb      	ldrb	r3, [r7, #3]
 8000da6:	2b00      	cmp	r3, #0
 8000da8:	d008      	beq.n	8000dbc <SPI_Cmd+0x24>
  {
    /* Enable the selected SPI peripheral */
    SPIx->CR1 |= SPI_CR1_SPE;
 8000daa:	687b      	ldr	r3, [r7, #4]
 8000dac:	881b      	ldrh	r3, [r3, #0]
 8000dae:	b29b      	uxth	r3, r3
 8000db0:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8000db4:	b29a      	uxth	r2, r3
 8000db6:	687b      	ldr	r3, [r7, #4]
 8000db8:	801a      	strh	r2, [r3, #0]
  else
  {
    /* Disable the selected SPI peripheral */
    SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_SPE);
  }
}
 8000dba:	e007      	b.n	8000dcc <SPI_Cmd+0x34>
    SPIx->CR1 |= SPI_CR1_SPE;
  }
  else
  {
    /* Disable the selected SPI peripheral */
    SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_SPE);
 8000dbc:	687b      	ldr	r3, [r7, #4]
 8000dbe:	881b      	ldrh	r3, [r3, #0]
 8000dc0:	b29b      	uxth	r3, r3
 8000dc2:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8000dc6:	b29a      	uxth	r2, r3
 8000dc8:	687b      	ldr	r3, [r7, #4]
 8000dca:	801a      	strh	r2, [r3, #0]
  }
}
 8000dcc:	bf00      	nop
 8000dce:	370c      	adds	r7, #12
 8000dd0:	46bd      	mov	sp, r7
 8000dd2:	bc80      	pop	{r7}
 8000dd4:	4770      	bx	lr
 8000dd6:	bf00      	nop

08000dd8 <SPI_I2S_GetFlagStatus>:
  *     @arg I2S_FLAG_UDR: Underrun Error flag.
  *     @arg I2S_FLAG_CHSIDE: Channel Side flag.
  * @retval The new state of SPI_I2S_FLAG (SET or RESET).
  */
FlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG)
{
 8000dd8:	b480      	push	{r7}
 8000dda:	b085      	sub	sp, #20
 8000ddc:	af00      	add	r7, sp, #0
 8000dde:	6078      	str	r0, [r7, #4]
 8000de0:	460b      	mov	r3, r1
 8000de2:	807b      	strh	r3, [r7, #2]
  FlagStatus bitstatus = RESET;
 8000de4:	2300      	movs	r3, #0
 8000de6:	73fb      	strb	r3, [r7, #15]
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_I2S_GET_FLAG(SPI_I2S_FLAG));
  
  /* Check the status of the specified SPI flag */
  if ((SPIx->SR & SPI_I2S_FLAG) != (uint16_t)RESET)
 8000de8:	687b      	ldr	r3, [r7, #4]
 8000dea:	891b      	ldrh	r3, [r3, #8]
 8000dec:	b29a      	uxth	r2, r3
 8000dee:	887b      	ldrh	r3, [r7, #2]
 8000df0:	4013      	ands	r3, r2
 8000df2:	b29b      	uxth	r3, r3
 8000df4:	2b00      	cmp	r3, #0
 8000df6:	d002      	beq.n	8000dfe <SPI_I2S_GetFlagStatus+0x26>
  {
    /* SPI_I2S_FLAG is set */
    bitstatus = SET;
 8000df8:	2301      	movs	r3, #1
 8000dfa:	73fb      	strb	r3, [r7, #15]
 8000dfc:	e001      	b.n	8000e02 <SPI_I2S_GetFlagStatus+0x2a>
  }
  else
  {
    /* SPI_I2S_FLAG is reset */
    bitstatus = RESET;
 8000dfe:	2300      	movs	r3, #0
 8000e00:	73fb      	strb	r3, [r7, #15]
  }
  /* Return the SPI_I2S_FLAG status */
  return  bitstatus;
 8000e02:	7bfb      	ldrb	r3, [r7, #15]
}
 8000e04:	4618      	mov	r0, r3
 8000e06:	3714      	adds	r7, #20
 8000e08:	46bd      	mov	sp, r7
 8000e0a:	bc80      	pop	{r7}
 8000e0c:	4770      	bx	lr
 8000e0e:	bf00      	nop

08000e10 <TIM_GetITStatus>:
  * @note TIM10 and TIM11 can have only update interrupt or TIM_FLAG_CC1
  *     interrupt      
  * @retval The new state of the TIM_IT(SET or RESET).
  */
ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT)
{
 8000e10:	b480      	push	{r7}
 8000e12:	b085      	sub	sp, #20
 8000e14:	af00      	add	r7, sp, #0
 8000e16:	6078      	str	r0, [r7, #4]
 8000e18:	460b      	mov	r3, r1
 8000e1a:	807b      	strh	r3, [r7, #2]
  ITStatus bitstatus = RESET;  
 8000e1c:	2300      	movs	r3, #0
 8000e1e:	73fb      	strb	r3, [r7, #15]
  uint16_t itstatus = 0x0, itenable = 0x0;
 8000e20:	2300      	movs	r3, #0
 8000e22:	81bb      	strh	r3, [r7, #12]
 8000e24:	2300      	movs	r3, #0
 8000e26:	817b      	strh	r3, [r7, #10]
  
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_GET_IT(TIM_IT));
   
  itstatus = TIMx->SR & TIM_IT;
 8000e28:	687b      	ldr	r3, [r7, #4]
 8000e2a:	8a1b      	ldrh	r3, [r3, #16]
 8000e2c:	b29a      	uxth	r2, r3
 8000e2e:	887b      	ldrh	r3, [r7, #2]
 8000e30:	4013      	ands	r3, r2
 8000e32:	81bb      	strh	r3, [r7, #12]
  
  itenable = TIMx->DIER & TIM_IT;
 8000e34:	687b      	ldr	r3, [r7, #4]
 8000e36:	899b      	ldrh	r3, [r3, #12]
 8000e38:	b29a      	uxth	r2, r3
 8000e3a:	887b      	ldrh	r3, [r7, #2]
 8000e3c:	4013      	ands	r3, r2
 8000e3e:	817b      	strh	r3, [r7, #10]
  if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
 8000e40:	89bb      	ldrh	r3, [r7, #12]
 8000e42:	2b00      	cmp	r3, #0
 8000e44:	d005      	beq.n	8000e52 <TIM_GetITStatus+0x42>
 8000e46:	897b      	ldrh	r3, [r7, #10]
 8000e48:	2b00      	cmp	r3, #0
 8000e4a:	d002      	beq.n	8000e52 <TIM_GetITStatus+0x42>
  {
    bitstatus = SET;
 8000e4c:	2301      	movs	r3, #1
 8000e4e:	73fb      	strb	r3, [r7, #15]
 8000e50:	e001      	b.n	8000e56 <TIM_GetITStatus+0x46>
  }
  else
  {
    bitstatus = RESET;
 8000e52:	2300      	movs	r3, #0
 8000e54:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
 8000e56:	7bfb      	ldrb	r3, [r7, #15]
}
 8000e58:	4618      	mov	r0, r3
 8000e5a:	3714      	adds	r7, #20
 8000e5c:	46bd      	mov	sp, r7
 8000e5e:	bc80      	pop	{r7}
 8000e60:	4770      	bx	lr
 8000e62:	bf00      	nop

08000e64 <TIM_ClearITPendingBit>:
  * @note TIM10 and TIM11 can have only update interrupt or TIM_IT_CC1
  *     interrupt        
  * @retval None
  */
void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT)
{
 8000e64:	b480      	push	{r7}
 8000e66:	b083      	sub	sp, #12
 8000e68:	af00      	add	r7, sp, #0
 8000e6a:	6078      	str	r0, [r7, #4]
 8000e6c:	460b      	mov	r3, r1
 8000e6e:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_IT(TIM_IT));
   
  /* Clear the IT pending Bit */
  TIMx->SR = (uint16_t)~TIM_IT;
 8000e70:	887b      	ldrh	r3, [r7, #2]
 8000e72:	43db      	mvns	r3, r3
 8000e74:	b29a      	uxth	r2, r3
 8000e76:	687b      	ldr	r3, [r7, #4]
 8000e78:	821a      	strh	r2, [r3, #16]
}
 8000e7a:	bf00      	nop
 8000e7c:	370c      	adds	r7, #12
 8000e7e:	46bd      	mov	sp, r7
 8000e80:	bc80      	pop	{r7}
 8000e82:	4770      	bx	lr

08000e84 <TIM7_IRQHandler>:
static uint16_t backlitModulo = 0;
static uint16_t shimmerModulo = 0;
static uint16_t shimmerDutyCycle = SHIMMER_DUTY_CYCLE;

void TIM7_IRQHandler(void)
{
 8000e84:	b598      	push	{r3, r4, r7, lr}
 8000e86:	af00      	add	r7, sp, #0
	if (TIM_GetITStatus(TIM7, TIM_IT_Update) == SET)
 8000e88:	2101      	movs	r1, #1
 8000e8a:	4817      	ldr	r0, [pc, #92]	; (8000ee8 <TIM7_IRQHandler+0x64>)
 8000e8c:	f7ff ffc0 	bl	8000e10 <TIM_GetITStatus>
 8000e90:	4603      	mov	r3, r0
 8000e92:	2b01      	cmp	r3, #1
 8000e94:	d126      	bne.n	8000ee4 <TIM7_IRQHandler+0x60>
	{
		backlitTimer++;
 8000e96:	4b15      	ldr	r3, [pc, #84]	; (8000eec <TIM7_IRQHandler+0x68>)
 8000e98:	cb18      	ldmia	r3, {r3, r4}
 8000e9a:	3301      	adds	r3, #1
 8000e9c:	f144 0400 	adc.w	r4, r4, #0
 8000ea0:	4a12      	ldr	r2, [pc, #72]	; (8000eec <TIM7_IRQHandler+0x68>)
 8000ea2:	e882 0018 	stmia.w	r2, {r3, r4}

		shimmerModulo = backlitTimer % SHIMMER_PERIOD;
 8000ea6:	4b11      	ldr	r3, [pc, #68]	; (8000eec <TIM7_IRQHandler+0x68>)
 8000ea8:	e9d3 0100 	ldrd	r0, r1, [r3]
 8000eac:	f242 7210 	movw	r2, #10000	; 0x2710
 8000eb0:	f04f 0300 	mov.w	r3, #0
 8000eb4:	f7ff f96a 	bl	800018c <__aeabi_uldivmod>
 8000eb8:	461c      	mov	r4, r3
 8000eba:	4613      	mov	r3, r2
 8000ebc:	b29a      	uxth	r2, r3
 8000ebe:	4b0c      	ldr	r3, [pc, #48]	; (8000ef0 <TIM7_IRQHandler+0x6c>)
 8000ec0:	801a      	strh	r2, [r3, #0]

		if(shimmerDutyCycle < shimmerModulo)
 8000ec2:	4b0c      	ldr	r3, [pc, #48]	; (8000ef4 <TIM7_IRQHandler+0x70>)
 8000ec4:	881a      	ldrh	r2, [r3, #0]
 8000ec6:	4b0a      	ldr	r3, [pc, #40]	; (8000ef0 <TIM7_IRQHandler+0x6c>)
 8000ec8:	881b      	ldrh	r3, [r3, #0]
 8000eca:	429a      	cmp	r2, r3
 8000ecc:	d203      	bcs.n	8000ed6 <TIM7_IRQHandler+0x52>
		{
			gShimmerFlag = 0;
 8000ece:	4b0a      	ldr	r3, [pc, #40]	; (8000ef8 <TIM7_IRQHandler+0x74>)
 8000ed0:	2200      	movs	r2, #0
 8000ed2:	701a      	strb	r2, [r3, #0]
 8000ed4:	e002      	b.n	8000edc <TIM7_IRQHandler+0x58>
		}
		else
		{
			gShimmerFlag = 1;
 8000ed6:	4b08      	ldr	r3, [pc, #32]	; (8000ef8 <TIM7_IRQHandler+0x74>)
 8000ed8:	2201      	movs	r2, #1
 8000eda:	701a      	strb	r2, [r3, #0]
				GPIOB->BSRRH = GPIO_Pin_0;
				GPIOA->BSRRH = GPIO_Pin_7;
			}
		}*/

		TIM_ClearITPendingBit(TIM7, TIM_IT_Update);
 8000edc:	2101      	movs	r1, #1
 8000ede:	4802      	ldr	r0, [pc, #8]	; (8000ee8 <TIM7_IRQHandler+0x64>)
 8000ee0:	f7ff ffc0 	bl	8000e64 <TIM_ClearITPendingBit>
	}
}
 8000ee4:	bf00      	nop
 8000ee6:	bd98      	pop	{r3, r4, r7, pc}
 8000ee8:	40001400 	.word	0x40001400
 8000eec:	20000088 	.word	0x20000088
 8000ef0:	20000090 	.word	0x20000090
 8000ef4:	20000000 	.word	0x20000000
 8000ef8:	20000084 	.word	0x20000084

08000efc <initSPI2>:
#include "mcu.h"

//TODO rework to STM32L mcu's

void initSPI2(void)
{
 8000efc:	b580      	push	{r7, lr}
 8000efe:	b088      	sub	sp, #32
 8000f00:	af00      	add	r7, sp, #0
	GPIO_InitTypeDef GPIO_InitStructure;

	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1, ENABLE);
 8000f02:	2101      	movs	r1, #1
 8000f04:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 8000f08:	f7ff feb2 	bl	8000c70 <RCC_APB2PeriphClockCmd>
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE);
 8000f0c:	2101      	movs	r1, #1
 8000f0e:	2001      	movs	r0, #1
 8000f10:	f7ff fe90 	bl	8000c34 <RCC_AHBPeriphClockCmd>

	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 8000f14:	2302      	movs	r3, #2
 8000f16:	773b      	strb	r3, [r7, #28]
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8000f18:	2300      	movs	r3, #0
 8000f1a:	77bb      	strb	r3, [r7, #30]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_40MHz;
 8000f1c:	2303      	movs	r3, #3
 8000f1e:	777b      	strb	r3, [r7, #29]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 8000f20:	2300      	movs	r3, #0
 8000f22:	77fb      	strb	r3, [r7, #31]

	//PB3 - SPI2_SCK
	//PB4 - SPI2_MISO
	//PB5 - SPI2_MOSI
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5|GPIO_Pin_6|GPIO_Pin_7;
 8000f24:	23e0      	movs	r3, #224	; 0xe0
 8000f26:	61bb      	str	r3, [r7, #24]
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 8000f28:	f107 0318 	add.w	r3, r7, #24
 8000f2c:	4619      	mov	r1, r3
 8000f2e:	4819      	ldr	r0, [pc, #100]	; (8000f94 <initSPI2+0x98>)
 8000f30:	f7ff fd76 	bl	8000a20 <GPIO_Init>

	GPIO_PinAFConfig(GPIOA, GPIO_PinSource5, GPIO_AF_SPI1);
 8000f34:	2205      	movs	r2, #5
 8000f36:	2105      	movs	r1, #5
 8000f38:	4816      	ldr	r0, [pc, #88]	; (8000f94 <initSPI2+0x98>)
 8000f3a:	f7ff fe23 	bl	8000b84 <GPIO_PinAFConfig>
	GPIO_PinAFConfig(GPIOA, GPIO_PinSource6, GPIO_AF_SPI1);
 8000f3e:	2205      	movs	r2, #5
 8000f40:	2106      	movs	r1, #6
 8000f42:	4814      	ldr	r0, [pc, #80]	; (8000f94 <initSPI2+0x98>)
 8000f44:	f7ff fe1e 	bl	8000b84 <GPIO_PinAFConfig>
	GPIO_PinAFConfig(GPIOA, GPIO_PinSource7, GPIO_AF_SPI1);
 8000f48:	2205      	movs	r2, #5
 8000f4a:	2107      	movs	r1, #7
 8000f4c:	4811      	ldr	r0, [pc, #68]	; (8000f94 <initSPI2+0x98>)
 8000f4e:	f7ff fe19 	bl	8000b84 <GPIO_PinAFConfig>

	SPI_InitTypeDef  SPI_InitStructure;
	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;
 8000f52:	2300      	movs	r3, #0
 8000f54:	823b      	strh	r3, [r7, #16]
	SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;
 8000f56:	2300      	movs	r3, #0
 8000f58:	81bb      	strh	r3, [r7, #12]
	SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;
 8000f5a:	2300      	movs	r3, #0
 8000f5c:	817b      	strh	r3, [r7, #10]
	SPI_InitStructure.SPI_CRCPolynomial = SPI_CRC_Rx;
 8000f5e:	2301      	movs	r3, #1
 8000f60:	82bb      	strh	r3, [r7, #20]
	SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;
 8000f62:	2300      	movs	r3, #0
 8000f64:	813b      	strh	r3, [r7, #8]
	SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;
 8000f66:	2300      	movs	r3, #0
 8000f68:	80bb      	strh	r3, [r7, #4]
	SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;
 8000f6a:	2300      	movs	r3, #0
 8000f6c:	827b      	strh	r3, [r7, #18]
	SPI_InitStructure.SPI_Mode = SPI_Mode_Master;
 8000f6e:	f44f 7382 	mov.w	r3, #260	; 0x104
 8000f72:	80fb      	strh	r3, [r7, #6]
	SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;
 8000f74:	f44f 7300 	mov.w	r3, #512	; 0x200
 8000f78:	81fb      	strh	r3, [r7, #14]

	/* Apply SPI configuration after enabling it */
	SPI_Init(SPI1, &SPI_InitStructure);
 8000f7a:	1d3b      	adds	r3, r7, #4
 8000f7c:	4619      	mov	r1, r3
 8000f7e:	4806      	ldr	r0, [pc, #24]	; (8000f98 <initSPI2+0x9c>)
 8000f80:	f7ff fec6 	bl	8000d10 <SPI_Init>
	/* SPI Peripheral Enable */
	SPI_Cmd(SPI1, ENABLE);
 8000f84:	2101      	movs	r1, #1
 8000f86:	4804      	ldr	r0, [pc, #16]	; (8000f98 <initSPI2+0x9c>)
 8000f88:	f7ff ff06 	bl	8000d98 <SPI_Cmd>
}
 8000f8c:	bf00      	nop
 8000f8e:	3720      	adds	r7, #32
 8000f90:	46bd      	mov	sp, r7
 8000f92:	bd80      	pop	{r7, pc}
 8000f94:	40020000 	.word	0x40020000
 8000f98:	40013000 	.word	0x40013000

08000f9c <readWriteSPI2>:

unsigned char readWriteSPI2(unsigned char txData)
{
 8000f9c:	b580      	push	{r7, lr}
 8000f9e:	b084      	sub	sp, #16
 8000fa0:	af00      	add	r7, sp, #0
 8000fa2:	4603      	mov	r3, r0
 8000fa4:	71fb      	strb	r3, [r7, #7]
	unsigned char  rxData;

	SPI1->DR = txData;
 8000fa6:	4b0e      	ldr	r3, [pc, #56]	; (8000fe0 <readWriteSPI2+0x44>)
 8000fa8:	79fa      	ldrb	r2, [r7, #7]
 8000faa:	b292      	uxth	r2, r2
 8000fac:	819a      	strh	r2, [r3, #12]
	// wait until TXE = 1
	while(SPI_I2S_GetFlagStatus(SPI1,SPI_I2S_FLAG_TXE) != SET);
 8000fae:	bf00      	nop
 8000fb0:	2102      	movs	r1, #2
 8000fb2:	480b      	ldr	r0, [pc, #44]	; (8000fe0 <readWriteSPI2+0x44>)
 8000fb4:	f7ff ff10 	bl	8000dd8 <SPI_I2S_GetFlagStatus>
 8000fb8:	4603      	mov	r3, r0
 8000fba:	2b01      	cmp	r3, #1
 8000fbc:	d1f8      	bne.n	8000fb0 <readWriteSPI2+0x14>
	// wait until RXNE = 1
	while(SPI_I2S_GetFlagStatus(SPI1,SPI_I2S_FLAG_RXNE) != SET);
 8000fbe:	bf00      	nop
 8000fc0:	2101      	movs	r1, #1
 8000fc2:	4807      	ldr	r0, [pc, #28]	; (8000fe0 <readWriteSPI2+0x44>)
 8000fc4:	f7ff ff08 	bl	8000dd8 <SPI_I2S_GetFlagStatus>
 8000fc8:	4603      	mov	r3, r0
 8000fca:	2b01      	cmp	r3, #1
 8000fcc:	d1f8      	bne.n	8000fc0 <readWriteSPI2+0x24>
	// read the rx buff to clear the RXNE flag (garbage)
	rxData = SPI1->DR;
 8000fce:	4b04      	ldr	r3, [pc, #16]	; (8000fe0 <readWriteSPI2+0x44>)
 8000fd0:	899b      	ldrh	r3, [r3, #12]
 8000fd2:	b29b      	uxth	r3, r3
 8000fd4:	73fb      	strb	r3, [r7, #15]

	return rxData;
 8000fd6:	7bfb      	ldrb	r3, [r7, #15]
}
 8000fd8:	4618      	mov	r0, r3
 8000fda:	3710      	adds	r7, #16
 8000fdc:	46bd      	mov	sp, r7
 8000fde:	bd80      	pop	{r7, pc}
 8000fe0:	40013000 	.word	0x40013000

08000fe4 <initCS_Pin>:

void initCS_Pin(void)
{
 8000fe4:	b580      	push	{r7, lr}
 8000fe6:	b082      	sub	sp, #8
 8000fe8:	af00      	add	r7, sp, #0
	GPIO_InitTypeDef GPIO_InitStructure;
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOB, ENABLE);
 8000fea:	2101      	movs	r1, #1
 8000fec:	2002      	movs	r0, #2
 8000fee:	f7ff fe21 	bl	8000c34 <RCC_AHBPeriphClockCmd>

	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8000ff2:	2300      	movs	r3, #0
 8000ff4:	71bb      	strb	r3, [r7, #6]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_40MHz;
 8000ff6:	2303      	movs	r3, #3
 8000ff8:	717b      	strb	r3, [r7, #5]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 8000ffa:	2300      	movs	r3, #0
 8000ffc:	71fb      	strb	r3, [r7, #7]
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
 8000ffe:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8001002:	603b      	str	r3, [r7, #0]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 8001004:	2301      	movs	r3, #1
 8001006:	713b      	strb	r3, [r7, #4]
	GPIO_Init(GPIOB, &GPIO_InitStructure);
 8001008:	463b      	mov	r3, r7
 800100a:	4619      	mov	r1, r3
 800100c:	4803      	ldr	r0, [pc, #12]	; (800101c <initCS_Pin+0x38>)
 800100e:	f7ff fd07 	bl	8000a20 <GPIO_Init>
}
 8001012:	bf00      	nop
 8001014:	3708      	adds	r7, #8
 8001016:	46bd      	mov	sp, r7
 8001018:	bd80      	pop	{r7, pc}
 800101a:	bf00      	nop
 800101c:	40020400 	.word	0x40020400

08001020 <initCD_Pin>:

void initCD_Pin(void)
{
 8001020:	b580      	push	{r7, lr}
 8001022:	b082      	sub	sp, #8
 8001024:	af00      	add	r7, sp, #0
	GPIO_InitTypeDef GPIO_InitStructure;
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE);
 8001026:	2101      	movs	r1, #1
 8001028:	2001      	movs	r0, #1
 800102a:	f7ff fe03 	bl	8000c34 <RCC_AHBPeriphClockCmd>

	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 800102e:	2300      	movs	r3, #0
 8001030:	71bb      	strb	r3, [r7, #6]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_40MHz;
 8001032:	2303      	movs	r3, #3
 8001034:	717b      	strb	r3, [r7, #5]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 8001036:	2300      	movs	r3, #0
 8001038:	71fb      	strb	r3, [r7, #7]
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;
 800103a:	f44f 7380 	mov.w	r3, #256	; 0x100
 800103e:	603b      	str	r3, [r7, #0]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 8001040:	2301      	movs	r3, #1
 8001042:	713b      	strb	r3, [r7, #4]
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 8001044:	463b      	mov	r3, r7
 8001046:	4619      	mov	r1, r3
 8001048:	4803      	ldr	r0, [pc, #12]	; (8001058 <initCD_Pin+0x38>)
 800104a:	f7ff fce9 	bl	8000a20 <GPIO_Init>
}
 800104e:	bf00      	nop
 8001050:	3708      	adds	r7, #8
 8001052:	46bd      	mov	sp, r7
 8001054:	bd80      	pop	{r7, pc}
 8001056:	bf00      	nop
 8001058:	40020000 	.word	0x40020000

0800105c <cd_set>:

void cd_set(void)
{
 800105c:	b480      	push	{r7}
 800105e:	af00      	add	r7, sp, #0
	GPIOA->BSRRL = GPIO_Pin_8;
 8001060:	4b03      	ldr	r3, [pc, #12]	; (8001070 <cd_set+0x14>)
 8001062:	f44f 7280 	mov.w	r2, #256	; 0x100
 8001066:	831a      	strh	r2, [r3, #24]
}
 8001068:	bf00      	nop
 800106a:	46bd      	mov	sp, r7
 800106c:	bc80      	pop	{r7}
 800106e:	4770      	bx	lr
 8001070:	40020000 	.word	0x40020000

08001074 <cd_reset>:

void cd_reset(void)
{
 8001074:	b480      	push	{r7}
 8001076:	af00      	add	r7, sp, #0
	GPIOA->BSRRH = GPIO_Pin_8;
 8001078:	4b03      	ldr	r3, [pc, #12]	; (8001088 <cd_reset+0x14>)
 800107a:	f44f 7280 	mov.w	r2, #256	; 0x100
 800107e:	835a      	strh	r2, [r3, #26]
}
 8001080:	bf00      	nop
 8001082:	46bd      	mov	sp, r7
 8001084:	bc80      	pop	{r7}
 8001086:	4770      	bx	lr
 8001088:	40020000 	.word	0x40020000

0800108c <initRES_Pin>:

void initRES_Pin(void)
{
 800108c:	b580      	push	{r7, lr}
 800108e:	b082      	sub	sp, #8
 8001090:	af00      	add	r7, sp, #0
	GPIO_InitTypeDef GPIO_InitStructure;
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE);
 8001092:	2101      	movs	r1, #1
 8001094:	2001      	movs	r0, #1
 8001096:	f7ff fdcd 	bl	8000c34 <RCC_AHBPeriphClockCmd>

	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 800109a:	2300      	movs	r3, #0
 800109c:	71bb      	strb	r3, [r7, #6]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_40MHz;
 800109e:	2303      	movs	r3, #3
 80010a0:	717b      	strb	r3, [r7, #5]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 80010a2:	2300      	movs	r3, #0
 80010a4:	71fb      	strb	r3, [r7, #7]
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
 80010a6:	f44f 7300 	mov.w	r3, #512	; 0x200
 80010aa:	603b      	str	r3, [r7, #0]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 80010ac:	2301      	movs	r3, #1
 80010ae:	713b      	strb	r3, [r7, #4]
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 80010b0:	463b      	mov	r3, r7
 80010b2:	4619      	mov	r1, r3
 80010b4:	4803      	ldr	r0, [pc, #12]	; (80010c4 <initRES_Pin+0x38>)
 80010b6:	f7ff fcb3 	bl	8000a20 <GPIO_Init>
}
 80010ba:	bf00      	nop
 80010bc:	3708      	adds	r7, #8
 80010be:	46bd      	mov	sp, r7
 80010c0:	bd80      	pop	{r7, pc}
 80010c2:	bf00      	nop
 80010c4:	40020000 	.word	0x40020000

080010c8 <res_set>:

void res_set(void)
{
 80010c8:	b480      	push	{r7}
 80010ca:	af00      	add	r7, sp, #0
	GPIOA->BSRRL = GPIO_Pin_9;
 80010cc:	4b03      	ldr	r3, [pc, #12]	; (80010dc <res_set+0x14>)
 80010ce:	f44f 7200 	mov.w	r2, #512	; 0x200
 80010d2:	831a      	strh	r2, [r3, #24]
}
 80010d4:	bf00      	nop
 80010d6:	46bd      	mov	sp, r7
 80010d8:	bc80      	pop	{r7}
 80010da:	4770      	bx	lr
 80010dc:	40020000 	.word	0x40020000

080010e0 <res_reset>:

void res_reset(void)
{
 80010e0:	b480      	push	{r7}
 80010e2:	af00      	add	r7, sp, #0
	GPIOA->BSRRH = GPIO_Pin_9;
 80010e4:	4b03      	ldr	r3, [pc, #12]	; (80010f4 <res_reset+0x14>)
 80010e6:	f44f 7200 	mov.w	r2, #512	; 0x200
 80010ea:	835a      	strh	r2, [r3, #26]
}
 80010ec:	bf00      	nop
 80010ee:	46bd      	mov	sp, r7
 80010f0:	bc80      	pop	{r7}
 80010f2:	4770      	bx	lr
 80010f4:	40020000 	.word	0x40020000

080010f8 <adc_init>:
 *      Author: Asus
 */
#include "adc.h"
//init adc prevodnika
void adc_init()
{
 80010f8:	b580      	push	{r7, lr}
 80010fa:	b08a      	sub	sp, #40	; 0x28
 80010fc:	af00      	add	r7, sp, #0
	GPIO_InitTypeDef GPIO_InitStructure;

	ADC_InitTypeDef ADC_InitStructure;
	/* Enable GPIO clock */
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE);
 80010fe:	2101      	movs	r1, #1
 8001100:	2001      	movs	r0, #1
 8001102:	f7ff fd97 	bl	8000c34 <RCC_AHBPeriphClockCmd>
	/* Configure ADCx Channel 2 as analog input */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 ;
 8001106:	2301      	movs	r3, #1
 8001108:	623b      	str	r3, [r7, #32]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
 800110a:	2303      	movs	r3, #3
 800110c:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
 8001110:	2300      	movs	r3, #0
 8001112:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 8001116:	f107 0320 	add.w	r3, r7, #32
 800111a:	4619      	mov	r1, r3
 800111c:	482a      	ldr	r0, [pc, #168]	; (80011c8 <adc_init+0xd0>)
 800111e:	f7ff fc7f 	bl	8000a20 <GPIO_Init>
	/* Enable the HSI oscillator */
	RCC_HSICmd(ENABLE);
 8001122:	2001      	movs	r0, #1
 8001124:	f7ff fd76 	bl	8000c14 <RCC_HSICmd>
	/* Check that HSI oscillator is ready */
	while(RCC_GetFlagStatus(RCC_FLAG_HSIRDY) == RESET);
 8001128:	bf00      	nop
 800112a:	2021      	movs	r0, #33	; 0x21
 800112c:	f7ff fdbe 	bl	8000cac <RCC_GetFlagStatus>
 8001130:	4603      	mov	r3, r0
 8001132:	2b00      	cmp	r3, #0
 8001134:	d0f9      	beq.n	800112a <adc_init+0x32>
	/* Enable ADC clock */
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);
 8001136:	2101      	movs	r1, #1
 8001138:	f44f 7000 	mov.w	r0, #512	; 0x200
 800113c:	f7ff fd98 	bl	8000c70 <RCC_APB2PeriphClockCmd>
	/* Initialize ADC structure */
	ADC_StructInit(&ADC_InitStructure);
 8001140:	f107 0308 	add.w	r3, r7, #8
 8001144:	4618      	mov	r0, r3
 8001146:	f7ff fa77 	bl	8000638 <ADC_StructInit>
	/* ADC1 configuration */
	ADC_InitStructure.ADC_Resolution = ADC_Resolution_12b;
 800114a:	2300      	movs	r3, #0
 800114c:	60bb      	str	r3, [r7, #8]
	ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;
 800114e:	2301      	movs	r3, #1
 8001150:	737b      	strb	r3, [r7, #13]
	ADC_InitStructure.ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;
 8001152:	2300      	movs	r3, #0
 8001154:	613b      	str	r3, [r7, #16]
	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
 8001156:	2300      	movs	r3, #0
 8001158:	61bb      	str	r3, [r7, #24]
	ADC_InitStructure.ADC_NbrOfConversion = 1;
 800115a:	2301      	movs	r3, #1
 800115c:	773b      	strb	r3, [r7, #28]
	ADC_Init(ADC1, &ADC_InitStructure);
 800115e:	f107 0308 	add.w	r3, r7, #8
 8001162:	4619      	mov	r1, r3
 8001164:	4819      	ldr	r0, [pc, #100]	; (80011cc <adc_init+0xd4>)
 8001166:	f7ff fa13 	bl	8000590 <ADC_Init>
	/* ADCx regular channel8 configuration */
	ADC_RegularChannelConfig(ADC1, ADC_Channel_0, 1, ADC_SampleTime_384Cycles);
 800116a:	2307      	movs	r3, #7
 800116c:	2201      	movs	r2, #1
 800116e:	2100      	movs	r1, #0
 8001170:	4816      	ldr	r0, [pc, #88]	; (80011cc <adc_init+0xd4>)
 8001172:	f7ff fa9d 	bl	80006b0 <ADC_RegularChannelConfig>

	ADC_ITConfig(ADC1, ADC_IT_EOC,ENABLE);
 8001176:	2201      	movs	r2, #1
 8001178:	f240 2105 	movw	r1, #517	; 0x205
 800117c:	4813      	ldr	r0, [pc, #76]	; (80011cc <adc_init+0xd4>)
 800117e:	f7ff fc0d 	bl	800099c <ADC_ITConfig>

	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_4);
 8001182:	f44f 7040 	mov.w	r0, #768	; 0x300
 8001186:	f7ff f991 	bl	80004ac <NVIC_PriorityGroupConfig>
	NVIC_InitTypeDef NVIC_InitStructure;
	NVIC_InitStructure.NVIC_IRQChannel = ADC1_IRQn; //zoznam preruen njdete v sbore stm32l1xx.h
 800118a:	2312      	movs	r3, #18
 800118c:	713b      	strb	r3, [r7, #4]
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
 800118e:	2300      	movs	r3, #0
 8001190:	717b      	strb	r3, [r7, #5]
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
 8001192:	2300      	movs	r3, #0
 8001194:	71bb      	strb	r3, [r7, #6]
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 8001196:	2301      	movs	r3, #1
 8001198:	71fb      	strb	r3, [r7, #7]

	NVIC_Init(&NVIC_InitStructure);
 800119a:	1d3b      	adds	r3, r7, #4
 800119c:	4618      	mov	r0, r3
 800119e:	f7ff f997 	bl	80004d0 <NVIC_Init>


	/* Enable the ADC */
	ADC_Cmd(ADC1, ENABLE);
 80011a2:	2101      	movs	r1, #1
 80011a4:	4809      	ldr	r0, [pc, #36]	; (80011cc <adc_init+0xd4>)
 80011a6:	f7ff fa67 	bl	8000678 <ADC_Cmd>
	/* Wait until the ADC1 is ready */
	while(ADC_GetFlagStatus(ADC1, ADC_FLAG_ADONS) == RESET)
 80011aa:	bf00      	nop
 80011ac:	2140      	movs	r1, #64	; 0x40
 80011ae:	4807      	ldr	r0, [pc, #28]	; (80011cc <adc_init+0xd4>)
 80011b0:	f7ff fc1c 	bl	80009ec <ADC_GetFlagStatus>
 80011b4:	4603      	mov	r3, r0
 80011b6:	2b00      	cmp	r3, #0
 80011b8:	d0f8      	beq.n	80011ac <adc_init+0xb4>
	{
	}
	/* Start ADC Software Conversion */
	ADC_SoftwareStartConv(ADC1);
 80011ba:	4804      	ldr	r0, [pc, #16]	; (80011cc <adc_init+0xd4>)
 80011bc:	f7ff fbde 	bl	800097c <ADC_SoftwareStartConv>
}
 80011c0:	bf00      	nop
 80011c2:	3728      	adds	r7, #40	; 0x28
 80011c4:	46bd      	mov	sp, r7
 80011c6:	bd80      	pop	{r7, pc}
 80011c8:	40020000 	.word	0x40020000
 80011cc:	40012400 	.word	0x40012400

080011d0 <ADC1_IRQHandler>:

void ADC1_IRQHandler(void)
{
 80011d0:	b480      	push	{r7}
 80011d2:	af00      	add	r7, sp, #0
	if(ADC1->SR & (ADC_SR_EOC))
 80011d4:	4b07      	ldr	r3, [pc, #28]	; (80011f4 <ADC1_IRQHandler+0x24>)
 80011d6:	681b      	ldr	r3, [r3, #0]
 80011d8:	f003 0302 	and.w	r3, r3, #2
 80011dc:	2b00      	cmp	r3, #0
 80011de:	d004      	beq.n	80011ea <ADC1_IRQHandler+0x1a>
	{
		adc_value = ADC1->DR;
 80011e0:	4b04      	ldr	r3, [pc, #16]	; (80011f4 <ADC1_IRQHandler+0x24>)
 80011e2:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80011e4:	b29a      	uxth	r2, r3
 80011e6:	4b04      	ldr	r3, [pc, #16]	; (80011f8 <ADC1_IRQHandler+0x28>)
 80011e8:	801a      	strh	r2, [r3, #0]
	}
}
 80011ea:	bf00      	nop
 80011ec:	46bd      	mov	sp, r7
 80011ee:	bc80      	pop	{r7}
 80011f0:	4770      	bx	lr
 80011f2:	bf00      	nop
 80011f4:	40012400 	.word	0x40012400
 80011f8:	200000a0 	.word	0x200000a0

080011fc <lcdReset>:

// Low-level LCD driving functions --------------------------------------------------------------------------

// Reset the LCD hardware
void lcdReset(void)
{
 80011fc:	b580      	push	{r7, lr}
 80011fe:	af00      	add	r7, sp, #0
	// Reset pin is active low (0 = reset, 1 = ready)
	res_reset();
 8001200:	f7ff ff6e 	bl	80010e0 <res_reset>
	Delay(10000);
 8001204:	f242 7010 	movw	r0, #10000	; 0x2710
 8001208:	f001 fb2a 	bl	8002860 <Delay>

	res_set();
 800120c:	f7ff ff5c 	bl	80010c8 <res_set>
	Delay(10000);
 8001210:	f242 7010 	movw	r0, #10000	; 0x2710
 8001214:	f001 fb24 	bl	8002860 <Delay>
}
 8001218:	bf00      	nop
 800121a:	bd80      	pop	{r7, pc}

0800121c <lcdWriteCommand>:

void lcdWriteCommand(uint8_t address)
{
 800121c:	b580      	push	{r7, lr}
 800121e:	b082      	sub	sp, #8
 8001220:	af00      	add	r7, sp, #0
 8001222:	4603      	mov	r3, r0
 8001224:	71fb      	strb	r3, [r7, #7]
	cd_reset();
 8001226:	f7ff ff25 	bl	8001074 <cd_reset>

	readWriteSPI2(address);
 800122a:	79fb      	ldrb	r3, [r7, #7]
 800122c:	4618      	mov	r0, r3
 800122e:	f7ff feb5 	bl	8000f9c <readWriteSPI2>
}
 8001232:	bf00      	nop
 8001234:	3708      	adds	r7, #8
 8001236:	46bd      	mov	sp, r7
 8001238:	bd80      	pop	{r7, pc}
 800123a:	bf00      	nop

0800123c <lcdWriteParameter>:

void lcdWriteParameter(uint8_t parameter)
{
 800123c:	b580      	push	{r7, lr}
 800123e:	b082      	sub	sp, #8
 8001240:	af00      	add	r7, sp, #0
 8001242:	4603      	mov	r3, r0
 8001244:	71fb      	strb	r3, [r7, #7]
	cd_set();
 8001246:	f7ff ff09 	bl	800105c <cd_set>

	readWriteSPI2(parameter);
 800124a:	79fb      	ldrb	r3, [r7, #7]
 800124c:	4618      	mov	r0, r3
 800124e:	f7ff fea5 	bl	8000f9c <readWriteSPI2>
}
 8001252:	bf00      	nop
 8001254:	3708      	adds	r7, #8
 8001256:	46bd      	mov	sp, r7
 8001258:	bd80      	pop	{r7, pc}
 800125a:	bf00      	nop

0800125c <lcdWriteData>:

void lcdWriteData(uint8_t dataByte1, uint8_t dataByte2)
{
 800125c:	b580      	push	{r7, lr}
 800125e:	b082      	sub	sp, #8
 8001260:	af00      	add	r7, sp, #0
 8001262:	4603      	mov	r3, r0
 8001264:	460a      	mov	r2, r1
 8001266:	71fb      	strb	r3, [r7, #7]
 8001268:	4613      	mov	r3, r2
 800126a:	71bb      	strb	r3, [r7, #6]
	cd_set();
 800126c:	f7ff fef6 	bl	800105c <cd_set>

	readWriteSPI2(dataByte1);
 8001270:	79fb      	ldrb	r3, [r7, #7]
 8001272:	4618      	mov	r0, r3
 8001274:	f7ff fe92 	bl	8000f9c <readWriteSPI2>
	readWriteSPI2(dataByte2);
 8001278:	79bb      	ldrb	r3, [r7, #6]
 800127a:	4618      	mov	r0, r3
 800127c:	f7ff fe8e 	bl	8000f9c <readWriteSPI2>
}
 8001280:	bf00      	nop
 8001282:	3708      	adds	r7, #8
 8001284:	46bd      	mov	sp, r7
 8001286:	bd80      	pop	{r7, pc}

08001288 <lcdInitialise>:

// Initialise the display with the require screen orientation
void lcdInitialise(uint8_t orientation)
{
 8001288:	b580      	push	{r7, lr}
 800128a:	b082      	sub	sp, #8
 800128c:	af00      	add	r7, sp, #0
 800128e:	4603      	mov	r3, r0
 8001290:	71fb      	strb	r3, [r7, #7]
	// Set up the IO ports for communication with the LCD


	// Hardware reset the LCD
	lcdReset();
 8001292:	f7ff ffb3 	bl	80011fc <lcdReset>

    lcdWriteCommand(EXIT_SLEEP_MODE);
 8001296:	2011      	movs	r0, #17
 8001298:	f7ff ffc0 	bl	800121c <lcdWriteCommand>
    Delay(10000); // Wait for the screen to wake up
 800129c:	f242 7010 	movw	r0, #10000	; 0x2710
 80012a0:	f001 fade 	bl	8002860 <Delay>

    lcdWriteCommand(SET_PIXEL_FORMAT);
 80012a4:	203a      	movs	r0, #58	; 0x3a
 80012a6:	f7ff ffb9 	bl	800121c <lcdWriteCommand>
    lcdWriteParameter(0x05); // 16 bits per pixel
 80012aa:	2005      	movs	r0, #5
 80012ac:	f7ff ffc6 	bl	800123c <lcdWriteParameter>

    lcdWriteCommand(SET_GAMMA_CURVE);
 80012b0:	2026      	movs	r0, #38	; 0x26
 80012b2:	f7ff ffb3 	bl	800121c <lcdWriteCommand>
    lcdWriteParameter(0x04); // Select gamma curve 3
 80012b6:	2004      	movs	r0, #4
 80012b8:	f7ff ffc0 	bl	800123c <lcdWriteParameter>

    lcdWriteCommand(GAM_R_SEL);
 80012bc:	20f2      	movs	r0, #242	; 0xf2
 80012be:	f7ff ffad 	bl	800121c <lcdWriteCommand>
    lcdWriteParameter(0x01); // Gamma adjustment enabled
 80012c2:	2001      	movs	r0, #1
 80012c4:	f7ff ffba 	bl	800123c <lcdWriteParameter>

    lcdWriteCommand(POSITIVE_GAMMA_CORRECT);
 80012c8:	20e0      	movs	r0, #224	; 0xe0
 80012ca:	f7ff ffa7 	bl	800121c <lcdWriteCommand>
    lcdWriteParameter(0x3f); // 1st Parameter
 80012ce:	203f      	movs	r0, #63	; 0x3f
 80012d0:	f7ff ffb4 	bl	800123c <lcdWriteParameter>
    lcdWriteParameter(0x25); // 2nd Parameter
 80012d4:	2025      	movs	r0, #37	; 0x25
 80012d6:	f7ff ffb1 	bl	800123c <lcdWriteParameter>
    lcdWriteParameter(0x1c); // 3rd Parameter
 80012da:	201c      	movs	r0, #28
 80012dc:	f7ff ffae 	bl	800123c <lcdWriteParameter>
    lcdWriteParameter(0x1e); // 4th Parameter
 80012e0:	201e      	movs	r0, #30
 80012e2:	f7ff ffab 	bl	800123c <lcdWriteParameter>
    lcdWriteParameter(0x20); // 5th Parameter
 80012e6:	2020      	movs	r0, #32
 80012e8:	f7ff ffa8 	bl	800123c <lcdWriteParameter>
    lcdWriteParameter(0x12); // 6th Parameter
 80012ec:	2012      	movs	r0, #18
 80012ee:	f7ff ffa5 	bl	800123c <lcdWriteParameter>
    lcdWriteParameter(0x2a); // 7th Parameter
 80012f2:	202a      	movs	r0, #42	; 0x2a
 80012f4:	f7ff ffa2 	bl	800123c <lcdWriteParameter>
    lcdWriteParameter(0x90); // 8th Parameter
 80012f8:	2090      	movs	r0, #144	; 0x90
 80012fa:	f7ff ff9f 	bl	800123c <lcdWriteParameter>
    lcdWriteParameter(0x24); // 9th Parameter
 80012fe:	2024      	movs	r0, #36	; 0x24
 8001300:	f7ff ff9c 	bl	800123c <lcdWriteParameter>
    lcdWriteParameter(0x11); // 10th Parameter
 8001304:	2011      	movs	r0, #17
 8001306:	f7ff ff99 	bl	800123c <lcdWriteParameter>
    lcdWriteParameter(0x00); // 11th Parameter
 800130a:	2000      	movs	r0, #0
 800130c:	f7ff ff96 	bl	800123c <lcdWriteParameter>
    lcdWriteParameter(0x00); // 12th Parameter
 8001310:	2000      	movs	r0, #0
 8001312:	f7ff ff93 	bl	800123c <lcdWriteParameter>
    lcdWriteParameter(0x00); // 13th Parameter
 8001316:	2000      	movs	r0, #0
 8001318:	f7ff ff90 	bl	800123c <lcdWriteParameter>
    lcdWriteParameter(0x00); // 14th Parameter
 800131c:	2000      	movs	r0, #0
 800131e:	f7ff ff8d 	bl	800123c <lcdWriteParameter>
    lcdWriteParameter(0x00); // 15th Parameter
 8001322:	2000      	movs	r0, #0
 8001324:	f7ff ff8a 	bl	800123c <lcdWriteParameter>

    lcdWriteCommand(NEGATIVE_GAMMA_CORRECT);
 8001328:	20e1      	movs	r0, #225	; 0xe1
 800132a:	f7ff ff77 	bl	800121c <lcdWriteCommand>
    lcdWriteParameter(0x20); // 1st Parameter
 800132e:	2020      	movs	r0, #32
 8001330:	f7ff ff84 	bl	800123c <lcdWriteParameter>
    lcdWriteParameter(0x20); // 2nd Parameter
 8001334:	2020      	movs	r0, #32
 8001336:	f7ff ff81 	bl	800123c <lcdWriteParameter>
    lcdWriteParameter(0x20); // 3rd Parameter
 800133a:	2020      	movs	r0, #32
 800133c:	f7ff ff7e 	bl	800123c <lcdWriteParameter>
    lcdWriteParameter(0x20); // 4th Parameter
 8001340:	2020      	movs	r0, #32
 8001342:	f7ff ff7b 	bl	800123c <lcdWriteParameter>
    lcdWriteParameter(0x05); // 5th Parameter
 8001346:	2005      	movs	r0, #5
 8001348:	f7ff ff78 	bl	800123c <lcdWriteParameter>
    lcdWriteParameter(0x00); // 6th Parameter
 800134c:	2000      	movs	r0, #0
 800134e:	f7ff ff75 	bl	800123c <lcdWriteParameter>
    lcdWriteParameter(0x15); // 7th Parameter
 8001352:	2015      	movs	r0, #21
 8001354:	f7ff ff72 	bl	800123c <lcdWriteParameter>
    lcdWriteParameter(0xa7); // 8th Parameter
 8001358:	20a7      	movs	r0, #167	; 0xa7
 800135a:	f7ff ff6f 	bl	800123c <lcdWriteParameter>
    lcdWriteParameter(0x3d); // 9th Parameter
 800135e:	203d      	movs	r0, #61	; 0x3d
 8001360:	f7ff ff6c 	bl	800123c <lcdWriteParameter>
    lcdWriteParameter(0x18); // 10th Parameter
 8001364:	2018      	movs	r0, #24
 8001366:	f7ff ff69 	bl	800123c <lcdWriteParameter>
    lcdWriteParameter(0x25); // 11th Parameter
 800136a:	2025      	movs	r0, #37	; 0x25
 800136c:	f7ff ff66 	bl	800123c <lcdWriteParameter>
    lcdWriteParameter(0x2a); // 12th Parameter
 8001370:	202a      	movs	r0, #42	; 0x2a
 8001372:	f7ff ff63 	bl	800123c <lcdWriteParameter>
    lcdWriteParameter(0x2b); // 13th Parameter
 8001376:	202b      	movs	r0, #43	; 0x2b
 8001378:	f7ff ff60 	bl	800123c <lcdWriteParameter>
    lcdWriteParameter(0x2b); // 14th Parameter
 800137c:	202b      	movs	r0, #43	; 0x2b
 800137e:	f7ff ff5d 	bl	800123c <lcdWriteParameter>
    lcdWriteParameter(0x3a); // 15th Parameter
 8001382:	203a      	movs	r0, #58	; 0x3a
 8001384:	f7ff ff5a 	bl	800123c <lcdWriteParameter>

    lcdWriteCommand(FRAME_RATE_CONTROL1);
 8001388:	20b1      	movs	r0, #177	; 0xb1
 800138a:	f7ff ff47 	bl	800121c <lcdWriteCommand>
    lcdWriteParameter(0x08); // DIVA = 8
 800138e:	2008      	movs	r0, #8
 8001390:	f7ff ff54 	bl	800123c <lcdWriteParameter>
    lcdWriteParameter(0x08); // VPA = 8
 8001394:	2008      	movs	r0, #8
 8001396:	f7ff ff51 	bl	800123c <lcdWriteParameter>

    lcdWriteCommand(DISPLAY_INVERSION);
 800139a:	20b4      	movs	r0, #180	; 0xb4
 800139c:	f7ff ff3e 	bl	800121c <lcdWriteCommand>
    lcdWriteParameter(0x07); // NLA = 1, NLB = 1, NLC = 1 (all on Frame Inversion)
 80013a0:	2007      	movs	r0, #7
 80013a2:	f7ff ff4b 	bl	800123c <lcdWriteParameter>

    lcdWriteCommand(POWER_CONTROL1);
 80013a6:	20c0      	movs	r0, #192	; 0xc0
 80013a8:	f7ff ff38 	bl	800121c <lcdWriteCommand>
    lcdWriteParameter(0x0a); // VRH = 10:  GVDD = 4.30
 80013ac:	200a      	movs	r0, #10
 80013ae:	f7ff ff45 	bl	800123c <lcdWriteParameter>
    lcdWriteParameter(0x02); // VC = 2: VCI1 = 2.65
 80013b2:	2002      	movs	r0, #2
 80013b4:	f7ff ff42 	bl	800123c <lcdWriteParameter>

    lcdWriteCommand(POWER_CONTROL2);
 80013b8:	20c1      	movs	r0, #193	; 0xc1
 80013ba:	f7ff ff2f 	bl	800121c <lcdWriteCommand>
    lcdWriteParameter(0x02); // BT = 2: AVDD = 2xVCI1, VCL = -1xVCI1, VGH = 5xVCI1, VGL = -2xVCI1
 80013be:	2002      	movs	r0, #2
 80013c0:	f7ff ff3c 	bl	800123c <lcdWriteParameter>

    lcdWriteCommand(VCOM_CONTROL1);
 80013c4:	20c5      	movs	r0, #197	; 0xc5
 80013c6:	f7ff ff29 	bl	800121c <lcdWriteCommand>
    lcdWriteParameter(0x50); // VMH = 80: VCOMH voltage = 4.5
 80013ca:	2050      	movs	r0, #80	; 0x50
 80013cc:	f7ff ff36 	bl	800123c <lcdWriteParameter>
    lcdWriteParameter(0x5b); // VML = 91: VCOML voltage = -0.225
 80013d0:	205b      	movs	r0, #91	; 0x5b
 80013d2:	f7ff ff33 	bl	800123c <lcdWriteParameter>

    lcdWriteCommand(VCOM_OFFSET_CONTROL);
 80013d6:	20c7      	movs	r0, #199	; 0xc7
 80013d8:	f7ff ff20 	bl	800121c <lcdWriteCommand>
    lcdWriteParameter(0x40); // nVM = 0, VMF = 64: VCOMH output = VMH, VCOML output = VML
 80013dc:	2040      	movs	r0, #64	; 0x40
 80013de:	f7ff ff2d 	bl	800123c <lcdWriteParameter>

    lcdWriteCommand(SET_COLUMN_ADDRESS);
 80013e2:	202a      	movs	r0, #42	; 0x2a
 80013e4:	f7ff ff1a 	bl	800121c <lcdWriteCommand>
    lcdWriteParameter(0x00); // XSH
 80013e8:	2000      	movs	r0, #0
 80013ea:	f7ff ff27 	bl	800123c <lcdWriteParameter>
    lcdWriteParameter(0x00); // XSL
 80013ee:	2000      	movs	r0, #0
 80013f0:	f7ff ff24 	bl	800123c <lcdWriteParameter>
    lcdWriteParameter(0x00); // XEH
 80013f4:	2000      	movs	r0, #0
 80013f6:	f7ff ff21 	bl	800123c <lcdWriteParameter>
    lcdWriteParameter(0x7f); // XEL (128 pixels x)
 80013fa:	207f      	movs	r0, #127	; 0x7f
 80013fc:	f7ff ff1e 	bl	800123c <lcdWriteParameter>

    lcdWriteCommand(SET_PAGE_ADDRESS);
 8001400:	202b      	movs	r0, #43	; 0x2b
 8001402:	f7ff ff0b 	bl	800121c <lcdWriteCommand>
    lcdWriteParameter(0x00);
 8001406:	2000      	movs	r0, #0
 8001408:	f7ff ff18 	bl	800123c <lcdWriteParameter>
    lcdWriteParameter(0x00);
 800140c:	2000      	movs	r0, #0
 800140e:	f7ff ff15 	bl	800123c <lcdWriteParameter>
    lcdWriteParameter(0x00);
 8001412:	2000      	movs	r0, #0
 8001414:	f7ff ff12 	bl	800123c <lcdWriteParameter>
    lcdWriteParameter(0x7f); // 128 pixels y
 8001418:	207f      	movs	r0, #127	; 0x7f
 800141a:	f7ff ff0f 	bl	800123c <lcdWriteParameter>

	// Select display orientation
    lcdWriteCommand(SET_ADDRESS_MODE);
 800141e:	2036      	movs	r0, #54	; 0x36
 8001420:	f7ff fefc 	bl	800121c <lcdWriteCommand>
	lcdWriteParameter(orientation);
 8001424:	79fb      	ldrb	r3, [r7, #7]
 8001426:	4618      	mov	r0, r3
 8001428:	f7ff ff08 	bl	800123c <lcdWriteParameter>

	// Set the display to on
    lcdWriteCommand(SET_DISPLAY_ON);
 800142c:	2029      	movs	r0, #41	; 0x29
 800142e:	f7ff fef5 	bl	800121c <lcdWriteCommand>
    lcdWriteCommand(WRITE_MEMORY_START);
 8001432:	202c      	movs	r0, #44	; 0x2c
 8001434:	f7ff fef2 	bl	800121c <lcdWriteCommand>
}
 8001438:	bf00      	nop
 800143a:	3708      	adds	r7, #8
 800143c:	46bd      	mov	sp, r7
 800143e:	bd80      	pop	{r7, pc}

08001440 <lcdClearDisplay>:

// LCD graphics functions -----------------------------------------------------------------------------------

void lcdClearDisplay(uint16_t colour)
{
 8001440:	b580      	push	{r7, lr}
 8001442:	b084      	sub	sp, #16
 8001444:	af00      	add	r7, sp, #0
 8001446:	4603      	mov	r3, r0
 8001448:	80fb      	strh	r3, [r7, #6]
	uint16_t pixel;

	// Set the column address to 0-127
	lcdWriteCommand(SET_COLUMN_ADDRESS);
 800144a:	202a      	movs	r0, #42	; 0x2a
 800144c:	f7ff fee6 	bl	800121c <lcdWriteCommand>
	lcdWriteParameter(0x00);
 8001450:	2000      	movs	r0, #0
 8001452:	f7ff fef3 	bl	800123c <lcdWriteParameter>
	lcdWriteParameter(0x00);
 8001456:	2000      	movs	r0, #0
 8001458:	f7ff fef0 	bl	800123c <lcdWriteParameter>
	lcdWriteParameter(0x00);
 800145c:	2000      	movs	r0, #0
 800145e:	f7ff feed 	bl	800123c <lcdWriteParameter>
	lcdWriteParameter(0x7f);
 8001462:	207f      	movs	r0, #127	; 0x7f
 8001464:	f7ff feea 	bl	800123c <lcdWriteParameter>

	// Set the page address to 0-127
	lcdWriteCommand(SET_PAGE_ADDRESS);
 8001468:	202b      	movs	r0, #43	; 0x2b
 800146a:	f7ff fed7 	bl	800121c <lcdWriteCommand>
	lcdWriteParameter(0x00);
 800146e:	2000      	movs	r0, #0
 8001470:	f7ff fee4 	bl	800123c <lcdWriteParameter>
	lcdWriteParameter(0x00);
 8001474:	2000      	movs	r0, #0
 8001476:	f7ff fee1 	bl	800123c <lcdWriteParameter>
	lcdWriteParameter(0x00);
 800147a:	2000      	movs	r0, #0
 800147c:	f7ff fede 	bl	800123c <lcdWriteParameter>
	lcdWriteParameter(0x7f);
 8001480:	207f      	movs	r0, #127	; 0x7f
 8001482:	f7ff fedb 	bl	800123c <lcdWriteParameter>

	// Plot the pixels
	lcdWriteCommand(WRITE_MEMORY_START);
 8001486:	202c      	movs	r0, #44	; 0x2c
 8001488:	f7ff fec8 	bl	800121c <lcdWriteCommand>
	for(pixel = 0; pixel < 16385; pixel++) lcdWriteData(colour >> 8, colour);
 800148c:	2300      	movs	r3, #0
 800148e:	81fb      	strh	r3, [r7, #14]
 8001490:	e00c      	b.n	80014ac <lcdClearDisplay+0x6c>
 8001492:	88fb      	ldrh	r3, [r7, #6]
 8001494:	0a1b      	lsrs	r3, r3, #8
 8001496:	b29b      	uxth	r3, r3
 8001498:	b2db      	uxtb	r3, r3
 800149a:	88fa      	ldrh	r2, [r7, #6]
 800149c:	b2d2      	uxtb	r2, r2
 800149e:	4611      	mov	r1, r2
 80014a0:	4618      	mov	r0, r3
 80014a2:	f7ff fedb 	bl	800125c <lcdWriteData>
 80014a6:	89fb      	ldrh	r3, [r7, #14]
 80014a8:	3301      	adds	r3, #1
 80014aa:	81fb      	strh	r3, [r7, #14]
 80014ac:	89fb      	ldrh	r3, [r7, #14]
 80014ae:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 80014b2:	d9ee      	bls.n	8001492 <lcdClearDisplay+0x52>
}
 80014b4:	bf00      	nop
 80014b6:	3710      	adds	r7, #16
 80014b8:	46bd      	mov	sp, r7
 80014ba:	bd80      	pop	{r7, pc}

080014bc <lcdPlot>:

void lcdPlot(uint8_t x, uint8_t y, uint16_t colour)
{
 80014bc:	b580      	push	{r7, lr}
 80014be:	b082      	sub	sp, #8
 80014c0:	af00      	add	r7, sp, #0
 80014c2:	4603      	mov	r3, r0
 80014c4:	71fb      	strb	r3, [r7, #7]
 80014c6:	460b      	mov	r3, r1
 80014c8:	71bb      	strb	r3, [r7, #6]
 80014ca:	4613      	mov	r3, r2
 80014cc:	80bb      	strh	r3, [r7, #4]
	// Horizontal Address Start Position
	lcdWriteCommand(SET_COLUMN_ADDRESS);
 80014ce:	202a      	movs	r0, #42	; 0x2a
 80014d0:	f7ff fea4 	bl	800121c <lcdWriteCommand>
	lcdWriteParameter(0x00);
 80014d4:	2000      	movs	r0, #0
 80014d6:	f7ff feb1 	bl	800123c <lcdWriteParameter>
	lcdWriteParameter(x);
 80014da:	79fb      	ldrb	r3, [r7, #7]
 80014dc:	4618      	mov	r0, r3
 80014de:	f7ff fead 	bl	800123c <lcdWriteParameter>
	lcdWriteParameter(0x00);
 80014e2:	2000      	movs	r0, #0
 80014e4:	f7ff feaa 	bl	800123c <lcdWriteParameter>
	lcdWriteParameter(0x7f);
 80014e8:	207f      	movs	r0, #127	; 0x7f
 80014ea:	f7ff fea7 	bl	800123c <lcdWriteParameter>

	// Vertical Address end Position
	lcdWriteCommand(SET_PAGE_ADDRESS);
 80014ee:	202b      	movs	r0, #43	; 0x2b
 80014f0:	f7ff fe94 	bl	800121c <lcdWriteCommand>
	lcdWriteParameter(0x00);
 80014f4:	2000      	movs	r0, #0
 80014f6:	f7ff fea1 	bl	800123c <lcdWriteParameter>
	lcdWriteParameter(y);
 80014fa:	79bb      	ldrb	r3, [r7, #6]
 80014fc:	4618      	mov	r0, r3
 80014fe:	f7ff fe9d 	bl	800123c <lcdWriteParameter>
	lcdWriteParameter(0x00);
 8001502:	2000      	movs	r0, #0
 8001504:	f7ff fe9a 	bl	800123c <lcdWriteParameter>
	lcdWriteParameter(0x7f);//7f
 8001508:	207f      	movs	r0, #127	; 0x7f
 800150a:	f7ff fe97 	bl	800123c <lcdWriteParameter>

	// Plot the point
	lcdWriteCommand(WRITE_MEMORY_START);
 800150e:	202c      	movs	r0, #44	; 0x2c
 8001510:	f7ff fe84 	bl	800121c <lcdWriteCommand>
	lcdWriteData(colour >> 8, colour);
 8001514:	88bb      	ldrh	r3, [r7, #4]
 8001516:	0a1b      	lsrs	r3, r3, #8
 8001518:	b29b      	uxth	r3, r3
 800151a:	b2db      	uxtb	r3, r3
 800151c:	88ba      	ldrh	r2, [r7, #4]
 800151e:	b2d2      	uxtb	r2, r2
 8001520:	4611      	mov	r1, r2
 8001522:	4618      	mov	r0, r3
 8001524:	f7ff fe9a 	bl	800125c <lcdWriteData>
}
 8001528:	bf00      	nop
 800152a:	3708      	adds	r7, #8
 800152c:	46bd      	mov	sp, r7
 800152e:	bd80      	pop	{r7, pc}

08001530 <lcdCircle>:
// Draw a circle
// Note:	This is another version of Bresenham's line drawing algorithm.
//			There's plenty of documentation on the web if you are curious
//			how this works.
void lcdCircle(int16_t xCentre, int16_t yCentre, int16_t radius, uint16_t colour)
{
 8001530:	b590      	push	{r4, r7, lr}
 8001532:	b085      	sub	sp, #20
 8001534:	af00      	add	r7, sp, #0
 8001536:	4604      	mov	r4, r0
 8001538:	4608      	mov	r0, r1
 800153a:	4611      	mov	r1, r2
 800153c:	461a      	mov	r2, r3
 800153e:	4623      	mov	r3, r4
 8001540:	80fb      	strh	r3, [r7, #6]
 8001542:	4603      	mov	r3, r0
 8001544:	80bb      	strh	r3, [r7, #4]
 8001546:	460b      	mov	r3, r1
 8001548:	807b      	strh	r3, [r7, #2]
 800154a:	4613      	mov	r3, r2
 800154c:	803b      	strh	r3, [r7, #0]
	int16_t x = 0, y = radius;
 800154e:	2300      	movs	r3, #0
 8001550:	81fb      	strh	r3, [r7, #14]
 8001552:	887b      	ldrh	r3, [r7, #2]
 8001554:	81bb      	strh	r3, [r7, #12]
	int16_t d = 3 - (2 * radius);
 8001556:	887b      	ldrh	r3, [r7, #2]
 8001558:	005b      	lsls	r3, r3, #1
 800155a:	b29b      	uxth	r3, r3
 800155c:	f1c3 0303 	rsb	r3, r3, #3
 8001560:	b29b      	uxth	r3, r3
 8001562:	817b      	strh	r3, [r7, #10]

    while(x <= y)
 8001564:	e0a5      	b.n	80016b2 <lcdCircle+0x182>
	{
		lcdPlot(xCentre + x, yCentre + y, colour);
 8001566:	88fb      	ldrh	r3, [r7, #6]
 8001568:	b2da      	uxtb	r2, r3
 800156a:	89fb      	ldrh	r3, [r7, #14]
 800156c:	b2db      	uxtb	r3, r3
 800156e:	4413      	add	r3, r2
 8001570:	b2d8      	uxtb	r0, r3
 8001572:	88bb      	ldrh	r3, [r7, #4]
 8001574:	b2da      	uxtb	r2, r3
 8001576:	89bb      	ldrh	r3, [r7, #12]
 8001578:	b2db      	uxtb	r3, r3
 800157a:	4413      	add	r3, r2
 800157c:	b2db      	uxtb	r3, r3
 800157e:	883a      	ldrh	r2, [r7, #0]
 8001580:	4619      	mov	r1, r3
 8001582:	f7ff ff9b 	bl	80014bc <lcdPlot>
		lcdPlot(xCentre + y, yCentre + x, colour);
 8001586:	88fb      	ldrh	r3, [r7, #6]
 8001588:	b2da      	uxtb	r2, r3
 800158a:	89bb      	ldrh	r3, [r7, #12]
 800158c:	b2db      	uxtb	r3, r3
 800158e:	4413      	add	r3, r2
 8001590:	b2d8      	uxtb	r0, r3
 8001592:	88bb      	ldrh	r3, [r7, #4]
 8001594:	b2da      	uxtb	r2, r3
 8001596:	89fb      	ldrh	r3, [r7, #14]
 8001598:	b2db      	uxtb	r3, r3
 800159a:	4413      	add	r3, r2
 800159c:	b2db      	uxtb	r3, r3
 800159e:	883a      	ldrh	r2, [r7, #0]
 80015a0:	4619      	mov	r1, r3
 80015a2:	f7ff ff8b 	bl	80014bc <lcdPlot>
		lcdPlot(xCentre - x, yCentre + y, colour);
 80015a6:	88fb      	ldrh	r3, [r7, #6]
 80015a8:	b2da      	uxtb	r2, r3
 80015aa:	89fb      	ldrh	r3, [r7, #14]
 80015ac:	b2db      	uxtb	r3, r3
 80015ae:	1ad3      	subs	r3, r2, r3
 80015b0:	b2d8      	uxtb	r0, r3
 80015b2:	88bb      	ldrh	r3, [r7, #4]
 80015b4:	b2da      	uxtb	r2, r3
 80015b6:	89bb      	ldrh	r3, [r7, #12]
 80015b8:	b2db      	uxtb	r3, r3
 80015ba:	4413      	add	r3, r2
 80015bc:	b2db      	uxtb	r3, r3
 80015be:	883a      	ldrh	r2, [r7, #0]
 80015c0:	4619      	mov	r1, r3
 80015c2:	f7ff ff7b 	bl	80014bc <lcdPlot>
		lcdPlot(xCentre + y, yCentre - x, colour);
 80015c6:	88fb      	ldrh	r3, [r7, #6]
 80015c8:	b2da      	uxtb	r2, r3
 80015ca:	89bb      	ldrh	r3, [r7, #12]
 80015cc:	b2db      	uxtb	r3, r3
 80015ce:	4413      	add	r3, r2
 80015d0:	b2d8      	uxtb	r0, r3
 80015d2:	88bb      	ldrh	r3, [r7, #4]
 80015d4:	b2da      	uxtb	r2, r3
 80015d6:	89fb      	ldrh	r3, [r7, #14]
 80015d8:	b2db      	uxtb	r3, r3
 80015da:	1ad3      	subs	r3, r2, r3
 80015dc:	b2db      	uxtb	r3, r3
 80015de:	883a      	ldrh	r2, [r7, #0]
 80015e0:	4619      	mov	r1, r3
 80015e2:	f7ff ff6b 	bl	80014bc <lcdPlot>
		lcdPlot(xCentre - x, yCentre - y, colour);
 80015e6:	88fb      	ldrh	r3, [r7, #6]
 80015e8:	b2da      	uxtb	r2, r3
 80015ea:	89fb      	ldrh	r3, [r7, #14]
 80015ec:	b2db      	uxtb	r3, r3
 80015ee:	1ad3      	subs	r3, r2, r3
 80015f0:	b2d8      	uxtb	r0, r3
 80015f2:	88bb      	ldrh	r3, [r7, #4]
 80015f4:	b2da      	uxtb	r2, r3
 80015f6:	89bb      	ldrh	r3, [r7, #12]
 80015f8:	b2db      	uxtb	r3, r3
 80015fa:	1ad3      	subs	r3, r2, r3
 80015fc:	b2db      	uxtb	r3, r3
 80015fe:	883a      	ldrh	r2, [r7, #0]
 8001600:	4619      	mov	r1, r3
 8001602:	f7ff ff5b 	bl	80014bc <lcdPlot>
		lcdPlot(xCentre - y, yCentre - x, colour);
 8001606:	88fb      	ldrh	r3, [r7, #6]
 8001608:	b2da      	uxtb	r2, r3
 800160a:	89bb      	ldrh	r3, [r7, #12]
 800160c:	b2db      	uxtb	r3, r3
 800160e:	1ad3      	subs	r3, r2, r3
 8001610:	b2d8      	uxtb	r0, r3
 8001612:	88bb      	ldrh	r3, [r7, #4]
 8001614:	b2da      	uxtb	r2, r3
 8001616:	89fb      	ldrh	r3, [r7, #14]
 8001618:	b2db      	uxtb	r3, r3
 800161a:	1ad3      	subs	r3, r2, r3
 800161c:	b2db      	uxtb	r3, r3
 800161e:	883a      	ldrh	r2, [r7, #0]
 8001620:	4619      	mov	r1, r3
 8001622:	f7ff ff4b 	bl	80014bc <lcdPlot>
		lcdPlot(xCentre + x, yCentre - y, colour);
 8001626:	88fb      	ldrh	r3, [r7, #6]
 8001628:	b2da      	uxtb	r2, r3
 800162a:	89fb      	ldrh	r3, [r7, #14]
 800162c:	b2db      	uxtb	r3, r3
 800162e:	4413      	add	r3, r2
 8001630:	b2d8      	uxtb	r0, r3
 8001632:	88bb      	ldrh	r3, [r7, #4]
 8001634:	b2da      	uxtb	r2, r3
 8001636:	89bb      	ldrh	r3, [r7, #12]
 8001638:	b2db      	uxtb	r3, r3
 800163a:	1ad3      	subs	r3, r2, r3
 800163c:	b2db      	uxtb	r3, r3
 800163e:	883a      	ldrh	r2, [r7, #0]
 8001640:	4619      	mov	r1, r3
 8001642:	f7ff ff3b 	bl	80014bc <lcdPlot>
		lcdPlot(xCentre - y, yCentre + x, colour);
 8001646:	88fb      	ldrh	r3, [r7, #6]
 8001648:	b2da      	uxtb	r2, r3
 800164a:	89bb      	ldrh	r3, [r7, #12]
 800164c:	b2db      	uxtb	r3, r3
 800164e:	1ad3      	subs	r3, r2, r3
 8001650:	b2d8      	uxtb	r0, r3
 8001652:	88bb      	ldrh	r3, [r7, #4]
 8001654:	b2da      	uxtb	r2, r3
 8001656:	89fb      	ldrh	r3, [r7, #14]
 8001658:	b2db      	uxtb	r3, r3
 800165a:	4413      	add	r3, r2
 800165c:	b2db      	uxtb	r3, r3
 800165e:	883a      	ldrh	r2, [r7, #0]
 8001660:	4619      	mov	r1, r3
 8001662:	f7ff ff2b 	bl	80014bc <lcdPlot>

		if (d < 0) d += (4 * x) + 6;
 8001666:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 800166a:	2b00      	cmp	r3, #0
 800166c:	da09      	bge.n	8001682 <lcdCircle+0x152>
 800166e:	89fb      	ldrh	r3, [r7, #14]
 8001670:	009b      	lsls	r3, r3, #2
 8001672:	b29a      	uxth	r2, r3
 8001674:	897b      	ldrh	r3, [r7, #10]
 8001676:	4413      	add	r3, r2
 8001678:	b29b      	uxth	r3, r3
 800167a:	3306      	adds	r3, #6
 800167c:	b29b      	uxth	r3, r3
 800167e:	817b      	strh	r3, [r7, #10]
 8001680:	e011      	b.n	80016a6 <lcdCircle+0x176>
		else
		{
			d += (4 * (x - y)) + 10;
 8001682:	f9b7 200e 	ldrsh.w	r2, [r7, #14]
 8001686:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 800168a:	1ad3      	subs	r3, r2, r3
 800168c:	b29b      	uxth	r3, r3
 800168e:	009b      	lsls	r3, r3, #2
 8001690:	b29a      	uxth	r2, r3
 8001692:	897b      	ldrh	r3, [r7, #10]
 8001694:	4413      	add	r3, r2
 8001696:	b29b      	uxth	r3, r3
 8001698:	330a      	adds	r3, #10
 800169a:	b29b      	uxth	r3, r3
 800169c:	817b      	strh	r3, [r7, #10]
			y -= 1;
 800169e:	89bb      	ldrh	r3, [r7, #12]
 80016a0:	3b01      	subs	r3, #1
 80016a2:	b29b      	uxth	r3, r3
 80016a4:	81bb      	strh	r3, [r7, #12]
		}

		x++;
 80016a6:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 80016aa:	b29b      	uxth	r3, r3
 80016ac:	3301      	adds	r3, #1
 80016ae:	b29b      	uxth	r3, r3
 80016b0:	81fb      	strh	r3, [r7, #14]
void lcdCircle(int16_t xCentre, int16_t yCentre, int16_t radius, uint16_t colour)
{
	int16_t x = 0, y = radius;
	int16_t d = 3 - (2 * radius);

    while(x <= y)
 80016b2:	f9b7 200e 	ldrsh.w	r2, [r7, #14]
 80016b6:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 80016ba:	429a      	cmp	r2, r3
 80016bc:	f77f af53 	ble.w	8001566 <lcdCircle+0x36>
			y -= 1;
		}

		x++;
	}
}
 80016c0:	bf00      	nop
 80016c2:	3714      	adds	r7, #20
 80016c4:	46bd      	mov	sp, r7
 80016c6:	bd90      	pop	{r4, r7, pc}

080016c8 <lcdPutCh>:

// LCD text manipulation functions --------------------------------------------------------------------------
#define pgm_read_byte_near(address_short) (uint16_t)(address_short)
// Plot a character at the specified x, y co-ordinates (top left hand corner of character)
void lcdPutCh(unsigned char character, uint8_t x, uint8_t y, uint16_t fgColour, uint16_t bgColour)
{
 80016c8:	b590      	push	{r4, r7, lr}
 80016ca:	b085      	sub	sp, #20
 80016cc:	af00      	add	r7, sp, #0
 80016ce:	4604      	mov	r4, r0
 80016d0:	4608      	mov	r0, r1
 80016d2:	4611      	mov	r1, r2
 80016d4:	461a      	mov	r2, r3
 80016d6:	4623      	mov	r3, r4
 80016d8:	71fb      	strb	r3, [r7, #7]
 80016da:	4603      	mov	r3, r0
 80016dc:	71bb      	strb	r3, [r7, #6]
 80016de:	460b      	mov	r3, r1
 80016e0:	717b      	strb	r3, [r7, #5]
 80016e2:	4613      	mov	r3, r2
 80016e4:	807b      	strh	r3, [r7, #2]

	// To speed up plotting we define a x window of 6 pixels and then
	// write out one row at a time.  This means the LCD will correctly
	// update the memory pointer saving us a good few bytes

	lcdWriteCommand(SET_COLUMN_ADDRESS); // Horizontal Address Start Position
 80016e6:	202a      	movs	r0, #42	; 0x2a
 80016e8:	f7ff fd98 	bl	800121c <lcdWriteCommand>
	lcdWriteParameter(0x00);
 80016ec:	2000      	movs	r0, #0
 80016ee:	f7ff fda5 	bl	800123c <lcdWriteParameter>
	lcdWriteParameter(x);
 80016f2:	79bb      	ldrb	r3, [r7, #6]
 80016f4:	4618      	mov	r0, r3
 80016f6:	f7ff fda1 	bl	800123c <lcdWriteParameter>
	lcdWriteParameter(0x00);
 80016fa:	2000      	movs	r0, #0
 80016fc:	f7ff fd9e 	bl	800123c <lcdWriteParameter>
	lcdWriteParameter(x+5);
 8001700:	79bb      	ldrb	r3, [r7, #6]
 8001702:	3305      	adds	r3, #5
 8001704:	b2db      	uxtb	r3, r3
 8001706:	4618      	mov	r0, r3
 8001708:	f7ff fd98 	bl	800123c <lcdWriteParameter>

	lcdWriteCommand(SET_PAGE_ADDRESS); // Vertical Address end Position
 800170c:	202b      	movs	r0, #43	; 0x2b
 800170e:	f7ff fd85 	bl	800121c <lcdWriteCommand>
	lcdWriteParameter(0x00);
 8001712:	2000      	movs	r0, #0
 8001714:	f7ff fd92 	bl	800123c <lcdWriteParameter>
	lcdWriteParameter(y);
 8001718:	797b      	ldrb	r3, [r7, #5]
 800171a:	4618      	mov	r0, r3
 800171c:	f7ff fd8e 	bl	800123c <lcdWriteParameter>
	lcdWriteParameter(0x00);
 8001720:	2000      	movs	r0, #0
 8001722:	f7ff fd8b 	bl	800123c <lcdWriteParameter>
	lcdWriteParameter(0x7f);
 8001726:	207f      	movs	r0, #127	; 0x7f
 8001728:	f7ff fd88 	bl	800123c <lcdWriteParameter>

	lcdWriteCommand(WRITE_MEMORY_START);
 800172c:	202c      	movs	r0, #44	; 0x2c
 800172e:	f7ff fd75 	bl	800121c <lcdWriteCommand>

	// Plot the font data
	for (row = 0; row < 8; row++)
 8001732:	2300      	movs	r3, #0
 8001734:	73fb      	strb	r3, [r7, #15]
 8001736:	e032      	b.n	800179e <lcdPutCh+0xd6>
	{
		for (column = 0; column < 6; column++)
 8001738:	2300      	movs	r3, #0
 800173a:	73bb      	strb	r3, [r7, #14]
 800173c:	e029      	b.n	8001792 <lcdPutCh+0xca>
		{
			if ((font5x8[character][column]) & (1 << row))
 800173e:	79fa      	ldrb	r2, [r7, #7]
 8001740:	7bb9      	ldrb	r1, [r7, #14]
 8001742:	481a      	ldr	r0, [pc, #104]	; (80017ac <lcdPutCh+0xe4>)
 8001744:	4613      	mov	r3, r2
 8001746:	005b      	lsls	r3, r3, #1
 8001748:	4413      	add	r3, r2
 800174a:	005b      	lsls	r3, r3, #1
 800174c:	4403      	add	r3, r0
 800174e:	440b      	add	r3, r1
 8001750:	781b      	ldrb	r3, [r3, #0]
 8001752:	461a      	mov	r2, r3
 8001754:	7bfb      	ldrb	r3, [r7, #15]
 8001756:	fa42 f303 	asr.w	r3, r2, r3
 800175a:	f003 0301 	and.w	r3, r3, #1
 800175e:	2b00      	cmp	r3, #0
 8001760:	d00a      	beq.n	8001778 <lcdPutCh+0xb0>
				lcdWriteData(fgColour>>8, fgColour);
 8001762:	887b      	ldrh	r3, [r7, #2]
 8001764:	0a1b      	lsrs	r3, r3, #8
 8001766:	b29b      	uxth	r3, r3
 8001768:	b2db      	uxtb	r3, r3
 800176a:	887a      	ldrh	r2, [r7, #2]
 800176c:	b2d2      	uxtb	r2, r2
 800176e:	4611      	mov	r1, r2
 8001770:	4618      	mov	r0, r3
 8001772:	f7ff fd73 	bl	800125c <lcdWriteData>
 8001776:	e009      	b.n	800178c <lcdPutCh+0xc4>
			else lcdWriteData(bgColour >> 8, bgColour);
 8001778:	8c3b      	ldrh	r3, [r7, #32]
 800177a:	0a1b      	lsrs	r3, r3, #8
 800177c:	b29b      	uxth	r3, r3
 800177e:	b2db      	uxtb	r3, r3
 8001780:	8c3a      	ldrh	r2, [r7, #32]
 8001782:	b2d2      	uxtb	r2, r2
 8001784:	4611      	mov	r1, r2
 8001786:	4618      	mov	r0, r3
 8001788:	f7ff fd68 	bl	800125c <lcdWriteData>
	lcdWriteCommand(WRITE_MEMORY_START);

	// Plot the font data
	for (row = 0; row < 8; row++)
	{
		for (column = 0; column < 6; column++)
 800178c:	7bbb      	ldrb	r3, [r7, #14]
 800178e:	3301      	adds	r3, #1
 8001790:	73bb      	strb	r3, [r7, #14]
 8001792:	7bbb      	ldrb	r3, [r7, #14]
 8001794:	2b05      	cmp	r3, #5
 8001796:	d9d2      	bls.n	800173e <lcdPutCh+0x76>
	lcdWriteParameter(0x7f);

	lcdWriteCommand(WRITE_MEMORY_START);

	// Plot the font data
	for (row = 0; row < 8; row++)
 8001798:	7bfb      	ldrb	r3, [r7, #15]
 800179a:	3301      	adds	r3, #1
 800179c:	73fb      	strb	r3, [r7, #15]
 800179e:	7bfb      	ldrb	r3, [r7, #15]
 80017a0:	2b07      	cmp	r3, #7
 80017a2:	d9c9      	bls.n	8001738 <lcdPutCh+0x70>
			if ((font5x8[character][column]) & (1 << row))
				lcdWriteData(fgColour>>8, fgColour);
			else lcdWriteData(bgColour >> 8, bgColour);
		}
	}
}
 80017a4:	bf00      	nop
 80017a6:	3714      	adds	r7, #20
 80017a8:	46bd      	mov	sp, r7
 80017aa:	bd90      	pop	{r4, r7, pc}
 80017ac:	08002d24 	.word	0x08002d24

080017b0 <decodeRgbValue>:

// Translates a 3 byte RGB value into a 2 byte value for the LCD (values should be 0-31)
uint16_t decodeRgbValue(uint8_t r, uint8_t g, uint8_t b)
{
 80017b0:	b480      	push	{r7}
 80017b2:	b083      	sub	sp, #12
 80017b4:	af00      	add	r7, sp, #0
 80017b6:	4603      	mov	r3, r0
 80017b8:	71fb      	strb	r3, [r7, #7]
 80017ba:	460b      	mov	r3, r1
 80017bc:	71bb      	strb	r3, [r7, #6]
 80017be:	4613      	mov	r3, r2
 80017c0:	717b      	strb	r3, [r7, #5]
	return (b << 11) | (g << 6) | (r);
 80017c2:	797b      	ldrb	r3, [r7, #5]
 80017c4:	02db      	lsls	r3, r3, #11
 80017c6:	b21a      	sxth	r2, r3
 80017c8:	79bb      	ldrb	r3, [r7, #6]
 80017ca:	019b      	lsls	r3, r3, #6
 80017cc:	b21b      	sxth	r3, r3
 80017ce:	4313      	orrs	r3, r2
 80017d0:	b21a      	sxth	r2, r3
 80017d2:	79fb      	ldrb	r3, [r7, #7]
 80017d4:	b21b      	sxth	r3, r3
 80017d6:	4313      	orrs	r3, r2
 80017d8:	b21b      	sxth	r3, r3
 80017da:	b29b      	uxth	r3, r3
}
 80017dc:	4618      	mov	r0, r3
 80017de:	370c      	adds	r7, #12
 80017e0:	46bd      	mov	sp, r7
 80017e2:	bc80      	pop	{r7}
 80017e4:	4770      	bx	lr
 80017e6:	bf00      	nop

080017e8 <lcdPutS>:
// it easy to place text
uint8_t lcdTextY(uint8_t y) { return y*8; }

// Plot a string of characters to the LCD
void lcdPutS(const char *string, uint8_t x, uint8_t y, uint16_t fgColour, uint16_t bgColour)
{
 80017e8:	b590      	push	{r4, r7, lr}
 80017ea:	b087      	sub	sp, #28
 80017ec:	af02      	add	r7, sp, #8
 80017ee:	6078      	str	r0, [r7, #4]
 80017f0:	4608      	mov	r0, r1
 80017f2:	4611      	mov	r1, r2
 80017f4:	461a      	mov	r2, r3
 80017f6:	4603      	mov	r3, r0
 80017f8:	70fb      	strb	r3, [r7, #3]
 80017fa:	460b      	mov	r3, r1
 80017fc:	70bb      	strb	r3, [r7, #2]
 80017fe:	4613      	mov	r3, r2
 8001800:	803b      	strh	r3, [r7, #0]
	uint8_t origin = x;
 8001802:	78fb      	ldrb	r3, [r7, #3]
 8001804:	73bb      	strb	r3, [r7, #14]
	uint8_t characterNumber;

	for (characterNumber = 0; characterNumber < strlen(string); characterNumber++)
 8001806:	2300      	movs	r3, #0
 8001808:	73fb      	strb	r3, [r7, #15]
 800180a:	e01c      	b.n	8001846 <lcdPutS+0x5e>
	{
		// Check if we are out of bounds and move to
		// the next line if we are
		if (x > 121)
 800180c:	78fb      	ldrb	r3, [r7, #3]
 800180e:	2b79      	cmp	r3, #121	; 0x79
 8001810:	d904      	bls.n	800181c <lcdPutS+0x34>
		{
			x = origin;
 8001812:	7bbb      	ldrb	r3, [r7, #14]
 8001814:	70fb      	strb	r3, [r7, #3]
			y += 8;
 8001816:	78bb      	ldrb	r3, [r7, #2]
 8001818:	3308      	adds	r3, #8
 800181a:	70bb      	strb	r3, [r7, #2]
		}

		// If we move past the bottom of the screen just exit
		if (y > 120) break;
 800181c:	78bb      	ldrb	r3, [r7, #2]
 800181e:	2b78      	cmp	r3, #120	; 0x78
 8001820:	d819      	bhi.n	8001856 <lcdPutS+0x6e>

		// Plot the current character
		lcdPutCh(string[characterNumber], x, y, fgColour, bgColour);
 8001822:	7bfb      	ldrb	r3, [r7, #15]
 8001824:	687a      	ldr	r2, [r7, #4]
 8001826:	4413      	add	r3, r2
 8001828:	7818      	ldrb	r0, [r3, #0]
 800182a:	883c      	ldrh	r4, [r7, #0]
 800182c:	78ba      	ldrb	r2, [r7, #2]
 800182e:	78f9      	ldrb	r1, [r7, #3]
 8001830:	8c3b      	ldrh	r3, [r7, #32]
 8001832:	9300      	str	r3, [sp, #0]
 8001834:	4623      	mov	r3, r4
 8001836:	f7ff ff47 	bl	80016c8 <lcdPutCh>
		x += 6;
 800183a:	78fb      	ldrb	r3, [r7, #3]
 800183c:	3306      	adds	r3, #6
 800183e:	70fb      	strb	r3, [r7, #3]
void lcdPutS(const char *string, uint8_t x, uint8_t y, uint16_t fgColour, uint16_t bgColour)
{
	uint8_t origin = x;
	uint8_t characterNumber;

	for (characterNumber = 0; characterNumber < strlen(string); characterNumber++)
 8001840:	7bfb      	ldrb	r3, [r7, #15]
 8001842:	3301      	adds	r3, #1
 8001844:	73fb      	strb	r3, [r7, #15]
 8001846:	7bfc      	ldrb	r4, [r7, #15]
 8001848:	6878      	ldr	r0, [r7, #4]
 800184a:	f7fe fc97 	bl	800017c <strlen>
 800184e:	4603      	mov	r3, r0
 8001850:	429c      	cmp	r4, r3
 8001852:	d3db      	bcc.n	800180c <lcdPutS+0x24>

		// Plot the current character
		lcdPutCh(string[characterNumber], x, y, fgColour, bgColour);
		x += 6;
	}
}
 8001854:	e000      	b.n	8001858 <lcdPutS+0x70>
			x = origin;
			y += 8;
		}

		// If we move past the bottom of the screen just exit
		if (y > 120) break;
 8001856:	bf00      	nop

		// Plot the current character
		lcdPutCh(string[characterNumber], x, y, fgColour, bgColour);
		x += 6;
	}
}
 8001858:	bf00      	nop
 800185a:	3714      	adds	r7, #20
 800185c:	46bd      	mov	sp, r7
 800185e:	bd90      	pop	{r4, r7, pc}

08001860 <main>:




int main(void)
{
 8001860:	b580      	push	{r7, lr}
 8001862:	af00      	add	r7, sp, #0

 init_game();
 8001864:	f000 fe54 	bl	8002510 <init_game>

  while (1){

  }
 8001868:	e7fe      	b.n	8001868 <main+0x8>
 800186a:	bf00      	nop

0800186c <get_adc_char>:
#include <unistd.h>
#include "spi_lcd.h"

char last = 'a';

char get_adc_char(){
 800186c:	b480      	push	{r7}
 800186e:	af00      	add	r7, sp, #0
	if (adc_value >1800 && adc_value < 2200){
 8001870:	4b21      	ldr	r3, [pc, #132]	; (80018f8 <get_adc_char+0x8c>)
 8001872:	881b      	ldrh	r3, [r3, #0]
 8001874:	f5b3 6fe1 	cmp.w	r3, #1800	; 0x708
 8001878:	d90a      	bls.n	8001890 <get_adc_char+0x24>
 800187a:	4b1f      	ldr	r3, [pc, #124]	; (80018f8 <get_adc_char+0x8c>)
 800187c:	881b      	ldrh	r3, [r3, #0]
 800187e:	f640 0297 	movw	r2, #2199	; 0x897
 8001882:	4293      	cmp	r3, r2
 8001884:	d804      	bhi.n	8001890 <get_adc_char+0x24>
		last = 'w';
 8001886:	4b1d      	ldr	r3, [pc, #116]	; (80018fc <get_adc_char+0x90>)
 8001888:	2277      	movs	r2, #119	; 0x77
 800188a:	701a      	strb	r2, [r3, #0]
		return 'w';
 800188c:	2377      	movs	r3, #119	; 0x77
 800188e:	e02e      	b.n	80018ee <get_adc_char+0x82>
	}
	else if(adc_value >850 && adc_value < 1200){
 8001890:	4b19      	ldr	r3, [pc, #100]	; (80018f8 <get_adc_char+0x8c>)
 8001892:	881b      	ldrh	r3, [r3, #0]
 8001894:	f240 3252 	movw	r2, #850	; 0x352
 8001898:	4293      	cmp	r3, r2
 800189a:	d909      	bls.n	80018b0 <get_adc_char+0x44>
 800189c:	4b16      	ldr	r3, [pc, #88]	; (80018f8 <get_adc_char+0x8c>)
 800189e:	881b      	ldrh	r3, [r3, #0]
 80018a0:	f5b3 6f96 	cmp.w	r3, #1200	; 0x4b0
 80018a4:	d204      	bcs.n	80018b0 <get_adc_char+0x44>
		last = 'd';
 80018a6:	4b15      	ldr	r3, [pc, #84]	; (80018fc <get_adc_char+0x90>)
 80018a8:	2264      	movs	r2, #100	; 0x64
 80018aa:	701a      	strb	r2, [r3, #0]
		return 'd';
 80018ac:	2364      	movs	r3, #100	; 0x64
 80018ae:	e01e      	b.n	80018ee <get_adc_char+0x82>
	}
	else if(adc_value >50 && adc_value < 400){
 80018b0:	4b11      	ldr	r3, [pc, #68]	; (80018f8 <get_adc_char+0x8c>)
 80018b2:	881b      	ldrh	r3, [r3, #0]
 80018b4:	2b32      	cmp	r3, #50	; 0x32
 80018b6:	d909      	bls.n	80018cc <get_adc_char+0x60>
 80018b8:	4b0f      	ldr	r3, [pc, #60]	; (80018f8 <get_adc_char+0x8c>)
 80018ba:	881b      	ldrh	r3, [r3, #0]
 80018bc:	f5b3 7fc8 	cmp.w	r3, #400	; 0x190
 80018c0:	d204      	bcs.n	80018cc <get_adc_char+0x60>
		last = 'a';
 80018c2:	4b0e      	ldr	r3, [pc, #56]	; (80018fc <get_adc_char+0x90>)
 80018c4:	2261      	movs	r2, #97	; 0x61
 80018c6:	701a      	strb	r2, [r3, #0]
		return 'a';
 80018c8:	2361      	movs	r3, #97	; 0x61
 80018ca:	e010      	b.n	80018ee <get_adc_char+0x82>
	}
	else if(adc_value >2400 && adc_value < 2800){
 80018cc:	4b0a      	ldr	r3, [pc, #40]	; (80018f8 <get_adc_char+0x8c>)
 80018ce:	881b      	ldrh	r3, [r3, #0]
 80018d0:	f5b3 6f16 	cmp.w	r3, #2400	; 0x960
 80018d4:	d909      	bls.n	80018ea <get_adc_char+0x7e>
 80018d6:	4b08      	ldr	r3, [pc, #32]	; (80018f8 <get_adc_char+0x8c>)
 80018d8:	881b      	ldrh	r3, [r3, #0]
 80018da:	f5b3 6f2f 	cmp.w	r3, #2800	; 0xaf0
 80018de:	d204      	bcs.n	80018ea <get_adc_char+0x7e>
		last = 's';
 80018e0:	4b06      	ldr	r3, [pc, #24]	; (80018fc <get_adc_char+0x90>)
 80018e2:	2273      	movs	r2, #115	; 0x73
 80018e4:	701a      	strb	r2, [r3, #0]
		return 's';
 80018e6:	2373      	movs	r3, #115	; 0x73
 80018e8:	e001      	b.n	80018ee <get_adc_char+0x82>
	}
	return last;
 80018ea:	4b04      	ldr	r3, [pc, #16]	; (80018fc <get_adc_char+0x90>)
 80018ec:	781b      	ldrb	r3, [r3, #0]
}
 80018ee:	4618      	mov	r0, r3
 80018f0:	46bd      	mov	sp, r7
 80018f2:	bc80      	pop	{r7}
 80018f4:	4770      	bx	lr
 80018f6:	bf00      	nop
 80018f8:	200000a0 	.word	0x200000a0
 80018fc:	20000002 	.word	0x20000002

08001900 <draw_hadik>:

void draw_hadik(){
 8001900:	b580      	push	{r7, lr}
 8001902:	b082      	sub	sp, #8
 8001904:	af02      	add	r7, sp, #8
	//H
	lcdCircle(5+DM1,20,2,31);
 8001906:	231f      	movs	r3, #31
 8001908:	2202      	movs	r2, #2
 800190a:	2114      	movs	r1, #20
 800190c:	2014      	movs	r0, #20
 800190e:	f7ff fe0f 	bl	8001530 <lcdCircle>
	lcdCircle(5+DM1,24,2,31);
 8001912:	231f      	movs	r3, #31
 8001914:	2202      	movs	r2, #2
 8001916:	2118      	movs	r1, #24
 8001918:	2014      	movs	r0, #20
 800191a:	f7ff fe09 	bl	8001530 <lcdCircle>
	lcdCircle(5+DM1,28,2,31);
 800191e:	231f      	movs	r3, #31
 8001920:	2202      	movs	r2, #2
 8001922:	211c      	movs	r1, #28
 8001924:	2014      	movs	r0, #20
 8001926:	f7ff fe03 	bl	8001530 <lcdCircle>
	lcdCircle(5+DM1,32,2,31);
 800192a:	231f      	movs	r3, #31
 800192c:	2202      	movs	r2, #2
 800192e:	2120      	movs	r1, #32
 8001930:	2014      	movs	r0, #20
 8001932:	f7ff fdfd 	bl	8001530 <lcdCircle>
	lcdCircle(5+DM1,36,2,31);
 8001936:	231f      	movs	r3, #31
 8001938:	2202      	movs	r2, #2
 800193a:	2124      	movs	r1, #36	; 0x24
 800193c:	2014      	movs	r0, #20
 800193e:	f7ff fdf7 	bl	8001530 <lcdCircle>
	lcdCircle(5+DM1,40,2,31);
 8001942:	231f      	movs	r3, #31
 8001944:	2202      	movs	r2, #2
 8001946:	2128      	movs	r1, #40	; 0x28
 8001948:	2014      	movs	r0, #20
 800194a:	f7ff fdf1 	bl	8001530 <lcdCircle>
	lcdCircle(5+DM1,44,2,31);
 800194e:	231f      	movs	r3, #31
 8001950:	2202      	movs	r2, #2
 8001952:	212c      	movs	r1, #44	; 0x2c
 8001954:	2014      	movs	r0, #20
 8001956:	f7ff fdeb 	bl	8001530 <lcdCircle>
	lcdCircle(9+DM1,32,2,31);
 800195a:	231f      	movs	r3, #31
 800195c:	2202      	movs	r2, #2
 800195e:	2120      	movs	r1, #32
 8001960:	2018      	movs	r0, #24
 8001962:	f7ff fde5 	bl	8001530 <lcdCircle>
	lcdCircle(11+DM1,32,2,31);
 8001966:	231f      	movs	r3, #31
 8001968:	2202      	movs	r2, #2
 800196a:	2120      	movs	r1, #32
 800196c:	201a      	movs	r0, #26
 800196e:	f7ff fddf 	bl	8001530 <lcdCircle>
	lcdCircle(13+DM1,32,2,31);
 8001972:	231f      	movs	r3, #31
 8001974:	2202      	movs	r2, #2
 8001976:	2120      	movs	r1, #32
 8001978:	201c      	movs	r0, #28
 800197a:	f7ff fdd9 	bl	8001530 <lcdCircle>
	lcdCircle(17+DM1,20,2,31);
 800197e:	231f      	movs	r3, #31
 8001980:	2202      	movs	r2, #2
 8001982:	2114      	movs	r1, #20
 8001984:	2020      	movs	r0, #32
 8001986:	f7ff fdd3 	bl	8001530 <lcdCircle>
	lcdCircle(17+DM1,24,2,31);
 800198a:	231f      	movs	r3, #31
 800198c:	2202      	movs	r2, #2
 800198e:	2118      	movs	r1, #24
 8001990:	2020      	movs	r0, #32
 8001992:	f7ff fdcd 	bl	8001530 <lcdCircle>
	lcdCircle(17+DM1,28,2,31);
 8001996:	231f      	movs	r3, #31
 8001998:	2202      	movs	r2, #2
 800199a:	211c      	movs	r1, #28
 800199c:	2020      	movs	r0, #32
 800199e:	f7ff fdc7 	bl	8001530 <lcdCircle>
	lcdCircle(17+DM1,32,2,31);
 80019a2:	231f      	movs	r3, #31
 80019a4:	2202      	movs	r2, #2
 80019a6:	2120      	movs	r1, #32
 80019a8:	2020      	movs	r0, #32
 80019aa:	f7ff fdc1 	bl	8001530 <lcdCircle>
	lcdCircle(17+DM1,36,2,31);
 80019ae:	231f      	movs	r3, #31
 80019b0:	2202      	movs	r2, #2
 80019b2:	2124      	movs	r1, #36	; 0x24
 80019b4:	2020      	movs	r0, #32
 80019b6:	f7ff fdbb 	bl	8001530 <lcdCircle>
	lcdCircle(17+DM1,40,2,31);
 80019ba:	231f      	movs	r3, #31
 80019bc:	2202      	movs	r2, #2
 80019be:	2128      	movs	r1, #40	; 0x28
 80019c0:	2020      	movs	r0, #32
 80019c2:	f7ff fdb5 	bl	8001530 <lcdCircle>
	lcdCircle(17+DM1,44,2,31);
 80019c6:	231f      	movs	r3, #31
 80019c8:	2202      	movs	r2, #2
 80019ca:	212c      	movs	r1, #44	; 0x2c
 80019cc:	2020      	movs	r0, #32
 80019ce:	f7ff fdaf 	bl	8001530 <lcdCircle>

	//A
	lcdCircle(25+DM1,44,2,31);
 80019d2:	231f      	movs	r3, #31
 80019d4:	2202      	movs	r2, #2
 80019d6:	212c      	movs	r1, #44	; 0x2c
 80019d8:	2028      	movs	r0, #40	; 0x28
 80019da:	f7ff fda9 	bl	8001530 <lcdCircle>
	lcdCircle(25+DM1,40,2,31);
 80019de:	231f      	movs	r3, #31
 80019e0:	2202      	movs	r2, #2
 80019e2:	2128      	movs	r1, #40	; 0x28
 80019e4:	2028      	movs	r0, #40	; 0x28
 80019e6:	f7ff fda3 	bl	8001530 <lcdCircle>
	lcdCircle(25+DM1,36,2,31);
 80019ea:	231f      	movs	r3, #31
 80019ec:	2202      	movs	r2, #2
 80019ee:	2124      	movs	r1, #36	; 0x24
 80019f0:	2028      	movs	r0, #40	; 0x28
 80019f2:	f7ff fd9d 	bl	8001530 <lcdCircle>
	lcdCircle(25+DM1,32,2,31);
 80019f6:	231f      	movs	r3, #31
 80019f8:	2202      	movs	r2, #2
 80019fa:	2120      	movs	r1, #32
 80019fc:	2028      	movs	r0, #40	; 0x28
 80019fe:	f7ff fd97 	bl	8001530 <lcdCircle>
	lcdCircle(29+DM1,32,2,31);
 8001a02:	231f      	movs	r3, #31
 8001a04:	2202      	movs	r2, #2
 8001a06:	2120      	movs	r1, #32
 8001a08:	202c      	movs	r0, #44	; 0x2c
 8001a0a:	f7ff fd91 	bl	8001530 <lcdCircle>
	lcdCircle(25+DM1,28,2,31);
 8001a0e:	231f      	movs	r3, #31
 8001a10:	2202      	movs	r2, #2
 8001a12:	211c      	movs	r1, #28
 8001a14:	2028      	movs	r0, #40	; 0x28
 8001a16:	f7ff fd8b 	bl	8001530 <lcdCircle>
	lcdCircle(25+DM1,24,2,31);
 8001a1a:	231f      	movs	r3, #31
 8001a1c:	2202      	movs	r2, #2
 8001a1e:	2118      	movs	r1, #24
 8001a20:	2028      	movs	r0, #40	; 0x28
 8001a22:	f7ff fd85 	bl	8001530 <lcdCircle>
	lcdCircle(25+DM1,20,2,31);
 8001a26:	231f      	movs	r3, #31
 8001a28:	2202      	movs	r2, #2
 8001a2a:	2114      	movs	r1, #20
 8001a2c:	2028      	movs	r0, #40	; 0x28
 8001a2e:	f7ff fd7f 	bl	8001530 <lcdCircle>
	lcdCircle(29+DM1,20,2,31);
 8001a32:	231f      	movs	r3, #31
 8001a34:	2202      	movs	r2, #2
 8001a36:	2114      	movs	r1, #20
 8001a38:	202c      	movs	r0, #44	; 0x2c
 8001a3a:	f7ff fd79 	bl	8001530 <lcdCircle>
	lcdCircle(31+DM1,20,2,31);
 8001a3e:	231f      	movs	r3, #31
 8001a40:	2202      	movs	r2, #2
 8001a42:	2114      	movs	r1, #20
 8001a44:	202e      	movs	r0, #46	; 0x2e
 8001a46:	f7ff fd73 	bl	8001530 <lcdCircle>
	lcdCircle(35+DM1,20,2,31);
 8001a4a:	231f      	movs	r3, #31
 8001a4c:	2202      	movs	r2, #2
 8001a4e:	2114      	movs	r1, #20
 8001a50:	2032      	movs	r0, #50	; 0x32
 8001a52:	f7ff fd6d 	bl	8001530 <lcdCircle>
	lcdCircle(35+DM1,44,2,31);
 8001a56:	231f      	movs	r3, #31
 8001a58:	2202      	movs	r2, #2
 8001a5a:	212c      	movs	r1, #44	; 0x2c
 8001a5c:	2032      	movs	r0, #50	; 0x32
 8001a5e:	f7ff fd67 	bl	8001530 <lcdCircle>
	lcdCircle(35+DM1,40,2,31);
 8001a62:	231f      	movs	r3, #31
 8001a64:	2202      	movs	r2, #2
 8001a66:	2128      	movs	r1, #40	; 0x28
 8001a68:	2032      	movs	r0, #50	; 0x32
 8001a6a:	f7ff fd61 	bl	8001530 <lcdCircle>
	lcdCircle(35+DM1,36,2,31);
 8001a6e:	231f      	movs	r3, #31
 8001a70:	2202      	movs	r2, #2
 8001a72:	2124      	movs	r1, #36	; 0x24
 8001a74:	2032      	movs	r0, #50	; 0x32
 8001a76:	f7ff fd5b 	bl	8001530 <lcdCircle>
	lcdCircle(35+DM1,32,2,31);
 8001a7a:	231f      	movs	r3, #31
 8001a7c:	2202      	movs	r2, #2
 8001a7e:	2120      	movs	r1, #32
 8001a80:	2032      	movs	r0, #50	; 0x32
 8001a82:	f7ff fd55 	bl	8001530 <lcdCircle>
	lcdCircle(35+DM1,28,2,31);
 8001a86:	231f      	movs	r3, #31
 8001a88:	2202      	movs	r2, #2
 8001a8a:	211c      	movs	r1, #28
 8001a8c:	2032      	movs	r0, #50	; 0x32
 8001a8e:	f7ff fd4f 	bl	8001530 <lcdCircle>
	lcdCircle(35+DM1,24,2,31);
 8001a92:	231f      	movs	r3, #31
 8001a94:	2202      	movs	r2, #2
 8001a96:	2118      	movs	r1, #24
 8001a98:	2032      	movs	r0, #50	; 0x32
 8001a9a:	f7ff fd49 	bl	8001530 <lcdCircle>

	//D
	lcdCircle(43+DM1,44,2,31);
 8001a9e:	231f      	movs	r3, #31
 8001aa0:	2202      	movs	r2, #2
 8001aa2:	212c      	movs	r1, #44	; 0x2c
 8001aa4:	203a      	movs	r0, #58	; 0x3a
 8001aa6:	f7ff fd43 	bl	8001530 <lcdCircle>
	lcdCircle(43+DM1,40,2,31);
 8001aaa:	231f      	movs	r3, #31
 8001aac:	2202      	movs	r2, #2
 8001aae:	2128      	movs	r1, #40	; 0x28
 8001ab0:	203a      	movs	r0, #58	; 0x3a
 8001ab2:	f7ff fd3d 	bl	8001530 <lcdCircle>
	lcdCircle(43+DM1,36,2,31);
 8001ab6:	231f      	movs	r3, #31
 8001ab8:	2202      	movs	r2, #2
 8001aba:	2124      	movs	r1, #36	; 0x24
 8001abc:	203a      	movs	r0, #58	; 0x3a
 8001abe:	f7ff fd37 	bl	8001530 <lcdCircle>
	lcdCircle(43+DM1,32,2,31);
 8001ac2:	231f      	movs	r3, #31
 8001ac4:	2202      	movs	r2, #2
 8001ac6:	2120      	movs	r1, #32
 8001ac8:	203a      	movs	r0, #58	; 0x3a
 8001aca:	f7ff fd31 	bl	8001530 <lcdCircle>
	lcdCircle(43+DM1,28,2,31);
 8001ace:	231f      	movs	r3, #31
 8001ad0:	2202      	movs	r2, #2
 8001ad2:	211c      	movs	r1, #28
 8001ad4:	203a      	movs	r0, #58	; 0x3a
 8001ad6:	f7ff fd2b 	bl	8001530 <lcdCircle>
	lcdCircle(43+DM1,24,2,31);
 8001ada:	231f      	movs	r3, #31
 8001adc:	2202      	movs	r2, #2
 8001ade:	2118      	movs	r1, #24
 8001ae0:	203a      	movs	r0, #58	; 0x3a
 8001ae2:	f7ff fd25 	bl	8001530 <lcdCircle>
	lcdCircle(43+DM1,20,2,31);
 8001ae6:	231f      	movs	r3, #31
 8001ae8:	2202      	movs	r2, #2
 8001aea:	2114      	movs	r1, #20
 8001aec:	203a      	movs	r0, #58	; 0x3a
 8001aee:	f7ff fd1f 	bl	8001530 <lcdCircle>
	lcdCircle(47+DM1,20,2,31);
 8001af2:	231f      	movs	r3, #31
 8001af4:	2202      	movs	r2, #2
 8001af6:	2114      	movs	r1, #20
 8001af8:	203e      	movs	r0, #62	; 0x3e
 8001afa:	f7ff fd19 	bl	8001530 <lcdCircle>
	lcdCircle(51+DM1,24,2,31);
 8001afe:	231f      	movs	r3, #31
 8001b00:	2202      	movs	r2, #2
 8001b02:	2118      	movs	r1, #24
 8001b04:	2042      	movs	r0, #66	; 0x42
 8001b06:	f7ff fd13 	bl	8001530 <lcdCircle>
	lcdCircle(47+DM1,44,2,31);
 8001b0a:	231f      	movs	r3, #31
 8001b0c:	2202      	movs	r2, #2
 8001b0e:	212c      	movs	r1, #44	; 0x2c
 8001b10:	203e      	movs	r0, #62	; 0x3e
 8001b12:	f7ff fd0d 	bl	8001530 <lcdCircle>
	lcdCircle(51+DM1,40,2,31);
 8001b16:	231f      	movs	r3, #31
 8001b18:	2202      	movs	r2, #2
 8001b1a:	2128      	movs	r1, #40	; 0x28
 8001b1c:	2042      	movs	r0, #66	; 0x42
 8001b1e:	f7ff fd07 	bl	8001530 <lcdCircle>
	lcdCircle(55+DM1,36,2,31);
 8001b22:	231f      	movs	r3, #31
 8001b24:	2202      	movs	r2, #2
 8001b26:	2124      	movs	r1, #36	; 0x24
 8001b28:	2046      	movs	r0, #70	; 0x46
 8001b2a:	f7ff fd01 	bl	8001530 <lcdCircle>
	lcdCircle(55+DM1,32,2,31);
 8001b2e:	231f      	movs	r3, #31
 8001b30:	2202      	movs	r2, #2
 8001b32:	2120      	movs	r1, #32
 8001b34:	2046      	movs	r0, #70	; 0x46
 8001b36:	f7ff fcfb 	bl	8001530 <lcdCircle>
	lcdCircle(55+DM1,28,2,31);
 8001b3a:	231f      	movs	r3, #31
 8001b3c:	2202      	movs	r2, #2
 8001b3e:	211c      	movs	r1, #28
 8001b40:	2046      	movs	r0, #70	; 0x46
 8001b42:	f7ff fcf5 	bl	8001530 <lcdCircle>

	//I
	lcdCircle(63+DM1,44,2,31);
 8001b46:	231f      	movs	r3, #31
 8001b48:	2202      	movs	r2, #2
 8001b4a:	212c      	movs	r1, #44	; 0x2c
 8001b4c:	204e      	movs	r0, #78	; 0x4e
 8001b4e:	f7ff fcef 	bl	8001530 <lcdCircle>
	lcdCircle(63+DM1,40,2,31);
 8001b52:	231f      	movs	r3, #31
 8001b54:	2202      	movs	r2, #2
 8001b56:	2128      	movs	r1, #40	; 0x28
 8001b58:	204e      	movs	r0, #78	; 0x4e
 8001b5a:	f7ff fce9 	bl	8001530 <lcdCircle>
	lcdCircle(63+DM1,36,2,31);
 8001b5e:	231f      	movs	r3, #31
 8001b60:	2202      	movs	r2, #2
 8001b62:	2124      	movs	r1, #36	; 0x24
 8001b64:	204e      	movs	r0, #78	; 0x4e
 8001b66:	f7ff fce3 	bl	8001530 <lcdCircle>
	lcdCircle(63+DM1,32,2,31);
 8001b6a:	231f      	movs	r3, #31
 8001b6c:	2202      	movs	r2, #2
 8001b6e:	2120      	movs	r1, #32
 8001b70:	204e      	movs	r0, #78	; 0x4e
 8001b72:	f7ff fcdd 	bl	8001530 <lcdCircle>
	lcdCircle(63+DM1,28,2,31);
 8001b76:	231f      	movs	r3, #31
 8001b78:	2202      	movs	r2, #2
 8001b7a:	211c      	movs	r1, #28
 8001b7c:	204e      	movs	r0, #78	; 0x4e
 8001b7e:	f7ff fcd7 	bl	8001530 <lcdCircle>
	lcdCircle(63+DM1,24,2,31);
 8001b82:	231f      	movs	r3, #31
 8001b84:	2202      	movs	r2, #2
 8001b86:	2118      	movs	r1, #24
 8001b88:	204e      	movs	r0, #78	; 0x4e
 8001b8a:	f7ff fcd1 	bl	8001530 <lcdCircle>
	lcdCircle(63+DM1,20,2,31);
 8001b8e:	231f      	movs	r3, #31
 8001b90:	2202      	movs	r2, #2
 8001b92:	2114      	movs	r1, #20
 8001b94:	204e      	movs	r0, #78	; 0x4e
 8001b96:	f7ff fccb 	bl	8001530 <lcdCircle>

	//K
	lcdCircle(71+DM1,44,2,31);
 8001b9a:	231f      	movs	r3, #31
 8001b9c:	2202      	movs	r2, #2
 8001b9e:	212c      	movs	r1, #44	; 0x2c
 8001ba0:	2056      	movs	r0, #86	; 0x56
 8001ba2:	f7ff fcc5 	bl	8001530 <lcdCircle>
	lcdCircle(71+DM1,40,2,31);
 8001ba6:	231f      	movs	r3, #31
 8001ba8:	2202      	movs	r2, #2
 8001baa:	2128      	movs	r1, #40	; 0x28
 8001bac:	2056      	movs	r0, #86	; 0x56
 8001bae:	f7ff fcbf 	bl	8001530 <lcdCircle>
	lcdCircle(71+DM1,36,2,31);
 8001bb2:	231f      	movs	r3, #31
 8001bb4:	2202      	movs	r2, #2
 8001bb6:	2124      	movs	r1, #36	; 0x24
 8001bb8:	2056      	movs	r0, #86	; 0x56
 8001bba:	f7ff fcb9 	bl	8001530 <lcdCircle>
	lcdCircle(71+DM1,32,2,31);
 8001bbe:	231f      	movs	r3, #31
 8001bc0:	2202      	movs	r2, #2
 8001bc2:	2120      	movs	r1, #32
 8001bc4:	2056      	movs	r0, #86	; 0x56
 8001bc6:	f7ff fcb3 	bl	8001530 <lcdCircle>
	lcdCircle(71+DM1,28,2,31);
 8001bca:	231f      	movs	r3, #31
 8001bcc:	2202      	movs	r2, #2
 8001bce:	211c      	movs	r1, #28
 8001bd0:	2056      	movs	r0, #86	; 0x56
 8001bd2:	f7ff fcad 	bl	8001530 <lcdCircle>
	lcdCircle(71+DM1,24,2,31);
 8001bd6:	231f      	movs	r3, #31
 8001bd8:	2202      	movs	r2, #2
 8001bda:	2118      	movs	r1, #24
 8001bdc:	2056      	movs	r0, #86	; 0x56
 8001bde:	f7ff fca7 	bl	8001530 <lcdCircle>
	lcdCircle(71+DM1,20,2,31);
 8001be2:	231f      	movs	r3, #31
 8001be4:	2202      	movs	r2, #2
 8001be6:	2114      	movs	r1, #20
 8001be8:	2056      	movs	r0, #86	; 0x56
 8001bea:	f7ff fca1 	bl	8001530 <lcdCircle>

	lcdCircle(75+DM1,32,2,31);
 8001bee:	231f      	movs	r3, #31
 8001bf0:	2202      	movs	r2, #2
 8001bf2:	2120      	movs	r1, #32
 8001bf4:	205a      	movs	r0, #90	; 0x5a
 8001bf6:	f7ff fc9b 	bl	8001530 <lcdCircle>

	lcdCircle(79+DM1,36,2,31);
 8001bfa:	231f      	movs	r3, #31
 8001bfc:	2202      	movs	r2, #2
 8001bfe:	2124      	movs	r1, #36	; 0x24
 8001c00:	205e      	movs	r0, #94	; 0x5e
 8001c02:	f7ff fc95 	bl	8001530 <lcdCircle>
	lcdCircle(83+DM1,40,2,31);
 8001c06:	231f      	movs	r3, #31
 8001c08:	2202      	movs	r2, #2
 8001c0a:	2128      	movs	r1, #40	; 0x28
 8001c0c:	2062      	movs	r0, #98	; 0x62
 8001c0e:	f7ff fc8f 	bl	8001530 <lcdCircle>
	lcdCircle(87+DM1,44,2,31);
 8001c12:	231f      	movs	r3, #31
 8001c14:	2202      	movs	r2, #2
 8001c16:	212c      	movs	r1, #44	; 0x2c
 8001c18:	2066      	movs	r0, #102	; 0x66
 8001c1a:	f7ff fc89 	bl	8001530 <lcdCircle>

	lcdCircle(87+DM1,20,2,31);
 8001c1e:	231f      	movs	r3, #31
 8001c20:	2202      	movs	r2, #2
 8001c22:	2114      	movs	r1, #20
 8001c24:	2066      	movs	r0, #102	; 0x66
 8001c26:	f7ff fc83 	bl	8001530 <lcdCircle>
	lcdCircle(83+DM1,24,2,31);
 8001c2a:	231f      	movs	r3, #31
 8001c2c:	2202      	movs	r2, #2
 8001c2e:	2118      	movs	r1, #24
 8001c30:	2062      	movs	r0, #98	; 0x62
 8001c32:	f7ff fc7d 	bl	8001530 <lcdCircle>
	lcdCircle(79+DM1,28,2,31);
 8001c36:	231f      	movs	r3, #31
 8001c38:	2202      	movs	r2, #2
 8001c3a:	211c      	movs	r1, #28
 8001c3c:	205e      	movs	r0, #94	; 0x5e
 8001c3e:	f7ff fc77 	bl	8001530 <lcdCircle>


	 lcdPutS("Pre hranie",40,70,0xFFFF, 0);
 8001c42:	2300      	movs	r3, #0
 8001c44:	9300      	str	r3, [sp, #0]
 8001c46:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8001c4a:	2246      	movs	r2, #70	; 0x46
 8001c4c:	2128      	movs	r1, #40	; 0x28
 8001c4e:	4807      	ldr	r0, [pc, #28]	; (8001c6c <draw_hadik+0x36c>)
 8001c50:	f7ff fdca 	bl	80017e8 <lcdPutS>
	 lcdPutS("Stlac modry button  ",10,80,0xFFFF, 0);
 8001c54:	2300      	movs	r3, #0
 8001c56:	9300      	str	r3, [sp, #0]
 8001c58:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8001c5c:	2250      	movs	r2, #80	; 0x50
 8001c5e:	210a      	movs	r1, #10
 8001c60:	4803      	ldr	r0, [pc, #12]	; (8001c70 <draw_hadik+0x370>)
 8001c62:	f7ff fdc1 	bl	80017e8 <lcdPutS>

}
 8001c66:	bf00      	nop
 8001c68:	46bd      	mov	sp, r7
 8001c6a:	bd80      	pop	{r7, pc}
 8001c6c:	08002cb4 	.word	0x08002cb4
 8001c70:	08002cc0 	.word	0x08002cc0

08001c74 <Delays>:

void Delays()
{
 8001c74:	b480      	push	{r7}
 8001c76:	b083      	sub	sp, #12
 8001c78:	af00      	add	r7, sp, #0
	int c = 1, d = 1;
 8001c7a:	2301      	movs	r3, #1
 8001c7c:	607b      	str	r3, [r7, #4]
 8001c7e:	2301      	movs	r3, #1
 8001c80:	603b      	str	r3, [r7, #0]

	   for ( c = 1 ; c <= 500 ; c++ )
 8001c82:	2301      	movs	r3, #1
 8001c84:	607b      	str	r3, [r7, #4]
 8001c86:	e00c      	b.n	8001ca2 <Delays+0x2e>
	       for ( d = 1 ; d <= 500 ; d++ )
 8001c88:	2301      	movs	r3, #1
 8001c8a:	603b      	str	r3, [r7, #0]
 8001c8c:	e002      	b.n	8001c94 <Delays+0x20>
 8001c8e:	683b      	ldr	r3, [r7, #0]
 8001c90:	3301      	adds	r3, #1
 8001c92:	603b      	str	r3, [r7, #0]
 8001c94:	683b      	ldr	r3, [r7, #0]
 8001c96:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
 8001c9a:	ddf8      	ble.n	8001c8e <Delays+0x1a>

void Delays()
{
	int c = 1, d = 1;

	   for ( c = 1 ; c <= 500 ; c++ )
 8001c9c:	687b      	ldr	r3, [r7, #4]
 8001c9e:	3301      	adds	r3, #1
 8001ca0:	607b      	str	r3, [r7, #4]
 8001ca2:	687b      	ldr	r3, [r7, #4]
 8001ca4:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
 8001ca8:	ddee      	ble.n	8001c88 <Delays+0x14>
	       for ( d = 1 ; d <= 500 ; d++ )
	       {}


}
 8001caa:	bf00      	nop
 8001cac:	370c      	adds	r7, #12
 8001cae:	46bd      	mov	sp, r7
 8001cb0:	bc80      	pop	{r7}
 8001cb2:	4770      	bx	lr

08001cb4 <Delays1>:

void Delays1()
{
 8001cb4:	b480      	push	{r7}
 8001cb6:	b083      	sub	sp, #12
 8001cb8:	af00      	add	r7, sp, #0
	int c = 1, d = 1;
 8001cba:	2301      	movs	r3, #1
 8001cbc:	607b      	str	r3, [r7, #4]
 8001cbe:	2301      	movs	r3, #1
 8001cc0:	603b      	str	r3, [r7, #0]

	   for ( c = 1 ; c <= 1500 ; c++ )
 8001cc2:	2301      	movs	r3, #1
 8001cc4:	607b      	str	r3, [r7, #4]
 8001cc6:	e00d      	b.n	8001ce4 <Delays1+0x30>
	       for ( d = 1 ; d <= 1500 ; d++ )
 8001cc8:	2301      	movs	r3, #1
 8001cca:	603b      	str	r3, [r7, #0]
 8001ccc:	e002      	b.n	8001cd4 <Delays1+0x20>
 8001cce:	683b      	ldr	r3, [r7, #0]
 8001cd0:	3301      	adds	r3, #1
 8001cd2:	603b      	str	r3, [r7, #0]
 8001cd4:	683b      	ldr	r3, [r7, #0]
 8001cd6:	f240 52dc 	movw	r2, #1500	; 0x5dc
 8001cda:	4293      	cmp	r3, r2
 8001cdc:	ddf7      	ble.n	8001cce <Delays1+0x1a>

void Delays1()
{
	int c = 1, d = 1;

	   for ( c = 1 ; c <= 1500 ; c++ )
 8001cde:	687b      	ldr	r3, [r7, #4]
 8001ce0:	3301      	adds	r3, #1
 8001ce2:	607b      	str	r3, [r7, #4]
 8001ce4:	687b      	ldr	r3, [r7, #4]
 8001ce6:	f240 52dc 	movw	r2, #1500	; 0x5dc
 8001cea:	4293      	cmp	r3, r2
 8001cec:	ddec      	ble.n	8001cc8 <Delays1+0x14>
	       for ( d = 1 ; d <= 1500 ; d++ )
	       {}


}
 8001cee:	bf00      	nop
 8001cf0:	370c      	adds	r7, #12
 8001cf2:	46bd      	mov	sp, r7
 8001cf4:	bc80      	pop	{r7}
 8001cf6:	4770      	bx	lr

08001cf8 <initWorld>:
void initWorld(char map[SIZE_OF_WORLD][SIZE_OF_WORLD]) {
 8001cf8:	b580      	push	{r7, lr}
 8001cfa:	b084      	sub	sp, #16
 8001cfc:	af00      	add	r7, sp, #0
 8001cfe:	6078      	str	r0, [r7, #4]
Funkcia initWorld memsetne celu maticu na medzery, nasledne ju preiteruje a nastavi
okraje matice na X, teda spravime si ohradu
*/
    int row, col;

    memset(map, ' ',NUMBER_OF_ELEMENTS);
 8001d00:	22a9      	movs	r2, #169	; 0xa9
 8001d02:	2120      	movs	r1, #32
 8001d04:	6878      	ldr	r0, [r7, #4]
 8001d06:	f000 ff09 	bl	8002b1c <memset>

    for (row=0; row < SIZE_OF_WORLD; row++) {
 8001d0a:	2300      	movs	r3, #0
 8001d0c:	60fb      	str	r3, [r7, #12]
 8001d0e:	e02f      	b.n	8001d70 <initWorld+0x78>
        for(col = 0; col < SIZE_OF_WORLD; col++) {
 8001d10:	2300      	movs	r3, #0
 8001d12:	60bb      	str	r3, [r7, #8]
 8001d14:	e026      	b.n	8001d64 <initWorld+0x6c>
            if(col == 0 || col == SIZE_OF_WORLD-1) {
 8001d16:	68bb      	ldr	r3, [r7, #8]
 8001d18:	2b00      	cmp	r3, #0
 8001d1a:	d002      	beq.n	8001d22 <initWorld+0x2a>
 8001d1c:	68bb      	ldr	r3, [r7, #8]
 8001d1e:	2b0c      	cmp	r3, #12
 8001d20:	d10b      	bne.n	8001d3a <initWorld+0x42>
                map[row][col] = 'X';
 8001d22:	68fa      	ldr	r2, [r7, #12]
 8001d24:	4613      	mov	r3, r2
 8001d26:	005b      	lsls	r3, r3, #1
 8001d28:	4413      	add	r3, r2
 8001d2a:	009b      	lsls	r3, r3, #2
 8001d2c:	4413      	add	r3, r2
 8001d2e:	687a      	ldr	r2, [r7, #4]
 8001d30:	441a      	add	r2, r3
 8001d32:	68bb      	ldr	r3, [r7, #8]
 8001d34:	4413      	add	r3, r2
 8001d36:	2258      	movs	r2, #88	; 0x58
 8001d38:	701a      	strb	r2, [r3, #0]
            }
            if(row == 0 || row == SIZE_OF_WORLD-1){
 8001d3a:	68fb      	ldr	r3, [r7, #12]
 8001d3c:	2b00      	cmp	r3, #0
 8001d3e:	d002      	beq.n	8001d46 <initWorld+0x4e>
 8001d40:	68fb      	ldr	r3, [r7, #12]
 8001d42:	2b0c      	cmp	r3, #12
 8001d44:	d10b      	bne.n	8001d5e <initWorld+0x66>
                map[row][col] = 'X';
 8001d46:	68fa      	ldr	r2, [r7, #12]
 8001d48:	4613      	mov	r3, r2
 8001d4a:	005b      	lsls	r3, r3, #1
 8001d4c:	4413      	add	r3, r2
 8001d4e:	009b      	lsls	r3, r3, #2
 8001d50:	4413      	add	r3, r2
 8001d52:	687a      	ldr	r2, [r7, #4]
 8001d54:	441a      	add	r2, r3
 8001d56:	68bb      	ldr	r3, [r7, #8]
 8001d58:	4413      	add	r3, r2
 8001d5a:	2258      	movs	r2, #88	; 0x58
 8001d5c:	701a      	strb	r2, [r3, #0]
    int row, col;

    memset(map, ' ',NUMBER_OF_ELEMENTS);

    for (row=0; row < SIZE_OF_WORLD; row++) {
        for(col = 0; col < SIZE_OF_WORLD; col++) {
 8001d5e:	68bb      	ldr	r3, [r7, #8]
 8001d60:	3301      	adds	r3, #1
 8001d62:	60bb      	str	r3, [r7, #8]
 8001d64:	68bb      	ldr	r3, [r7, #8]
 8001d66:	2b0c      	cmp	r3, #12
 8001d68:	ddd5      	ble.n	8001d16 <initWorld+0x1e>
*/
    int row, col;

    memset(map, ' ',NUMBER_OF_ELEMENTS);

    for (row=0; row < SIZE_OF_WORLD; row++) {
 8001d6a:	68fb      	ldr	r3, [r7, #12]
 8001d6c:	3301      	adds	r3, #1
 8001d6e:	60fb      	str	r3, [r7, #12]
 8001d70:	68fb      	ldr	r3, [r7, #12]
 8001d72:	2b0c      	cmp	r3, #12
 8001d74:	ddcc      	ble.n	8001d10 <initWorld+0x18>
            if(row == 0 || row == SIZE_OF_WORLD-1){
                map[row][col] = 'X';
            }
        }
    }
}
 8001d76:	bf00      	nop
 8001d78:	3710      	adds	r7, #16
 8001d7a:	46bd      	mov	sp, r7
 8001d7c:	bd80      	pop	{r7, pc}
 8001d7e:	bf00      	nop

08001d80 <printWorld>:

void printWorld(char map[SIZE_OF_WORLD][SIZE_OF_WORLD]) {
 8001d80:	b580      	push	{r7, lr}
 8001d82:	b086      	sub	sp, #24
 8001d84:	af02      	add	r7, sp, #8
 8001d86:	6078      	str	r0, [r7, #4]
Vyprinti aktualny stav matice
*/

    int row, col;

    for (row=0; row < SIZE_OF_WORLD; row++) {
 8001d88:	2300      	movs	r3, #0
 8001d8a:	60fb      	str	r3, [r7, #12]
 8001d8c:	e029      	b.n	8001de2 <printWorld+0x62>
        for(col = 0; col < SIZE_OF_WORLD; col++) {
 8001d8e:	2300      	movs	r3, #0
 8001d90:	60bb      	str	r3, [r7, #8]
 8001d92:	e020      	b.n	8001dd6 <printWorld+0x56>
             //printf("%c", map[row][col]);
        	lcdPutCh(map[row][col], col*DM, row*DM, 31, 0);
 8001d94:	68fa      	ldr	r2, [r7, #12]
 8001d96:	4613      	mov	r3, r2
 8001d98:	005b      	lsls	r3, r3, #1
 8001d9a:	4413      	add	r3, r2
 8001d9c:	009b      	lsls	r3, r3, #2
 8001d9e:	4413      	add	r3, r2
 8001da0:	687a      	ldr	r2, [r7, #4]
 8001da2:	441a      	add	r2, r3
 8001da4:	68bb      	ldr	r3, [r7, #8]
 8001da6:	4413      	add	r3, r2
 8001da8:	7818      	ldrb	r0, [r3, #0]
 8001daa:	68bb      	ldr	r3, [r7, #8]
 8001dac:	b2db      	uxtb	r3, r3
 8001dae:	461a      	mov	r2, r3
 8001db0:	0092      	lsls	r2, r2, #2
 8001db2:	4413      	add	r3, r2
 8001db4:	005b      	lsls	r3, r3, #1
 8001db6:	b2d9      	uxtb	r1, r3
 8001db8:	68fb      	ldr	r3, [r7, #12]
 8001dba:	b2db      	uxtb	r3, r3
 8001dbc:	461a      	mov	r2, r3
 8001dbe:	0092      	lsls	r2, r2, #2
 8001dc0:	4413      	add	r3, r2
 8001dc2:	005b      	lsls	r3, r3, #1
 8001dc4:	b2da      	uxtb	r2, r3
 8001dc6:	2300      	movs	r3, #0
 8001dc8:	9300      	str	r3, [sp, #0]
 8001dca:	231f      	movs	r3, #31
 8001dcc:	f7ff fc7c 	bl	80016c8 <lcdPutCh>
*/

    int row, col;

    for (row=0; row < SIZE_OF_WORLD; row++) {
        for(col = 0; col < SIZE_OF_WORLD; col++) {
 8001dd0:	68bb      	ldr	r3, [r7, #8]
 8001dd2:	3301      	adds	r3, #1
 8001dd4:	60bb      	str	r3, [r7, #8]
 8001dd6:	68bb      	ldr	r3, [r7, #8]
 8001dd8:	2b0c      	cmp	r3, #12
 8001dda:	dddb      	ble.n	8001d94 <printWorld+0x14>
Vyprinti aktualny stav matice
*/

    int row, col;

    for (row=0; row < SIZE_OF_WORLD; row++) {
 8001ddc:	68fb      	ldr	r3, [r7, #12]
 8001dde:	3301      	adds	r3, #1
 8001de0:	60fb      	str	r3, [r7, #12]
 8001de2:	68fb      	ldr	r3, [r7, #12]
 8001de4:	2b0c      	cmp	r3, #12
 8001de6:	ddd2      	ble.n	8001d8e <printWorld+0xe>
        }

        //printf("\n");
    }

}
 8001de8:	bf00      	nop
 8001dea:	3710      	adds	r7, #16
 8001dec:	46bd      	mov	sp, r7
 8001dee:	bd80      	pop	{r7, pc}

08001df0 <spawnFood>:


void spawnFood(char map[SIZE_OF_WORLD][SIZE_OF_WORLD]) {
 8001df0:	b580      	push	{r7, lr}
 8001df2:	b084      	sub	sp, #16
 8001df4:	af00      	add	r7, sp, #0
 8001df6:	6078      	str	r0, [r7, #4]
*/
    //srand(time(NULL));
    int x,y;

    do {
        x = rand() % SIZE_OF_WORLD;
 8001df8:	f000 fef6 	bl	8002be8 <rand>
 8001dfc:	4602      	mov	r2, r0
 8001dfe:	4b1d      	ldr	r3, [pc, #116]	; (8001e74 <spawnFood+0x84>)
 8001e00:	fb83 1302 	smull	r1, r3, r3, r2
 8001e04:	1099      	asrs	r1, r3, #2
 8001e06:	17d3      	asrs	r3, r2, #31
 8001e08:	1ac9      	subs	r1, r1, r3
 8001e0a:	460b      	mov	r3, r1
 8001e0c:	005b      	lsls	r3, r3, #1
 8001e0e:	440b      	add	r3, r1
 8001e10:	009b      	lsls	r3, r3, #2
 8001e12:	440b      	add	r3, r1
 8001e14:	1ad3      	subs	r3, r2, r3
 8001e16:	60fb      	str	r3, [r7, #12]
        y = rand() % SIZE_OF_WORLD;
 8001e18:	f000 fee6 	bl	8002be8 <rand>
 8001e1c:	4602      	mov	r2, r0
 8001e1e:	4b15      	ldr	r3, [pc, #84]	; (8001e74 <spawnFood+0x84>)
 8001e20:	fb83 1302 	smull	r1, r3, r3, r2
 8001e24:	1099      	asrs	r1, r3, #2
 8001e26:	17d3      	asrs	r3, r2, #31
 8001e28:	1ac9      	subs	r1, r1, r3
 8001e2a:	460b      	mov	r3, r1
 8001e2c:	005b      	lsls	r3, r3, #1
 8001e2e:	440b      	add	r3, r1
 8001e30:	009b      	lsls	r3, r3, #2
 8001e32:	440b      	add	r3, r1
 8001e34:	1ad3      	subs	r3, r2, r3
 8001e36:	60bb      	str	r3, [r7, #8]
    } while (map[x][y] != ' ');
 8001e38:	68fa      	ldr	r2, [r7, #12]
 8001e3a:	4613      	mov	r3, r2
 8001e3c:	005b      	lsls	r3, r3, #1
 8001e3e:	4413      	add	r3, r2
 8001e40:	009b      	lsls	r3, r3, #2
 8001e42:	4413      	add	r3, r2
 8001e44:	687a      	ldr	r2, [r7, #4]
 8001e46:	441a      	add	r2, r3
 8001e48:	68bb      	ldr	r3, [r7, #8]
 8001e4a:	4413      	add	r3, r2
 8001e4c:	781b      	ldrb	r3, [r3, #0]
 8001e4e:	2b20      	cmp	r3, #32
 8001e50:	d1d2      	bne.n	8001df8 <spawnFood+0x8>

    map[x][y] = '@';
 8001e52:	68fa      	ldr	r2, [r7, #12]
 8001e54:	4613      	mov	r3, r2
 8001e56:	005b      	lsls	r3, r3, #1
 8001e58:	4413      	add	r3, r2
 8001e5a:	009b      	lsls	r3, r3, #2
 8001e5c:	4413      	add	r3, r2
 8001e5e:	687a      	ldr	r2, [r7, #4]
 8001e60:	441a      	add	r2, r3
 8001e62:	68bb      	ldr	r3, [r7, #8]
 8001e64:	4413      	add	r3, r2
 8001e66:	2240      	movs	r2, #64	; 0x40
 8001e68:	701a      	strb	r2, [r3, #0]
}
 8001e6a:	bf00      	nop
 8001e6c:	3710      	adds	r7, #16
 8001e6e:	46bd      	mov	sp, r7
 8001e70:	bd80      	pop	{r7, pc}
 8001e72:	bf00      	nop
 8001e74:	4ec4ec4f 	.word	0x4ec4ec4f

08001e78 <spawnRock>:

void spawnRock(char map[SIZE_OF_WORLD][SIZE_OF_WORLD]) {
 8001e78:	b580      	push	{r7, lr}
 8001e7a:	b084      	sub	sp, #16
 8001e7c:	af00      	add	r7, sp, #0
 8001e7e:	6078      	str	r0, [r7, #4]

    //srand(time(NULL));
    int x,y;

    do {
        x = rand() % SIZE_OF_WORLD;
 8001e80:	f000 feb2 	bl	8002be8 <rand>
 8001e84:	4602      	mov	r2, r0
 8001e86:	4b1d      	ldr	r3, [pc, #116]	; (8001efc <spawnRock+0x84>)
 8001e88:	fb83 1302 	smull	r1, r3, r3, r2
 8001e8c:	1099      	asrs	r1, r3, #2
 8001e8e:	17d3      	asrs	r3, r2, #31
 8001e90:	1ac9      	subs	r1, r1, r3
 8001e92:	460b      	mov	r3, r1
 8001e94:	005b      	lsls	r3, r3, #1
 8001e96:	440b      	add	r3, r1
 8001e98:	009b      	lsls	r3, r3, #2
 8001e9a:	440b      	add	r3, r1
 8001e9c:	1ad3      	subs	r3, r2, r3
 8001e9e:	60fb      	str	r3, [r7, #12]
        y = rand() % SIZE_OF_WORLD;
 8001ea0:	f000 fea2 	bl	8002be8 <rand>
 8001ea4:	4602      	mov	r2, r0
 8001ea6:	4b15      	ldr	r3, [pc, #84]	; (8001efc <spawnRock+0x84>)
 8001ea8:	fb83 1302 	smull	r1, r3, r3, r2
 8001eac:	1099      	asrs	r1, r3, #2
 8001eae:	17d3      	asrs	r3, r2, #31
 8001eb0:	1ac9      	subs	r1, r1, r3
 8001eb2:	460b      	mov	r3, r1
 8001eb4:	005b      	lsls	r3, r3, #1
 8001eb6:	440b      	add	r3, r1
 8001eb8:	009b      	lsls	r3, r3, #2
 8001eba:	440b      	add	r3, r1
 8001ebc:	1ad3      	subs	r3, r2, r3
 8001ebe:	60bb      	str	r3, [r7, #8]
    } while (map[x][y] != ' ');
 8001ec0:	68fa      	ldr	r2, [r7, #12]
 8001ec2:	4613      	mov	r3, r2
 8001ec4:	005b      	lsls	r3, r3, #1
 8001ec6:	4413      	add	r3, r2
 8001ec8:	009b      	lsls	r3, r3, #2
 8001eca:	4413      	add	r3, r2
 8001ecc:	687a      	ldr	r2, [r7, #4]
 8001ece:	441a      	add	r2, r3
 8001ed0:	68bb      	ldr	r3, [r7, #8]
 8001ed2:	4413      	add	r3, r2
 8001ed4:	781b      	ldrb	r3, [r3, #0]
 8001ed6:	2b20      	cmp	r3, #32
 8001ed8:	d1d2      	bne.n	8001e80 <spawnRock+0x8>

    map[x][y] = 'X';
 8001eda:	68fa      	ldr	r2, [r7, #12]
 8001edc:	4613      	mov	r3, r2
 8001ede:	005b      	lsls	r3, r3, #1
 8001ee0:	4413      	add	r3, r2
 8001ee2:	009b      	lsls	r3, r3, #2
 8001ee4:	4413      	add	r3, r2
 8001ee6:	687a      	ldr	r2, [r7, #4]
 8001ee8:	441a      	add	r2, r3
 8001eea:	68bb      	ldr	r3, [r7, #8]
 8001eec:	4413      	add	r3, r2
 8001eee:	2258      	movs	r2, #88	; 0x58
 8001ef0:	701a      	strb	r2, [r3, #0]
}
 8001ef2:	bf00      	nop
 8001ef4:	3710      	adds	r7, #16
 8001ef6:	46bd      	mov	sp, r7
 8001ef8:	bd80      	pop	{r7, pc}
 8001efa:	bf00      	nop
 8001efc:	4ec4ec4f 	.word	0x4ec4ec4f

08001f00 <initSnake>:

void initSnake(char map[SIZE_OF_WORLD][SIZE_OF_WORLD], Snake snake[SIZE_OF_SNAKE]) {
 8001f00:	b480      	push	{r7}
 8001f02:	b085      	sub	sp, #20
 8001f04:	af00      	add	r7, sp, #0
 8001f06:	6078      	str	r0, [r7, #4]
 8001f08:	6039      	str	r1, [r7, #0]
Funkcia vytvori "hlavu" hada, vsetky ostatne struktury v poli nastavi na nula. Hlavu hada
umiestni do stredu mapy
*/
    int i;

    snake[0].isUsed = 1;
 8001f0a:	683b      	ldr	r3, [r7, #0]
 8001f0c:	2201      	movs	r2, #1
 8001f0e:	609a      	str	r2, [r3, #8]
    snake[0].x = (int)floor(SIZE_OF_WORLD/2);
 8001f10:	683b      	ldr	r3, [r7, #0]
 8001f12:	2206      	movs	r2, #6
 8001f14:	601a      	str	r2, [r3, #0]
    snake[0].y = (int)floor(SIZE_OF_WORLD/2);
 8001f16:	683b      	ldr	r3, [r7, #0]
 8001f18:	2206      	movs	r2, #6
 8001f1a:	605a      	str	r2, [r3, #4]
    for(i = 1; i < SIZE_OF_SNAKE; i++) {
 8001f1c:	2301      	movs	r3, #1
 8001f1e:	60fb      	str	r3, [r7, #12]
 8001f20:	e00c      	b.n	8001f3c <initSnake+0x3c>
        snake[i].isUsed = 0;
 8001f22:	68fa      	ldr	r2, [r7, #12]
 8001f24:	4613      	mov	r3, r2
 8001f26:	005b      	lsls	r3, r3, #1
 8001f28:	4413      	add	r3, r2
 8001f2a:	009b      	lsls	r3, r3, #2
 8001f2c:	461a      	mov	r2, r3
 8001f2e:	683b      	ldr	r3, [r7, #0]
 8001f30:	4413      	add	r3, r2
 8001f32:	2200      	movs	r2, #0
 8001f34:	609a      	str	r2, [r3, #8]
    int i;

    snake[0].isUsed = 1;
    snake[0].x = (int)floor(SIZE_OF_WORLD/2);
    snake[0].y = (int)floor(SIZE_OF_WORLD/2);
    for(i = 1; i < SIZE_OF_SNAKE; i++) {
 8001f36:	68fb      	ldr	r3, [r7, #12]
 8001f38:	3301      	adds	r3, #1
 8001f3a:	60fb      	str	r3, [r7, #12]
 8001f3c:	68fb      	ldr	r3, [r7, #12]
 8001f3e:	2b0e      	cmp	r3, #14
 8001f40:	ddef      	ble.n	8001f22 <initSnake+0x22>
        snake[i].isUsed = 0;
    }

    map[snake[0].x][snake[0].y] = 'O';
 8001f42:	683b      	ldr	r3, [r7, #0]
 8001f44:	681b      	ldr	r3, [r3, #0]
 8001f46:	461a      	mov	r2, r3
 8001f48:	4613      	mov	r3, r2
 8001f4a:	005b      	lsls	r3, r3, #1
 8001f4c:	4413      	add	r3, r2
 8001f4e:	009b      	lsls	r3, r3, #2
 8001f50:	4413      	add	r3, r2
 8001f52:	687a      	ldr	r2, [r7, #4]
 8001f54:	441a      	add	r2, r3
 8001f56:	683b      	ldr	r3, [r7, #0]
 8001f58:	685b      	ldr	r3, [r3, #4]
 8001f5a:	214f      	movs	r1, #79	; 0x4f
 8001f5c:	54d1      	strb	r1, [r2, r3]
}
 8001f5e:	bf00      	nop
 8001f60:	3714      	adds	r7, #20
 8001f62:	46bd      	mov	sp, r7
 8001f64:	bc80      	pop	{r7}
 8001f66:	4770      	bx	lr

08001f68 <moveSnake>:

void moveSnake(char map[SIZE_OF_WORLD][SIZE_OF_WORLD], Snake snake[SIZE_OF_SNAKE]) {
 8001f68:	b480      	push	{r7}
 8001f6a:	b0b1      	sub	sp, #196	; 0xc4
 8001f6c:	af00      	add	r7, sp, #0
 8001f6e:	6078      	str	r0, [r7, #4]
 8001f70:	6039      	str	r1, [r7, #0]
nastavim suradnice tej predchadzajucej,teda kazda cast sa "pohne" tam, kde bola predosla
*/
    int i;
    Snake oldSnake[SIZE_OF_SNAKE];

    for(i = 0; i < SIZE_OF_SNAKE; i++) {
 8001f72:	2300      	movs	r3, #0
 8001f74:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
 8001f78:	e01b      	b.n	8001fb2 <moveSnake+0x4a>
        oldSnake[i] = snake[i];
 8001f7a:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
 8001f7e:	4613      	mov	r3, r2
 8001f80:	005b      	lsls	r3, r3, #1
 8001f82:	4413      	add	r3, r2
 8001f84:	009b      	lsls	r3, r3, #2
 8001f86:	461a      	mov	r2, r3
 8001f88:	683b      	ldr	r3, [r7, #0]
 8001f8a:	1899      	adds	r1, r3, r2
 8001f8c:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
 8001f90:	4613      	mov	r3, r2
 8001f92:	005b      	lsls	r3, r3, #1
 8001f94:	4413      	add	r3, r2
 8001f96:	009b      	lsls	r3, r3, #2
 8001f98:	f107 02c0 	add.w	r2, r7, #192	; 0xc0
 8001f9c:	4413      	add	r3, r2
 8001f9e:	3bb8      	subs	r3, #184	; 0xb8
 8001fa0:	460a      	mov	r2, r1
 8001fa2:	ca07      	ldmia	r2, {r0, r1, r2}
 8001fa4:	e883 0007 	stmia.w	r3, {r0, r1, r2}
nastavim suradnice tej predchadzajucej,teda kazda cast sa "pohne" tam, kde bola predosla
*/
    int i;
    Snake oldSnake[SIZE_OF_SNAKE];

    for(i = 0; i < SIZE_OF_SNAKE; i++) {
 8001fa8:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 8001fac:	3301      	adds	r3, #1
 8001fae:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
 8001fb2:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 8001fb6:	2b0e      	cmp	r3, #14
 8001fb8:	dddf      	ble.n	8001f7a <moveSnake+0x12>
        oldSnake[i] = snake[i];
    }

    for(i = 1; i < SIZE_OF_SNAKE; i++) {
 8001fba:	2301      	movs	r3, #1
 8001fbc:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
 8001fc0:	e029      	b.n	8002016 <moveSnake+0xae>
        if(snake[i].isUsed == 1) {
 8001fc2:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
 8001fc6:	4613      	mov	r3, r2
 8001fc8:	005b      	lsls	r3, r3, #1
 8001fca:	4413      	add	r3, r2
 8001fcc:	009b      	lsls	r3, r3, #2
 8001fce:	461a      	mov	r2, r3
 8001fd0:	683b      	ldr	r3, [r7, #0]
 8001fd2:	4413      	add	r3, r2
 8001fd4:	689b      	ldr	r3, [r3, #8]
 8001fd6:	2b01      	cmp	r3, #1
 8001fd8:	d118      	bne.n	800200c <moveSnake+0xa4>
            snake[i] = oldSnake[i-1];
 8001fda:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
 8001fde:	4613      	mov	r3, r2
 8001fe0:	005b      	lsls	r3, r3, #1
 8001fe2:	4413      	add	r3, r2
 8001fe4:	009b      	lsls	r3, r3, #2
 8001fe6:	461a      	mov	r2, r3
 8001fe8:	683b      	ldr	r3, [r7, #0]
 8001fea:	1899      	adds	r1, r3, r2
 8001fec:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 8001ff0:	1e5a      	subs	r2, r3, #1
 8001ff2:	4613      	mov	r3, r2
 8001ff4:	005b      	lsls	r3, r3, #1
 8001ff6:	4413      	add	r3, r2
 8001ff8:	009b      	lsls	r3, r3, #2
 8001ffa:	f107 02c0 	add.w	r2, r7, #192	; 0xc0
 8001ffe:	4413      	add	r3, r2
 8002000:	f1a3 02b8 	sub.w	r2, r3, #184	; 0xb8
 8002004:	460b      	mov	r3, r1
 8002006:	ca07      	ldmia	r2, {r0, r1, r2}
 8002008:	e883 0007 	stmia.w	r3, {r0, r1, r2}

    for(i = 0; i < SIZE_OF_SNAKE; i++) {
        oldSnake[i] = snake[i];
    }

    for(i = 1; i < SIZE_OF_SNAKE; i++) {
 800200c:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 8002010:	3301      	adds	r3, #1
 8002012:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
 8002016:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 800201a:	2b0e      	cmp	r3, #14
 800201c:	ddd1      	ble.n	8001fc2 <moveSnake+0x5a>
        if(snake[i].isUsed == 1) {
            snake[i] = oldSnake[i-1];
        }
    }
}
 800201e:	bf00      	nop
 8002020:	37c4      	adds	r7, #196	; 0xc4
 8002022:	46bd      	mov	sp, r7
 8002024:	bc80      	pop	{r7}
 8002026:	4770      	bx	lr

08002028 <growthSnake>:

void growthSnake(char map[SIZE_OF_WORLD][SIZE_OF_WORLD], Snake snake[SIZE_OF_SNAKE], int* score) {
 8002028:	b580      	push	{r7, lr}
 800202a:	b0b2      	sub	sp, #200	; 0xc8
 800202c:	af00      	add	r7, sp, #0
 800202e:	60f8      	str	r0, [r7, #12]
 8002030:	60b9      	str	r1, [r7, #8]
 8002032:	607a      	str	r2, [r7, #4]
Teda, akoby som pridal jednu gulicku dopredu, na poziciu jedla.
*/
    int i;
    Snake oldSnake[SIZE_OF_SNAKE];

    for(i = 0; i < SIZE_OF_SNAKE; i++) {
 8002034:	2300      	movs	r3, #0
 8002036:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
 800203a:	e01b      	b.n	8002074 <growthSnake+0x4c>
        oldSnake[i] = snake[i];
 800203c:	f8d7 20c4 	ldr.w	r2, [r7, #196]	; 0xc4
 8002040:	4613      	mov	r3, r2
 8002042:	005b      	lsls	r3, r3, #1
 8002044:	4413      	add	r3, r2
 8002046:	009b      	lsls	r3, r3, #2
 8002048:	461a      	mov	r2, r3
 800204a:	68bb      	ldr	r3, [r7, #8]
 800204c:	1899      	adds	r1, r3, r2
 800204e:	f8d7 20c4 	ldr.w	r2, [r7, #196]	; 0xc4
 8002052:	4613      	mov	r3, r2
 8002054:	005b      	lsls	r3, r3, #1
 8002056:	4413      	add	r3, r2
 8002058:	009b      	lsls	r3, r3, #2
 800205a:	f107 02c8 	add.w	r2, r7, #200	; 0xc8
 800205e:	4413      	add	r3, r2
 8002060:	3bb8      	subs	r3, #184	; 0xb8
 8002062:	460a      	mov	r2, r1
 8002064:	ca07      	ldmia	r2, {r0, r1, r2}
 8002066:	e883 0007 	stmia.w	r3, {r0, r1, r2}
Teda, akoby som pridal jednu gulicku dopredu, na poziciu jedla.
*/
    int i;
    Snake oldSnake[SIZE_OF_SNAKE];

    for(i = 0; i < SIZE_OF_SNAKE; i++) {
 800206a:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 800206e:	3301      	adds	r3, #1
 8002070:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
 8002074:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 8002078:	2b0e      	cmp	r3, #14
 800207a:	dddf      	ble.n	800203c <growthSnake+0x14>
        oldSnake[i] = snake[i];
    }

    for(i = 1; i < *score + 1; i++) {
 800207c:	2301      	movs	r3, #1
 800207e:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
 8002082:	e01d      	b.n	80020c0 <growthSnake+0x98>
            snake[i] = oldSnake[i-1];
 8002084:	f8d7 20c4 	ldr.w	r2, [r7, #196]	; 0xc4
 8002088:	4613      	mov	r3, r2
 800208a:	005b      	lsls	r3, r3, #1
 800208c:	4413      	add	r3, r2
 800208e:	009b      	lsls	r3, r3, #2
 8002090:	461a      	mov	r2, r3
 8002092:	68bb      	ldr	r3, [r7, #8]
 8002094:	1899      	adds	r1, r3, r2
 8002096:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 800209a:	1e5a      	subs	r2, r3, #1
 800209c:	4613      	mov	r3, r2
 800209e:	005b      	lsls	r3, r3, #1
 80020a0:	4413      	add	r3, r2
 80020a2:	009b      	lsls	r3, r3, #2
 80020a4:	f107 02c8 	add.w	r2, r7, #200	; 0xc8
 80020a8:	4413      	add	r3, r2
 80020aa:	f1a3 02b8 	sub.w	r2, r3, #184	; 0xb8
 80020ae:	460b      	mov	r3, r1
 80020b0:	ca07      	ldmia	r2, {r0, r1, r2}
 80020b2:	e883 0007 	stmia.w	r3, {r0, r1, r2}

    for(i = 0; i < SIZE_OF_SNAKE; i++) {
        oldSnake[i] = snake[i];
    }

    for(i = 1; i < *score + 1; i++) {
 80020b6:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 80020ba:	3301      	adds	r3, #1
 80020bc:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
 80020c0:	687b      	ldr	r3, [r7, #4]
 80020c2:	681b      	ldr	r3, [r3, #0]
 80020c4:	1c5a      	adds	r2, r3, #1
 80020c6:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 80020ca:	429a      	cmp	r2, r3
 80020cc:	dcda      	bgt.n	8002084 <growthSnake+0x5c>
            snake[i] = oldSnake[i-1];
    }
    spawnRock(map);
 80020ce:	68f8      	ldr	r0, [r7, #12]
 80020d0:	f7ff fed2 	bl	8001e78 <spawnRock>
}
 80020d4:	bf00      	nop
 80020d6:	37c8      	adds	r7, #200	; 0xc8
 80020d8:	46bd      	mov	sp, r7
 80020da:	bd80      	pop	{r7, pc}

080020dc <clearMapFromSnake>:

void clearMapFromSnake(char map[SIZE_OF_WORLD][SIZE_OF_WORLD]) {
 80020dc:	b480      	push	{r7}
 80020de:	b085      	sub	sp, #20
 80020e0:	af00      	add	r7, sp, #0
 80020e2:	6078      	str	r0, [r7, #4]
Funkcia potrebna pri pohybe hada, najskor z matice hada odstranime, potom preratame,kam sa
ma had posunut a nasledne ho tam pridame. V tejto funkcii ho len odstranime
*/
    int row, col;

    for (row=0; row < SIZE_OF_WORLD; row++) {
 80020e4:	2300      	movs	r3, #0
 80020e6:	60fb      	str	r3, [r7, #12]
 80020e8:	e024      	b.n	8002134 <clearMapFromSnake+0x58>
        for(col = 0; col < SIZE_OF_WORLD; col++) {
 80020ea:	2300      	movs	r3, #0
 80020ec:	60bb      	str	r3, [r7, #8]
 80020ee:	e01b      	b.n	8002128 <clearMapFromSnake+0x4c>
            if(map[row][col] == 'O') {
 80020f0:	68fa      	ldr	r2, [r7, #12]
 80020f2:	4613      	mov	r3, r2
 80020f4:	005b      	lsls	r3, r3, #1
 80020f6:	4413      	add	r3, r2
 80020f8:	009b      	lsls	r3, r3, #2
 80020fa:	4413      	add	r3, r2
 80020fc:	687a      	ldr	r2, [r7, #4]
 80020fe:	441a      	add	r2, r3
 8002100:	68bb      	ldr	r3, [r7, #8]
 8002102:	4413      	add	r3, r2
 8002104:	781b      	ldrb	r3, [r3, #0]
 8002106:	2b4f      	cmp	r3, #79	; 0x4f
 8002108:	d10b      	bne.n	8002122 <clearMapFromSnake+0x46>
             map[row][col] = ' ';
 800210a:	68fa      	ldr	r2, [r7, #12]
 800210c:	4613      	mov	r3, r2
 800210e:	005b      	lsls	r3, r3, #1
 8002110:	4413      	add	r3, r2
 8002112:	009b      	lsls	r3, r3, #2
 8002114:	4413      	add	r3, r2
 8002116:	687a      	ldr	r2, [r7, #4]
 8002118:	441a      	add	r2, r3
 800211a:	68bb      	ldr	r3, [r7, #8]
 800211c:	4413      	add	r3, r2
 800211e:	2220      	movs	r2, #32
 8002120:	701a      	strb	r2, [r3, #0]
ma had posunut a nasledne ho tam pridame. V tejto funkcii ho len odstranime
*/
    int row, col;

    for (row=0; row < SIZE_OF_WORLD; row++) {
        for(col = 0; col < SIZE_OF_WORLD; col++) {
 8002122:	68bb      	ldr	r3, [r7, #8]
 8002124:	3301      	adds	r3, #1
 8002126:	60bb      	str	r3, [r7, #8]
 8002128:	68bb      	ldr	r3, [r7, #8]
 800212a:	2b0c      	cmp	r3, #12
 800212c:	dde0      	ble.n	80020f0 <clearMapFromSnake+0x14>
Funkcia potrebna pri pohybe hada, najskor z matice hada odstranime, potom preratame,kam sa
ma had posunut a nasledne ho tam pridame. V tejto funkcii ho len odstranime
*/
    int row, col;

    for (row=0; row < SIZE_OF_WORLD; row++) {
 800212e:	68fb      	ldr	r3, [r7, #12]
 8002130:	3301      	adds	r3, #1
 8002132:	60fb      	str	r3, [r7, #12]
 8002134:	68fb      	ldr	r3, [r7, #12]
 8002136:	2b0c      	cmp	r3, #12
 8002138:	ddd7      	ble.n	80020ea <clearMapFromSnake+0xe>
            if(map[row][col] == 'O') {
             map[row][col] = ' ';
            }
        }
    }
}
 800213a:	bf00      	nop
 800213c:	3714      	adds	r7, #20
 800213e:	46bd      	mov	sp, r7
 8002140:	bc80      	pop	{r7}
 8002142:	4770      	bx	lr

08002144 <addSnakeToMap>:

void addSnakeToMap(char map[SIZE_OF_WORLD][SIZE_OF_WORLD], Snake snake[SIZE_OF_SNAKE]) {
 8002144:	b480      	push	{r7}
 8002146:	b085      	sub	sp, #20
 8002148:	af00      	add	r7, sp, #0
 800214a:	6078      	str	r0, [r7, #4]
 800214c:	6039      	str	r1, [r7, #0]
/*
Po vyratani novych suradnic pridame hada tam, kde ma byt
*/
    int i;

    for (i = 0; i < SIZE_OF_SNAKE; i++) {
 800214e:	2300      	movs	r3, #0
 8002150:	60fb      	str	r3, [r7, #12]
 8002152:	e029      	b.n	80021a8 <addSnakeToMap+0x64>
        if(snake[i].isUsed == 1) {
 8002154:	68fa      	ldr	r2, [r7, #12]
 8002156:	4613      	mov	r3, r2
 8002158:	005b      	lsls	r3, r3, #1
 800215a:	4413      	add	r3, r2
 800215c:	009b      	lsls	r3, r3, #2
 800215e:	461a      	mov	r2, r3
 8002160:	683b      	ldr	r3, [r7, #0]
 8002162:	4413      	add	r3, r2
 8002164:	689b      	ldr	r3, [r3, #8]
 8002166:	2b01      	cmp	r3, #1
 8002168:	d11b      	bne.n	80021a2 <addSnakeToMap+0x5e>
            map[snake[i].x][snake[i].y] = 'O';
 800216a:	68fa      	ldr	r2, [r7, #12]
 800216c:	4613      	mov	r3, r2
 800216e:	005b      	lsls	r3, r3, #1
 8002170:	4413      	add	r3, r2
 8002172:	009b      	lsls	r3, r3, #2
 8002174:	461a      	mov	r2, r3
 8002176:	683b      	ldr	r3, [r7, #0]
 8002178:	4413      	add	r3, r2
 800217a:	681b      	ldr	r3, [r3, #0]
 800217c:	461a      	mov	r2, r3
 800217e:	4613      	mov	r3, r2
 8002180:	005b      	lsls	r3, r3, #1
 8002182:	4413      	add	r3, r2
 8002184:	009b      	lsls	r3, r3, #2
 8002186:	4413      	add	r3, r2
 8002188:	687a      	ldr	r2, [r7, #4]
 800218a:	18d1      	adds	r1, r2, r3
 800218c:	68fa      	ldr	r2, [r7, #12]
 800218e:	4613      	mov	r3, r2
 8002190:	005b      	lsls	r3, r3, #1
 8002192:	4413      	add	r3, r2
 8002194:	009b      	lsls	r3, r3, #2
 8002196:	461a      	mov	r2, r3
 8002198:	683b      	ldr	r3, [r7, #0]
 800219a:	4413      	add	r3, r2
 800219c:	685b      	ldr	r3, [r3, #4]
 800219e:	224f      	movs	r2, #79	; 0x4f
 80021a0:	54ca      	strb	r2, [r1, r3]
/*
Po vyratani novych suradnic pridame hada tam, kde ma byt
*/
    int i;

    for (i = 0; i < SIZE_OF_SNAKE; i++) {
 80021a2:	68fb      	ldr	r3, [r7, #12]
 80021a4:	3301      	adds	r3, #1
 80021a6:	60fb      	str	r3, [r7, #12]
 80021a8:	68fb      	ldr	r3, [r7, #12]
 80021aa:	2b0e      	cmp	r3, #14
 80021ac:	ddd2      	ble.n	8002154 <addSnakeToMap+0x10>
        if(snake[i].isUsed == 1) {
            map[snake[i].x][snake[i].y] = 'O';
        }
    }
}
 80021ae:	bf00      	nop
 80021b0:	3714      	adds	r7, #20
 80021b2:	46bd      	mov	sp, r7
 80021b4:	bc80      	pop	{r7}
 80021b6:	4770      	bx	lr

080021b8 <collision>:

int collision(char map[SIZE_OF_WORLD][SIZE_OF_WORLD], Snake snake[SIZE_OF_SNAKE],int x, int y, int* score) {
 80021b8:	b480      	push	{r7}
 80021ba:	b085      	sub	sp, #20
 80021bc:	af00      	add	r7, sp, #0
 80021be:	60f8      	str	r0, [r7, #12]
 80021c0:	60b9      	str	r1, [r7, #8]
 80021c2:	607a      	str	r2, [r7, #4]
 80021c4:	603b      	str	r3, [r7, #0]
/*
Funkcia deteguje koliziu. Podmienky su zoradene tak, ako predpokladame ich pravdepodobnostny vyskyt a teda
zjednodusujeme zlozitost. Funkcia vracia taku hodnotu,aka udalost nastala, teda 1 ak je mapa volna, 2 ak
sme nieco zjedli a -1 ak sme narazili.
*/
	if(map[x][y] == ' ') {
 80021c6:	687a      	ldr	r2, [r7, #4]
 80021c8:	4613      	mov	r3, r2
 80021ca:	005b      	lsls	r3, r3, #1
 80021cc:	4413      	add	r3, r2
 80021ce:	009b      	lsls	r3, r3, #2
 80021d0:	4413      	add	r3, r2
 80021d2:	68fa      	ldr	r2, [r7, #12]
 80021d4:	441a      	add	r2, r3
 80021d6:	683b      	ldr	r3, [r7, #0]
 80021d8:	4413      	add	r3, r2
 80021da:	781b      	ldrb	r3, [r3, #0]
 80021dc:	2b20      	cmp	r3, #32
 80021de:	d101      	bne.n	80021e4 <collision+0x2c>
		return 1;
 80021e0:	2301      	movs	r3, #1
 80021e2:	e050      	b.n	8002286 <collision+0xce>
	}
	if(map[x][y] == '@') {
 80021e4:	687a      	ldr	r2, [r7, #4]
 80021e6:	4613      	mov	r3, r2
 80021e8:	005b      	lsls	r3, r3, #1
 80021ea:	4413      	add	r3, r2
 80021ec:	009b      	lsls	r3, r3, #2
 80021ee:	4413      	add	r3, r2
 80021f0:	68fa      	ldr	r2, [r7, #12]
 80021f2:	441a      	add	r2, r3
 80021f4:	683b      	ldr	r3, [r7, #0]
 80021f6:	4413      	add	r3, r2
 80021f8:	781b      	ldrb	r3, [r3, #0]
 80021fa:	2b40      	cmp	r3, #64	; 0x40
 80021fc:	d101      	bne.n	8002202 <collision+0x4a>
		return 2;
 80021fe:	2302      	movs	r3, #2
 8002200:	e041      	b.n	8002286 <collision+0xce>
	}
	if(map[x][y] == 'X' ) {
 8002202:	687a      	ldr	r2, [r7, #4]
 8002204:	4613      	mov	r3, r2
 8002206:	005b      	lsls	r3, r3, #1
 8002208:	4413      	add	r3, r2
 800220a:	009b      	lsls	r3, r3, #2
 800220c:	4413      	add	r3, r2
 800220e:	68fa      	ldr	r2, [r7, #12]
 8002210:	441a      	add	r2, r3
 8002212:	683b      	ldr	r3, [r7, #0]
 8002214:	4413      	add	r3, r2
 8002216:	781b      	ldrb	r3, [r3, #0]
 8002218:	2b58      	cmp	r3, #88	; 0x58
 800221a:	d102      	bne.n	8002222 <collision+0x6a>
		return -1;
 800221c:	f04f 33ff 	mov.w	r3, #4294967295
 8002220:	e031      	b.n	8002286 <collision+0xce>
	Spodny if zabezpeci, ze ked bude vidiet hada pred sebou,narazi, ten nad nim cekuje,ci nahodou ten
	had pred nim je je koniec chvosta..lebo tam moze ist,nakolko sa ten chost posunie dopredu..preto
	najskor cekujem ci to nieje spicka chvosta,a ak ano vratim jednotku,ze tam mozne ist..az potom
	cekujem ci je to zvysok hada a narazim
	*/
	if (x == snake[*score].x && y == snake[*score].y && (*score !=1)) {
 8002222:	69bb      	ldr	r3, [r7, #24]
 8002224:	681b      	ldr	r3, [r3, #0]
 8002226:	461a      	mov	r2, r3
 8002228:	4613      	mov	r3, r2
 800222a:	005b      	lsls	r3, r3, #1
 800222c:	4413      	add	r3, r2
 800222e:	009b      	lsls	r3, r3, #2
 8002230:	461a      	mov	r2, r3
 8002232:	68bb      	ldr	r3, [r7, #8]
 8002234:	4413      	add	r3, r2
 8002236:	681a      	ldr	r2, [r3, #0]
 8002238:	687b      	ldr	r3, [r7, #4]
 800223a:	429a      	cmp	r2, r3
 800223c:	d113      	bne.n	8002266 <collision+0xae>
 800223e:	69bb      	ldr	r3, [r7, #24]
 8002240:	681b      	ldr	r3, [r3, #0]
 8002242:	461a      	mov	r2, r3
 8002244:	4613      	mov	r3, r2
 8002246:	005b      	lsls	r3, r3, #1
 8002248:	4413      	add	r3, r2
 800224a:	009b      	lsls	r3, r3, #2
 800224c:	461a      	mov	r2, r3
 800224e:	68bb      	ldr	r3, [r7, #8]
 8002250:	4413      	add	r3, r2
 8002252:	685a      	ldr	r2, [r3, #4]
 8002254:	683b      	ldr	r3, [r7, #0]
 8002256:	429a      	cmp	r2, r3
 8002258:	d105      	bne.n	8002266 <collision+0xae>
 800225a:	69bb      	ldr	r3, [r7, #24]
 800225c:	681b      	ldr	r3, [r3, #0]
 800225e:	2b01      	cmp	r3, #1
 8002260:	d001      	beq.n	8002266 <collision+0xae>
		return 1;
 8002262:	2301      	movs	r3, #1
 8002264:	e00f      	b.n	8002286 <collision+0xce>
	}
	if (map[x][y] == 'O') {
 8002266:	687a      	ldr	r2, [r7, #4]
 8002268:	4613      	mov	r3, r2
 800226a:	005b      	lsls	r3, r3, #1
 800226c:	4413      	add	r3, r2
 800226e:	009b      	lsls	r3, r3, #2
 8002270:	4413      	add	r3, r2
 8002272:	68fa      	ldr	r2, [r7, #12]
 8002274:	441a      	add	r2, r3
 8002276:	683b      	ldr	r3, [r7, #0]
 8002278:	4413      	add	r3, r2
 800227a:	781b      	ldrb	r3, [r3, #0]
 800227c:	2b4f      	cmp	r3, #79	; 0x4f
 800227e:	d102      	bne.n	8002286 <collision+0xce>
		return -1;
 8002280:	f04f 33ff 	mov.w	r3, #4294967295
 8002284:	e7ff      	b.n	8002286 <collision+0xce>
	}
}
 8002286:	4618      	mov	r0, r3
 8002288:	3714      	adds	r7, #20
 800228a:	46bd      	mov	sp, r7
 800228c:	bc80      	pop	{r7}
 800228e:	4770      	bx	lr

08002290 <move>:

int move(char direction, char map[SIZE_OF_WORLD][SIZE_OF_WORLD], Snake snake[SIZE_OF_SNAKE], int* score) {
 8002290:	b580      	push	{r7, lr}
 8002292:	b088      	sub	sp, #32
 8002294:	af02      	add	r7, sp, #8
 8002296:	60b9      	str	r1, [r7, #8]
 8002298:	607a      	str	r2, [r7, #4]
 800229a:	603b      	str	r3, [r7, #0]
 800229c:	4603      	mov	r3, r0
 800229e:	73fb      	strb	r3, [r7, #15]
    int decision = 0;
 80022a0:	2300      	movs	r3, #0
 80022a2:	617b      	str	r3, [r7, #20]

    switch(direction) {
 80022a4:	7bfb      	ldrb	r3, [r7, #15]
 80022a6:	3b61      	subs	r3, #97	; 0x61
 80022a8:	2b16      	cmp	r3, #22
 80022aa:	f200 8110 	bhi.w	80024ce <move+0x23e>
 80022ae:	a201      	add	r2, pc, #4	; (adr r2, 80022b4 <move+0x24>)
 80022b0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80022b4:	08002311 	.word	0x08002311
 80022b8:	080024cf 	.word	0x080024cf
 80022bc:	080024cf 	.word	0x080024cf
 80022c0:	0800237d 	.word	0x0800237d
 80022c4:	080024cf 	.word	0x080024cf
 80022c8:	080024cf 	.word	0x080024cf
 80022cc:	080024cf 	.word	0x080024cf
 80022d0:	080024cf 	.word	0x080024cf
 80022d4:	080024cf 	.word	0x080024cf
 80022d8:	080024cf 	.word	0x080024cf
 80022dc:	080024cf 	.word	0x080024cf
 80022e0:	080024cf 	.word	0x080024cf
 80022e4:	080024cf 	.word	0x080024cf
 80022e8:	080024cf 	.word	0x080024cf
 80022ec:	080024bd 	.word	0x080024bd
 80022f0:	080024cf 	.word	0x080024cf
 80022f4:	080024cf 	.word	0x080024cf
 80022f8:	080024cf 	.word	0x080024cf
 80022fc:	080023e9 	.word	0x080023e9
 8002300:	080024cf 	.word	0x080024cf
 8002304:	080024cf 	.word	0x080024cf
 8002308:	080024cf 	.word	0x080024cf
 800230c:	08002453 	.word	0x08002453
        case 'a':    // key up
            decision = collision(map, snake, snake[0].x, snake[0].y - 1, score);
 8002310:	687b      	ldr	r3, [r7, #4]
 8002312:	681a      	ldr	r2, [r3, #0]
 8002314:	687b      	ldr	r3, [r7, #4]
 8002316:	685b      	ldr	r3, [r3, #4]
 8002318:	1e59      	subs	r1, r3, #1
 800231a:	683b      	ldr	r3, [r7, #0]
 800231c:	9300      	str	r3, [sp, #0]
 800231e:	460b      	mov	r3, r1
 8002320:	6879      	ldr	r1, [r7, #4]
 8002322:	68b8      	ldr	r0, [r7, #8]
 8002324:	f7ff ff48 	bl	80021b8 <collision>
 8002328:	6178      	str	r0, [r7, #20]
            if (decision < 0) {
 800232a:	697b      	ldr	r3, [r7, #20]
 800232c:	2b00      	cmp	r3, #0
 800232e:	da01      	bge.n	8002334 <move+0xa4>
                return 1;
 8002330:	2301      	movs	r3, #1
 8002332:	e0cd      	b.n	80024d0 <move+0x240>
            } else if (decision == 1) {
 8002334:	697b      	ldr	r3, [r7, #20]
 8002336:	2b01      	cmp	r3, #1
 8002338:	d109      	bne.n	800234e <move+0xbe>
                moveSnake(map,snake);
 800233a:	6879      	ldr	r1, [r7, #4]
 800233c:	68b8      	ldr	r0, [r7, #8]
 800233e:	f7ff fe13 	bl	8001f68 <moveSnake>
                snake[0].y--;
 8002342:	687b      	ldr	r3, [r7, #4]
 8002344:	685b      	ldr	r3, [r3, #4]
 8002346:	1e5a      	subs	r2, r3, #1
 8002348:	687b      	ldr	r3, [r7, #4]
 800234a:	605a      	str	r2, [r3, #4]
                (*score)++;
                growthSnake(map, snake, score);
                snake[0].y--;
                spawnFood(map);
            }
            break;
 800234c:	e0b8      	b.n	80024c0 <move+0x230>
            if (decision < 0) {
                return 1;
            } else if (decision == 1) {
                moveSnake(map,snake);
                snake[0].y--;
            } else if (decision == 2) {
 800234e:	697b      	ldr	r3, [r7, #20]
 8002350:	2b02      	cmp	r3, #2
 8002352:	f040 80b5 	bne.w	80024c0 <move+0x230>
                (*score)++;
 8002356:	683b      	ldr	r3, [r7, #0]
 8002358:	681b      	ldr	r3, [r3, #0]
 800235a:	1c5a      	adds	r2, r3, #1
 800235c:	683b      	ldr	r3, [r7, #0]
 800235e:	601a      	str	r2, [r3, #0]
                growthSnake(map, snake, score);
 8002360:	683a      	ldr	r2, [r7, #0]
 8002362:	6879      	ldr	r1, [r7, #4]
 8002364:	68b8      	ldr	r0, [r7, #8]
 8002366:	f7ff fe5f 	bl	8002028 <growthSnake>
                snake[0].y--;
 800236a:	687b      	ldr	r3, [r7, #4]
 800236c:	685b      	ldr	r3, [r3, #4]
 800236e:	1e5a      	subs	r2, r3, #1
 8002370:	687b      	ldr	r3, [r7, #4]
 8002372:	605a      	str	r2, [r3, #4]
                spawnFood(map);
 8002374:	68b8      	ldr	r0, [r7, #8]
 8002376:	f7ff fd3b 	bl	8001df0 <spawnFood>
            }
            break;
 800237a:	e0a1      	b.n	80024c0 <move+0x230>
        case 'd':    // key down
            decision = collision(map, snake, snake[0].x, snake[0].y + 1, score);
 800237c:	687b      	ldr	r3, [r7, #4]
 800237e:	681a      	ldr	r2, [r3, #0]
 8002380:	687b      	ldr	r3, [r7, #4]
 8002382:	685b      	ldr	r3, [r3, #4]
 8002384:	1c59      	adds	r1, r3, #1
 8002386:	683b      	ldr	r3, [r7, #0]
 8002388:	9300      	str	r3, [sp, #0]
 800238a:	460b      	mov	r3, r1
 800238c:	6879      	ldr	r1, [r7, #4]
 800238e:	68b8      	ldr	r0, [r7, #8]
 8002390:	f7ff ff12 	bl	80021b8 <collision>
 8002394:	6178      	str	r0, [r7, #20]
            if (decision < 0) {
 8002396:	697b      	ldr	r3, [r7, #20]
 8002398:	2b00      	cmp	r3, #0
 800239a:	da01      	bge.n	80023a0 <move+0x110>
                return 1;
 800239c:	2301      	movs	r3, #1
 800239e:	e097      	b.n	80024d0 <move+0x240>
            } else if (decision == 1) {
 80023a0:	697b      	ldr	r3, [r7, #20]
 80023a2:	2b01      	cmp	r3, #1
 80023a4:	d109      	bne.n	80023ba <move+0x12a>
                moveSnake(map,snake);
 80023a6:	6879      	ldr	r1, [r7, #4]
 80023a8:	68b8      	ldr	r0, [r7, #8]
 80023aa:	f7ff fddd 	bl	8001f68 <moveSnake>
                snake[0].y++;
 80023ae:	687b      	ldr	r3, [r7, #4]
 80023b0:	685b      	ldr	r3, [r3, #4]
 80023b2:	1c5a      	adds	r2, r3, #1
 80023b4:	687b      	ldr	r3, [r7, #4]
 80023b6:	605a      	str	r2, [r3, #4]
                (*score)++;
                growthSnake(map, snake, score);
                snake[0].y++;
                spawnFood(map);
            }
            break;
 80023b8:	e084      	b.n	80024c4 <move+0x234>
            if (decision < 0) {
                return 1;
            } else if (decision == 1) {
                moveSnake(map,snake);
                snake[0].y++;
            } else if (decision == 2){
 80023ba:	697b      	ldr	r3, [r7, #20]
 80023bc:	2b02      	cmp	r3, #2
 80023be:	f040 8081 	bne.w	80024c4 <move+0x234>
                (*score)++;
 80023c2:	683b      	ldr	r3, [r7, #0]
 80023c4:	681b      	ldr	r3, [r3, #0]
 80023c6:	1c5a      	adds	r2, r3, #1
 80023c8:	683b      	ldr	r3, [r7, #0]
 80023ca:	601a      	str	r2, [r3, #0]
                growthSnake(map, snake, score);
 80023cc:	683a      	ldr	r2, [r7, #0]
 80023ce:	6879      	ldr	r1, [r7, #4]
 80023d0:	68b8      	ldr	r0, [r7, #8]
 80023d2:	f7ff fe29 	bl	8002028 <growthSnake>
                snake[0].y++;
 80023d6:	687b      	ldr	r3, [r7, #4]
 80023d8:	685b      	ldr	r3, [r3, #4]
 80023da:	1c5a      	adds	r2, r3, #1
 80023dc:	687b      	ldr	r3, [r7, #4]
 80023de:	605a      	str	r2, [r3, #4]
                spawnFood(map);
 80023e0:	68b8      	ldr	r0, [r7, #8]
 80023e2:	f7ff fd05 	bl	8001df0 <spawnFood>
            }
            break;
 80023e6:	e06d      	b.n	80024c4 <move+0x234>
        case 's':    // key right
            decision = collision(map, snake, snake[0].x + 1, snake[0].y, score);
 80023e8:	687b      	ldr	r3, [r7, #4]
 80023ea:	681b      	ldr	r3, [r3, #0]
 80023ec:	1c5a      	adds	r2, r3, #1
 80023ee:	687b      	ldr	r3, [r7, #4]
 80023f0:	6859      	ldr	r1, [r3, #4]
 80023f2:	683b      	ldr	r3, [r7, #0]
 80023f4:	9300      	str	r3, [sp, #0]
 80023f6:	460b      	mov	r3, r1
 80023f8:	6879      	ldr	r1, [r7, #4]
 80023fa:	68b8      	ldr	r0, [r7, #8]
 80023fc:	f7ff fedc 	bl	80021b8 <collision>
 8002400:	6178      	str	r0, [r7, #20]
            if (decision < 0) {
 8002402:	697b      	ldr	r3, [r7, #20]
 8002404:	2b00      	cmp	r3, #0
 8002406:	da01      	bge.n	800240c <move+0x17c>
                return 1;
 8002408:	2301      	movs	r3, #1
 800240a:	e061      	b.n	80024d0 <move+0x240>
            } else if (decision == 1) {
 800240c:	697b      	ldr	r3, [r7, #20]
 800240e:	2b01      	cmp	r3, #1
 8002410:	d109      	bne.n	8002426 <move+0x196>
                moveSnake(map,snake);
 8002412:	6879      	ldr	r1, [r7, #4]
 8002414:	68b8      	ldr	r0, [r7, #8]
 8002416:	f7ff fda7 	bl	8001f68 <moveSnake>
                snake[0].x++;
 800241a:	687b      	ldr	r3, [r7, #4]
 800241c:	681b      	ldr	r3, [r3, #0]
 800241e:	1c5a      	adds	r2, r3, #1
 8002420:	687b      	ldr	r3, [r7, #4]
 8002422:	601a      	str	r2, [r3, #0]
                (*score)++;
                growthSnake(map, snake, score);
                snake[0].x++;
                spawnFood(map);
            }
            break;
 8002424:	e050      	b.n	80024c8 <move+0x238>
            if (decision < 0) {
                return 1;
            } else if (decision == 1) {
                moveSnake(map,snake);
                snake[0].x++;
            } else if (decision == 2){
 8002426:	697b      	ldr	r3, [r7, #20]
 8002428:	2b02      	cmp	r3, #2
 800242a:	d14d      	bne.n	80024c8 <move+0x238>
                (*score)++;
 800242c:	683b      	ldr	r3, [r7, #0]
 800242e:	681b      	ldr	r3, [r3, #0]
 8002430:	1c5a      	adds	r2, r3, #1
 8002432:	683b      	ldr	r3, [r7, #0]
 8002434:	601a      	str	r2, [r3, #0]
                growthSnake(map, snake, score);
 8002436:	683a      	ldr	r2, [r7, #0]
 8002438:	6879      	ldr	r1, [r7, #4]
 800243a:	68b8      	ldr	r0, [r7, #8]
 800243c:	f7ff fdf4 	bl	8002028 <growthSnake>
                snake[0].x++;
 8002440:	687b      	ldr	r3, [r7, #4]
 8002442:	681b      	ldr	r3, [r3, #0]
 8002444:	1c5a      	adds	r2, r3, #1
 8002446:	687b      	ldr	r3, [r7, #4]
 8002448:	601a      	str	r2, [r3, #0]
                spawnFood(map);
 800244a:	68b8      	ldr	r0, [r7, #8]
 800244c:	f7ff fcd0 	bl	8001df0 <spawnFood>
            }
            break;
 8002450:	e03a      	b.n	80024c8 <move+0x238>
        case 'w':    // key left
            decision = collision(map, snake, snake[0].x - 1, snake[0].y, score);
 8002452:	687b      	ldr	r3, [r7, #4]
 8002454:	681b      	ldr	r3, [r3, #0]
 8002456:	1e5a      	subs	r2, r3, #1
 8002458:	687b      	ldr	r3, [r7, #4]
 800245a:	6859      	ldr	r1, [r3, #4]
 800245c:	683b      	ldr	r3, [r7, #0]
 800245e:	9300      	str	r3, [sp, #0]
 8002460:	460b      	mov	r3, r1
 8002462:	6879      	ldr	r1, [r7, #4]
 8002464:	68b8      	ldr	r0, [r7, #8]
 8002466:	f7ff fea7 	bl	80021b8 <collision>
 800246a:	6178      	str	r0, [r7, #20]
            if (decision < 0) {
 800246c:	697b      	ldr	r3, [r7, #20]
 800246e:	2b00      	cmp	r3, #0
 8002470:	da01      	bge.n	8002476 <move+0x1e6>
                return 1;
 8002472:	2301      	movs	r3, #1
 8002474:	e02c      	b.n	80024d0 <move+0x240>
            } else if (decision == 1) {
 8002476:	697b      	ldr	r3, [r7, #20]
 8002478:	2b01      	cmp	r3, #1
 800247a:	d109      	bne.n	8002490 <move+0x200>
                moveSnake(map,snake);
 800247c:	6879      	ldr	r1, [r7, #4]
 800247e:	68b8      	ldr	r0, [r7, #8]
 8002480:	f7ff fd72 	bl	8001f68 <moveSnake>
                snake[0].x--;
 8002484:	687b      	ldr	r3, [r7, #4]
 8002486:	681b      	ldr	r3, [r3, #0]
 8002488:	1e5a      	subs	r2, r3, #1
 800248a:	687b      	ldr	r3, [r7, #4]
 800248c:	601a      	str	r2, [r3, #0]
                (*score)++;
                growthSnake(map, snake, score);
                snake[0].x--;
                spawnFood(map);
            }
            break;
 800248e:	e01d      	b.n	80024cc <move+0x23c>
            if (decision < 0) {
                return 1;
            } else if (decision == 1) {
                moveSnake(map,snake);
                snake[0].x--;
            } else if (decision == 2){
 8002490:	697b      	ldr	r3, [r7, #20]
 8002492:	2b02      	cmp	r3, #2
 8002494:	d11a      	bne.n	80024cc <move+0x23c>
                (*score)++;
 8002496:	683b      	ldr	r3, [r7, #0]
 8002498:	681b      	ldr	r3, [r3, #0]
 800249a:	1c5a      	adds	r2, r3, #1
 800249c:	683b      	ldr	r3, [r7, #0]
 800249e:	601a      	str	r2, [r3, #0]
                growthSnake(map, snake, score);
 80024a0:	683a      	ldr	r2, [r7, #0]
 80024a2:	6879      	ldr	r1, [r7, #4]
 80024a4:	68b8      	ldr	r0, [r7, #8]
 80024a6:	f7ff fdbf 	bl	8002028 <growthSnake>
                snake[0].x--;
 80024aa:	687b      	ldr	r3, [r7, #4]
 80024ac:	681b      	ldr	r3, [r3, #0]
 80024ae:	1e5a      	subs	r2, r3, #1
 80024b0:	687b      	ldr	r3, [r7, #4]
 80024b2:	601a      	str	r2, [r3, #0]
                spawnFood(map);
 80024b4:	68b8      	ldr	r0, [r7, #8]
 80024b6:	f7ff fc9b 	bl	8001df0 <spawnFood>
            }
            break;
 80024ba:	e007      	b.n	80024cc <move+0x23c>
        case 'o':
            return 1;
 80024bc:	2301      	movs	r3, #1
 80024be:	e007      	b.n	80024d0 <move+0x240>
                (*score)++;
                growthSnake(map, snake, score);
                snake[0].y--;
                spawnFood(map);
            }
            break;
 80024c0:	bf00      	nop
 80024c2:	e004      	b.n	80024ce <move+0x23e>
                (*score)++;
                growthSnake(map, snake, score);
                snake[0].y++;
                spawnFood(map);
            }
            break;
 80024c4:	bf00      	nop
 80024c6:	e002      	b.n	80024ce <move+0x23e>
                (*score)++;
                growthSnake(map, snake, score);
                snake[0].x++;
                spawnFood(map);
            }
            break;
 80024c8:	bf00      	nop
 80024ca:	e000      	b.n	80024ce <move+0x23e>
                (*score)++;
                growthSnake(map, snake, score);
                snake[0].x--;
                spawnFood(map);
            }
            break;
 80024cc:	bf00      	nop
        case 'o':
            return 1;
            break;
    }

    return 0;
 80024ce:	2300      	movs	r3, #0
}
 80024d0:	4618      	mov	r0, r3
 80024d2:	3718      	adds	r7, #24
 80024d4:	46bd      	mov	sp, r7
 80024d6:	bd80      	pop	{r7, pc}

080024d8 <buttoninit>:


void buttoninit(){
 80024d8:	b580      	push	{r7, lr}
 80024da:	b082      	sub	sp, #8
 80024dc:	af00      	add	r7, sp, #0
	  GPIO_InitTypeDef struktura1;
	 RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOC, ENABLE);
 80024de:	2101      	movs	r1, #1
 80024e0:	2004      	movs	r0, #4
 80024e2:	f7fe fba7 	bl	8000c34 <RCC_AHBPeriphClockCmd>
		     struktura1.GPIO_Mode = GPIO_Mode_IN ;
 80024e6:	2300      	movs	r3, #0
 80024e8:	713b      	strb	r3, [r7, #4]
		     struktura1.GPIO_OType = GPIO_OType_PP;
 80024ea:	2300      	movs	r3, #0
 80024ec:	71bb      	strb	r3, [r7, #6]
		     struktura1.GPIO_PuPd = GPIO_PuPd_NOPULL;
 80024ee:	2300      	movs	r3, #0
 80024f0:	71fb      	strb	r3, [r7, #7]
		     struktura1.GPIO_Pin = GPIO_Pin_13;
 80024f2:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 80024f6:	603b      	str	r3, [r7, #0]
		     GPIO_Init(GPIOC, &struktura1);
 80024f8:	463b      	mov	r3, r7
 80024fa:	4619      	mov	r1, r3
 80024fc:	4803      	ldr	r0, [pc, #12]	; (800250c <buttoninit+0x34>)
 80024fe:	f7fe fa8f 	bl	8000a20 <GPIO_Init>
}
 8002502:	bf00      	nop
 8002504:	3708      	adds	r7, #8
 8002506:	46bd      	mov	sp, r7
 8002508:	bd80      	pop	{r7, pc}
 800250a:	bf00      	nop
 800250c:	40020800 	.word	0x40020800

08002510 <init_game>:

void init_game(){
 8002510:	b580      	push	{r7, lr}
 8002512:	b0e0      	sub	sp, #384	; 0x180
 8002514:	af02      	add	r7, sp, #8
	  adc_init();
 8002516:	f7fe fdef 	bl	80010f8 <adc_init>
	  initSPI2();
 800251a:	f7fe fcef 	bl	8000efc <initSPI2>
	  initCD_Pin();
 800251e:	f7fe fd7f 	bl	8001020 <initCD_Pin>
	  initCS_Pin();
 8002522:	f7fe fd5f 	bl	8000fe4 <initCS_Pin>
	  initRES_Pin();
 8002526:	f7fe fdb1 	bl	800108c <initRES_Pin>
	  buttoninit();
 800252a:	f7ff ffd5 	bl	80024d8 <buttoninit>

	  lcdInitialise(LCD_ORIENTATION0);
 800252e:	2000      	movs	r0, #0
 8002530:	f7fe feaa 	bl	8001288 <lcdInitialise>
	 lcdClearDisplay(decodeRgbValue(0, 0, 0));
 8002534:	2200      	movs	r2, #0
 8002536:	2100      	movs	r1, #0
 8002538:	2000      	movs	r0, #0
 800253a:	f7ff f939 	bl	80017b0 <decodeRgbValue>
 800253e:	4603      	mov	r3, r0
 8002540:	4618      	mov	r0, r3
 8002542:	f7fe ff7d 	bl	8001440 <lcdClearDisplay>
	 draw_hadik();
 8002546:	f7ff f9db 	bl	8001900 <draw_hadik>
	  int button = 0;
 800254a:	2300      	movs	r3, #0
 800254c:	f8c7 3168 	str.w	r3, [r7, #360]	; 0x168
	  int endFlag = 0;
 8002550:	2300      	movs	r3, #0
 8002552:	f8c7 3174 	str.w	r3, [r7, #372]	; 0x174
	  int *score = (int*)malloc(sizeof(int));
 8002556:	2004      	movs	r0, #4
 8002558:	f000 fad8 	bl	8002b0c <malloc>
 800255c:	4603      	mov	r3, r0
 800255e:	f8c7 3164 	str.w	r3, [r7, #356]	; 0x164
	  *score = 0;
 8002562:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 8002566:	2200      	movs	r2, #0
 8002568:	601a      	str	r2, [r3, #0]
	  int isFood = 1;
 800256a:	2301      	movs	r3, #1
 800256c:	f8c7 3170 	str.w	r3, [r7, #368]	; 0x170
	  char direction = 0;
 8002570:	2300      	movs	r3, #0
 8002572:	f887 3163 	strb.w	r3, [r7, #355]	; 0x163
	  char map[SIZE_OF_WORLD][SIZE_OF_WORLD];
	  Snake snake[SIZE_OF_SNAKE];
	  Delays1(10);
 8002576:	200a      	movs	r0, #10
 8002578:	f7ff fb9c 	bl	8001cb4 <Delays1>
	  lcdClearDisplay(decodeRgbValue(0, 0, 0));
 800257c:	2200      	movs	r2, #0
 800257e:	2100      	movs	r1, #0
 8002580:	2000      	movs	r0, #0
 8002582:	f7ff f915 	bl	80017b0 <decodeRgbValue>
 8002586:	4603      	mov	r3, r0
 8002588:	4618      	mov	r0, r3
 800258a:	f7fe ff59 	bl	8001440 <lcdClearDisplay>
	  initWorld(map);
 800258e:	f107 03b4 	add.w	r3, r7, #180	; 0xb4
 8002592:	4618      	mov	r0, r3
 8002594:	f7ff fbb0 	bl	8001cf8 <initWorld>
	  initSnake(map,snake);
 8002598:	463a      	mov	r2, r7
 800259a:	f107 03b4 	add.w	r3, r7, #180	; 0xb4
 800259e:	4611      	mov	r1, r2
 80025a0:	4618      	mov	r0, r3
 80025a2:	f7ff fcad 	bl	8001f00 <initSnake>
	  spawnFood(map);
 80025a6:	f107 03b4 	add.w	r3, r7, #180	; 0xb4
 80025aa:	4618      	mov	r0, r3
 80025ac:	f7ff fc20 	bl	8001df0 <spawnFood>
	  map[3][6] = '@';
 80025b0:	2340      	movs	r3, #64	; 0x40
 80025b2:	f887 30e1 	strb.w	r3, [r7, #225]	; 0xe1
	  char str ;
	  printWorld(map);
 80025b6:	f107 03b4 	add.w	r3, r7, #180	; 0xb4
 80025ba:	4618      	mov	r0, r3
 80025bc:	f7ff fbe0 	bl	8001d80 <printWorld>
	  int pom = 0;
 80025c0:	2300      	movs	r3, #0
 80025c2:	f8c7 316c 	str.w	r3, [r7, #364]	; 0x16c
	  char dec, el,temp;



	  do{
		     button = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_13);
 80025c6:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 80025ca:	489e      	ldr	r0, [pc, #632]	; (8002844 <init_game+0x334>)
 80025cc:	f7fe fabe 	bl	8000b4c <GPIO_ReadInputDataBit>
 80025d0:	4603      	mov	r3, r0
 80025d2:	f8c7 3168 	str.w	r3, [r7, #360]	; 0x168
		     if(!button) pom = 1 ;
 80025d6:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 80025da:	2b00      	cmp	r3, #0
 80025dc:	d102      	bne.n	80025e4 <init_game+0xd4>
 80025de:	2301      	movs	r3, #1
 80025e0:	f8c7 316c 	str.w	r3, [r7, #364]	; 0x16c
		     if(pom){
 80025e4:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 80025e8:	2b00      	cmp	r3, #0
 80025ea:	f000 80a0 	beq.w	800272e <init_game+0x21e>


	         if(!isFood) {
 80025ee:	f8d7 3170 	ldr.w	r3, [r7, #368]	; 0x170
 80025f2:	2b00      	cmp	r3, #0
 80025f4:	d107      	bne.n	8002606 <init_game+0xf6>
	             spawnFood(map);
 80025f6:	f107 03b4 	add.w	r3, r7, #180	; 0xb4
 80025fa:	4618      	mov	r0, r3
 80025fc:	f7ff fbf8 	bl	8001df0 <spawnFood>
	             isFood = 1;
 8002600:	2301      	movs	r3, #1
 8002602:	f8c7 3170 	str.w	r3, [r7, #368]	; 0x170
	         }


	         direction = get_adc_char();
 8002606:	f7ff f931 	bl	800186c <get_adc_char>
 800260a:	4603      	mov	r3, r0
 800260c:	f887 3163 	strb.w	r3, [r7, #355]	; 0x163

	         /*if(!button)
	        	 direction = 'w';*/


	         endFlag = move(direction, map, snake, score);
 8002610:	463a      	mov	r2, r7
 8002612:	f107 01b4 	add.w	r1, r7, #180	; 0xb4
 8002616:	f897 0163 	ldrb.w	r0, [r7, #355]	; 0x163
 800261a:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 800261e:	f7ff fe37 	bl	8002290 <move>
 8002622:	f8c7 0174 	str.w	r0, [r7, #372]	; 0x174

	         //system("@cls||clear");
	         clearMapFromSnake(map);
 8002626:	f107 03b4 	add.w	r3, r7, #180	; 0xb4
 800262a:	4618      	mov	r0, r3
 800262c:	f7ff fd56 	bl	80020dc <clearMapFromSnake>
	         addSnakeToMap(map,snake);
 8002630:	463a      	mov	r2, r7
 8002632:	f107 03b4 	add.w	r3, r7, #180	; 0xb4
 8002636:	4611      	mov	r1, r2
 8002638:	4618      	mov	r0, r3
 800263a:	f7ff fd83 	bl	8002144 <addSnakeToMap>
	         printWorld(map);
 800263e:	f107 03b4 	add.w	r3, r7, #180	; 0xb4
 8002642:	4618      	mov	r0, r3
 8002644:	f7ff fb9c 	bl	8001d80 <printWorld>

	         //while ( getchar() != '\n' );
	         //fflush(stdin);
	         //direction = 0;
	         Delays(10);
 8002648:	200a      	movs	r0, #10
 800264a:	f7ff fb13 	bl	8001c74 <Delays>



	         if(*score == SIZE_OF_SNAKE -1) {
 800264e:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 8002652:	681b      	ldr	r3, [r3, #0]
 8002654:	2b0e      	cmp	r3, #14
 8002656:	d16a      	bne.n	800272e <init_game+0x21e>
	        		char hodnota = *score;
 8002658:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 800265c:	681b      	ldr	r3, [r3, #0]
 800265e:	f887 3162 	strb.w	r3, [r7, #354]	; 0x162
	        		dec = hodnota/10;
 8002662:	f897 3162 	ldrb.w	r3, [r7, #354]	; 0x162
 8002666:	4a78      	ldr	r2, [pc, #480]	; (8002848 <init_game+0x338>)
 8002668:	fba2 2303 	umull	r2, r3, r2, r3
 800266c:	08db      	lsrs	r3, r3, #3
 800266e:	f887 3161 	strb.w	r3, [r7, #353]	; 0x161
	        		el = hodnota % 10;
 8002672:	f897 2162 	ldrb.w	r2, [r7, #354]	; 0x162
 8002676:	4b74      	ldr	r3, [pc, #464]	; (8002848 <init_game+0x338>)
 8002678:	fba3 1302 	umull	r1, r3, r3, r2
 800267c:	08d9      	lsrs	r1, r3, #3
 800267e:	460b      	mov	r3, r1
 8002680:	009b      	lsls	r3, r3, #2
 8002682:	440b      	add	r3, r1
 8002684:	005b      	lsls	r3, r3, #1
 8002686:	1ad3      	subs	r3, r2, r3
 8002688:	f887 3160 	strb.w	r3, [r7, #352]	; 0x160
	        		dec += 48;
 800268c:	f897 3161 	ldrb.w	r3, [r7, #353]	; 0x161
 8002690:	3330      	adds	r3, #48	; 0x30
 8002692:	f887 3161 	strb.w	r3, [r7, #353]	; 0x161
	        	    el  += 48;
 8002696:	f897 3160 	ldrb.w	r3, [r7, #352]	; 0x160
 800269a:	3330      	adds	r3, #48	; 0x30
 800269c:	f887 3160 	strb.w	r3, [r7, #352]	; 0x160
	        	    lcdClearDisplay(decodeRgbValue(0, 0, 0));
 80026a0:	2200      	movs	r2, #0
 80026a2:	2100      	movs	r1, #0
 80026a4:	2000      	movs	r0, #0
 80026a6:	f7ff f883 	bl	80017b0 <decodeRgbValue>
 80026aa:	4603      	mov	r3, r0
 80026ac:	4618      	mov	r0, r3
 80026ae:	f7fe fec7 	bl	8001440 <lcdClearDisplay>
	        	    lcdPutS("Vyhral si",40,50,0xFFFF, 0);
 80026b2:	2300      	movs	r3, #0
 80026b4:	9300      	str	r3, [sp, #0]
 80026b6:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80026ba:	2232      	movs	r2, #50	; 0x32
 80026bc:	2128      	movs	r1, #40	; 0x28
 80026be:	4863      	ldr	r0, [pc, #396]	; (800284c <init_game+0x33c>)
 80026c0:	f7ff f892 	bl	80017e8 <lcdPutS>
	        	    lcdPutS("Tvoje skore :",35,60,0xFFFF,0);
 80026c4:	2300      	movs	r3, #0
 80026c6:	9300      	str	r3, [sp, #0]
 80026c8:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80026cc:	223c      	movs	r2, #60	; 0x3c
 80026ce:	2123      	movs	r1, #35	; 0x23
 80026d0:	485f      	ldr	r0, [pc, #380]	; (8002850 <init_game+0x340>)
 80026d2:	f7ff f889 	bl	80017e8 <lcdPutS>
	        	    lcdPutCh(dec,105,60,0xFFFF,0);
 80026d6:	f897 0161 	ldrb.w	r0, [r7, #353]	; 0x161
 80026da:	2300      	movs	r3, #0
 80026dc:	9300      	str	r3, [sp, #0]
 80026de:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80026e2:	223c      	movs	r2, #60	; 0x3c
 80026e4:	2169      	movs	r1, #105	; 0x69
 80026e6:	f7fe ffef 	bl	80016c8 <lcdPutCh>
	                if(*score >=10){
 80026ea:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 80026ee:	681b      	ldr	r3, [r3, #0]
 80026f0:	2b09      	cmp	r3, #9
 80026f2:	dd09      	ble.n	8002708 <init_game+0x1f8>
	        	    lcdPutCh(el,113,60,0xFFFF,0);}
 80026f4:	f897 0160 	ldrb.w	r0, [r7, #352]	; 0x160
 80026f8:	2300      	movs	r3, #0
 80026fa:	9300      	str	r3, [sp, #0]
 80026fc:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8002700:	223c      	movs	r2, #60	; 0x3c
 8002702:	2171      	movs	r1, #113	; 0x71
 8002704:	f7fe ffe0 	bl	80016c8 <lcdPutCh>
	        	    lcdPutS("Pre hranie odznova ",10,70,0xFFFF, 0);
 8002708:	2300      	movs	r3, #0
 800270a:	9300      	str	r3, [sp, #0]
 800270c:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8002710:	2246      	movs	r2, #70	; 0x46
 8002712:	210a      	movs	r1, #10
 8002714:	484f      	ldr	r0, [pc, #316]	; (8002854 <init_game+0x344>)
 8002716:	f7ff f867 	bl	80017e8 <lcdPutS>
	        	    lcdPutS("Stlac reset  ",35,80,0xFFFF, 0);
 800271a:	2300      	movs	r3, #0
 800271c:	9300      	str	r3, [sp, #0]
 800271e:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8002722:	2250      	movs	r2, #80	; 0x50
 8002724:	2123      	movs	r1, #35	; 0x23
 8002726:	484c      	ldr	r0, [pc, #304]	; (8002858 <init_game+0x348>)
 8002728:	f7ff f85e 	bl	80017e8 <lcdPutS>
	        	    return 0;
 800272c:	e086      	b.n	800283c <init_game+0x32c>
	         }

		     }
	     }while(endFlag != 1);
 800272e:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 8002732:	2b01      	cmp	r3, #1
 8002734:	f47f af47 	bne.w	80025c6 <init_game+0xb6>
	  	  	  	  	char hodnota = *score;
 8002738:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 800273c:	681b      	ldr	r3, [r3, #0]
 800273e:	f887 315f 	strb.w	r3, [r7, #351]	; 0x15f
	  	         	dec = hodnota/10;
 8002742:	f897 315f 	ldrb.w	r3, [r7, #351]	; 0x15f
 8002746:	4a40      	ldr	r2, [pc, #256]	; (8002848 <init_game+0x338>)
 8002748:	fba2 2303 	umull	r2, r3, r2, r3
 800274c:	08db      	lsrs	r3, r3, #3
 800274e:	f887 3161 	strb.w	r3, [r7, #353]	; 0x161
	  	         	temp = hodnota;
 8002752:	f897 315f 	ldrb.w	r3, [r7, #351]	; 0x15f
 8002756:	f887 315e 	strb.w	r3, [r7, #350]	; 0x15e
	  	         	el = hodnota % 10;
 800275a:	f897 215f 	ldrb.w	r2, [r7, #351]	; 0x15f
 800275e:	4b3a      	ldr	r3, [pc, #232]	; (8002848 <init_game+0x338>)
 8002760:	fba3 1302 	umull	r1, r3, r3, r2
 8002764:	08d9      	lsrs	r1, r3, #3
 8002766:	460b      	mov	r3, r1
 8002768:	009b      	lsls	r3, r3, #2
 800276a:	440b      	add	r3, r1
 800276c:	005b      	lsls	r3, r3, #1
 800276e:	1ad3      	subs	r3, r2, r3
 8002770:	f887 3160 	strb.w	r3, [r7, #352]	; 0x160

	  	         	dec += 48;
 8002774:	f897 3161 	ldrb.w	r3, [r7, #353]	; 0x161
 8002778:	3330      	adds	r3, #48	; 0x30
 800277a:	f887 3161 	strb.w	r3, [r7, #353]	; 0x161
	  	         	el  += 48;
 800277e:	f897 3160 	ldrb.w	r3, [r7, #352]	; 0x160
 8002782:	3330      	adds	r3, #48	; 0x30
 8002784:	f887 3160 	strb.w	r3, [r7, #352]	; 0x160
	  	         	temp +=48;
 8002788:	f897 315e 	ldrb.w	r3, [r7, #350]	; 0x15e
 800278c:	3330      	adds	r3, #48	; 0x30
 800278e:	f887 315e 	strb.w	r3, [r7, #350]	; 0x15e
	  	         	lcdClearDisplay(decodeRgbValue(0, 0, 0));
 8002792:	2200      	movs	r2, #0
 8002794:	2100      	movs	r1, #0
 8002796:	2000      	movs	r0, #0
 8002798:	f7ff f80a 	bl	80017b0 <decodeRgbValue>
 800279c:	4603      	mov	r3, r0
 800279e:	4618      	mov	r0, r3
 80027a0:	f7fe fe4e 	bl	8001440 <lcdClearDisplay>
	  	         	lcdPutS("Prehral si",40,50,0xFFFF, 0);
 80027a4:	2300      	movs	r3, #0
 80027a6:	9300      	str	r3, [sp, #0]
 80027a8:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80027ac:	2232      	movs	r2, #50	; 0x32
 80027ae:	2128      	movs	r1, #40	; 0x28
 80027b0:	482a      	ldr	r0, [pc, #168]	; (800285c <init_game+0x34c>)
 80027b2:	f7ff f819 	bl	80017e8 <lcdPutS>
	  	         	lcdPutS("Tvoje skore :",35,60,0xFFFF,0);
 80027b6:	2300      	movs	r3, #0
 80027b8:	9300      	str	r3, [sp, #0]
 80027ba:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80027be:	223c      	movs	r2, #60	; 0x3c
 80027c0:	2123      	movs	r1, #35	; 0x23
 80027c2:	4823      	ldr	r0, [pc, #140]	; (8002850 <init_game+0x340>)
 80027c4:	f7ff f810 	bl	80017e8 <lcdPutS>
	  	         	if(*score < 10){
 80027c8:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 80027cc:	681b      	ldr	r3, [r3, #0]
 80027ce:	2b09      	cmp	r3, #9
 80027d0:	dc09      	bgt.n	80027e6 <init_game+0x2d6>
	  	         	lcdPutCh(temp,105,60,0xFFFF,0);
 80027d2:	f897 015e 	ldrb.w	r0, [r7, #350]	; 0x15e
 80027d6:	2300      	movs	r3, #0
 80027d8:	9300      	str	r3, [sp, #0]
 80027da:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80027de:	223c      	movs	r2, #60	; 0x3c
 80027e0:	2169      	movs	r1, #105	; 0x69
 80027e2:	f7fe ff71 	bl	80016c8 <lcdPutCh>
	  	         	}
	  	         	if(*score >=10){
 80027e6:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 80027ea:	681b      	ldr	r3, [r3, #0]
 80027ec:	2b09      	cmp	r3, #9
 80027ee:	dd13      	ble.n	8002818 <init_game+0x308>
	  	         	lcdPutCh(dec,105,60,0xFFFF,0);
 80027f0:	f897 0161 	ldrb.w	r0, [r7, #353]	; 0x161
 80027f4:	2300      	movs	r3, #0
 80027f6:	9300      	str	r3, [sp, #0]
 80027f8:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80027fc:	223c      	movs	r2, #60	; 0x3c
 80027fe:	2169      	movs	r1, #105	; 0x69
 8002800:	f7fe ff62 	bl	80016c8 <lcdPutCh>
	  	         	lcdPutCh(el,113,60,0xFFFF,0);
 8002804:	f897 0160 	ldrb.w	r0, [r7, #352]	; 0x160
 8002808:	2300      	movs	r3, #0
 800280a:	9300      	str	r3, [sp, #0]
 800280c:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8002810:	223c      	movs	r2, #60	; 0x3c
 8002812:	2171      	movs	r1, #113	; 0x71
 8002814:	f7fe ff58 	bl	80016c8 <lcdPutCh>
	  	         	}
	  	         	lcdPutS("Pre hranie odznova ",10,70,0xFFFF, 0);
 8002818:	2300      	movs	r3, #0
 800281a:	9300      	str	r3, [sp, #0]
 800281c:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8002820:	2246      	movs	r2, #70	; 0x46
 8002822:	210a      	movs	r1, #10
 8002824:	480b      	ldr	r0, [pc, #44]	; (8002854 <init_game+0x344>)
 8002826:	f7fe ffdf 	bl	80017e8 <lcdPutS>
	  	         	lcdPutS("Stlac reset  ",35,80,0xFFFF, 0);
 800282a:	2300      	movs	r3, #0
 800282c:	9300      	str	r3, [sp, #0]
 800282e:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8002832:	2250      	movs	r2, #80	; 0x50
 8002834:	2123      	movs	r1, #35	; 0x23
 8002836:	4808      	ldr	r0, [pc, #32]	; (8002858 <init_game+0x348>)
 8002838:	f7fe ffd6 	bl	80017e8 <lcdPutS>

}
 800283c:	f507 77bc 	add.w	r7, r7, #376	; 0x178
 8002840:	46bd      	mov	sp, r7
 8002842:	bd80      	pop	{r7, pc}
 8002844:	40020800 	.word	0x40020800
 8002848:	cccccccd 	.word	0xcccccccd
 800284c:	08002cd8 	.word	0x08002cd8
 8002850:	08002ce4 	.word	0x08002ce4
 8002854:	08002cf4 	.word	0x08002cf4
 8002858:	08002d08 	.word	0x08002d08
 800285c:	08002d18 	.word	0x08002d18

08002860 <Delay>:
				Write_Data(*(n+16*k+i));
				}
}

void Delay(uint16_t n)
{
 8002860:	b480      	push	{r7}
 8002862:	b085      	sub	sp, #20
 8002864:	af00      	add	r7, sp, #0
 8002866:	4603      	mov	r3, r0
 8002868:	80fb      	strh	r3, [r7, #6]
	uint32_t nl = n*2;
 800286a:	88fb      	ldrh	r3, [r7, #6]
 800286c:	005b      	lsls	r3, r3, #1
 800286e:	60fb      	str	r3, [r7, #12]
	while(nl--);
 8002870:	bf00      	nop
 8002872:	68fb      	ldr	r3, [r7, #12]
 8002874:	1e5a      	subs	r2, r3, #1
 8002876:	60fa      	str	r2, [r7, #12]
 8002878:	2b00      	cmp	r3, #0
 800287a:	d1fa      	bne.n	8002872 <Delay+0x12>


	return;
 800287c:	bf00      	nop
}
 800287e:	3714      	adds	r7, #20
 8002880:	46bd      	mov	sp, r7
 8002882:	bc80      	pop	{r7}
 8002884:	4770      	bx	lr
 8002886:	bf00      	nop

08002888 <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   sp, =_estack    /* Atollic update: set stack pointer */
 8002888:	f8df d034 	ldr.w	sp, [pc, #52]	; 80028c0 <LoopFillZerobss+0x14>

/* Copy the data segment initializers from flash to SRAM */
  movs r1, #0
 800288c:	2100      	movs	r1, #0
  b LoopCopyDataInit
 800288e:	e003      	b.n	8002898 <LoopCopyDataInit>

08002890 <CopyDataInit>:

CopyDataInit:
  ldr r3, =_sidata
 8002890:	4b0c      	ldr	r3, [pc, #48]	; (80028c4 <LoopFillZerobss+0x18>)
  ldr r3, [r3, r1]
 8002892:	585b      	ldr	r3, [r3, r1]
  str r3, [r0, r1]
 8002894:	5043      	str	r3, [r0, r1]
  adds r1, r1, #4
 8002896:	3104      	adds	r1, #4

08002898 <LoopCopyDataInit>:

LoopCopyDataInit:
  ldr r0, =_sdata
 8002898:	480b      	ldr	r0, [pc, #44]	; (80028c8 <LoopFillZerobss+0x1c>)
  ldr r3, =_edata
 800289a:	4b0c      	ldr	r3, [pc, #48]	; (80028cc <LoopFillZerobss+0x20>)
  adds r2, r0, r1
 800289c:	1842      	adds	r2, r0, r1
  cmp r2, r3
 800289e:	429a      	cmp	r2, r3
  bcc CopyDataInit
 80028a0:	d3f6      	bcc.n	8002890 <CopyDataInit>
  ldr r2, =_sbss
 80028a2:	4a0b      	ldr	r2, [pc, #44]	; (80028d0 <LoopFillZerobss+0x24>)
  b LoopFillZerobss
 80028a4:	e002      	b.n	80028ac <LoopFillZerobss>

080028a6 <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
  movs r3, #0
 80028a6:	2300      	movs	r3, #0
  str r3, [r2], #4
 80028a8:	f842 3b04 	str.w	r3, [r2], #4

080028ac <LoopFillZerobss>:

LoopFillZerobss:
  ldr r3, = _ebss
 80028ac:	4b09      	ldr	r3, [pc, #36]	; (80028d4 <LoopFillZerobss+0x28>)
  cmp r2, r3
 80028ae:	429a      	cmp	r2, r3
  bcc FillZerobss
 80028b0:	d3f9      	bcc.n	80028a6 <FillZerobss>

/* Call the clock system intitialization function.*/
    bl  SystemInit
 80028b2:	f000 f841 	bl	8002938 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 80028b6:	f000 f903 	bl	8002ac0 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 80028ba:	f7fe ffd1 	bl	8001860 <main>
  bx lr
 80028be:	4770      	bx	lr

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   sp, =_estack    /* Atollic update: set stack pointer */
 80028c0:	20014000 	.word	0x20014000
/* Copy the data segment initializers from flash to SRAM */
  movs r1, #0
  b LoopCopyDataInit

CopyDataInit:
  ldr r3, =_sidata
 80028c4:	08003338 	.word	0x08003338
  ldr r3, [r3, r1]
  str r3, [r0, r1]
  adds r1, r1, #4

LoopCopyDataInit:
  ldr r0, =_sdata
 80028c8:	20000000 	.word	0x20000000
  ldr r3, =_edata
 80028cc:	20000068 	.word	0x20000068
  adds r2, r0, r1
  cmp r2, r3
  bcc CopyDataInit
  ldr r2, =_sbss
 80028d0:	20000068 	.word	0x20000068
FillZerobss:
  movs r3, #0
  str r3, [r2], #4

LoopFillZerobss:
  ldr r3, = _ebss
 80028d4:	200000a8 	.word	0x200000a8

080028d8 <AES_IRQHandler>:
 * @retval : None
*/
    .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 80028d8:	e7fe      	b.n	80028d8 <AES_IRQHandler>
	...

080028dc <NMI_Handler>:
  * @brief  This function handles NMI exception.
  * @param  None
  * @retval None
  */
void NMI_Handler(void)
{
 80028dc:	b480      	push	{r7}
 80028de:	af00      	add	r7, sp, #0
}
 80028e0:	bf00      	nop
 80028e2:	46bd      	mov	sp, r7
 80028e4:	bc80      	pop	{r7}
 80028e6:	4770      	bx	lr

080028e8 <HardFault_Handler>:
  * @brief  This function handles Hard Fault exception.
  * @param  None
  * @retval None
  */
void HardFault_Handler(void)
{
 80028e8:	b480      	push	{r7}
 80028ea:	af00      	add	r7, sp, #0
  /* Go to infinite loop when Hard Fault exception occurs */
  while (1)
  {
  }
 80028ec:	e7fe      	b.n	80028ec <HardFault_Handler+0x4>
 80028ee:	bf00      	nop

080028f0 <MemManage_Handler>:
  * @brief  This function handles Memory Manage exception.
  * @param  None
  * @retval None
  */
void MemManage_Handler(void)
{
 80028f0:	b480      	push	{r7}
 80028f2:	af00      	add	r7, sp, #0
  /* Go to infinite loop when Memory Manage exception occurs */
  while (1)
  {
  }
 80028f4:	e7fe      	b.n	80028f4 <MemManage_Handler+0x4>
 80028f6:	bf00      	nop

080028f8 <BusFault_Handler>:
  * @brief  This function handles Bus Fault exception.
  * @param  None
  * @retval None
  */
void BusFault_Handler(void)
{
 80028f8:	b480      	push	{r7}
 80028fa:	af00      	add	r7, sp, #0
  /* Go to infinite loop when Bus Fault exception occurs */
  while (1)
  {
  }
 80028fc:	e7fe      	b.n	80028fc <BusFault_Handler+0x4>
 80028fe:	bf00      	nop

08002900 <UsageFault_Handler>:
  * @brief  This function handles Usage Fault exception.
  * @param  None
  * @retval None
  */
void UsageFault_Handler(void)
{
 8002900:	b480      	push	{r7}
 8002902:	af00      	add	r7, sp, #0
  /* Go to infinite loop when Usage Fault exception occurs */
  while (1)
  {
  }
 8002904:	e7fe      	b.n	8002904 <UsageFault_Handler+0x4>
 8002906:	bf00      	nop

08002908 <SVC_Handler>:
  * @brief  This function handles SVCall exception.
  * @param  None
  * @retval None
  */
void SVC_Handler(void)
{
 8002908:	b480      	push	{r7}
 800290a:	af00      	add	r7, sp, #0
}
 800290c:	bf00      	nop
 800290e:	46bd      	mov	sp, r7
 8002910:	bc80      	pop	{r7}
 8002912:	4770      	bx	lr

08002914 <DebugMon_Handler>:
  * @brief  This function handles Debug Monitor exception.
  * @param  None
  * @retval None
  */
void DebugMon_Handler(void)
{
 8002914:	b480      	push	{r7}
 8002916:	af00      	add	r7, sp, #0
}
 8002918:	bf00      	nop
 800291a:	46bd      	mov	sp, r7
 800291c:	bc80      	pop	{r7}
 800291e:	4770      	bx	lr

08002920 <PendSV_Handler>:
  * @brief  This function handles PendSVC exception.
  * @param  None
  * @retval None
  */
void PendSV_Handler(void)
{
 8002920:	b480      	push	{r7}
 8002922:	af00      	add	r7, sp, #0
}
 8002924:	bf00      	nop
 8002926:	46bd      	mov	sp, r7
 8002928:	bc80      	pop	{r7}
 800292a:	4770      	bx	lr

0800292c <SysTick_Handler>:
  * @brief  This function handles SysTick Handler.
  * @param  None
  * @retval None
  */
void SysTick_Handler(void)
{
 800292c:	b480      	push	{r7}
 800292e:	af00      	add	r7, sp, #0
	/*  TimingDelay_Decrement(); */
#ifdef USE_STM32L_DISCOVERY
  TimingDelay_Decrement();
#endif
}
 8002930:	bf00      	nop
 8002932:	46bd      	mov	sp, r7
 8002934:	bc80      	pop	{r7}
 8002936:	4770      	bx	lr

08002938 <SystemInit>:
  *         SystemCoreClock variable.
  * @param  None
  * @retval None
  */
void SystemInit (void)
{
 8002938:	b580      	push	{r7, lr}
 800293a:	af00      	add	r7, sp, #0
  /*!< Set MSION bit */
  RCC->CR |= (uint32_t)0x00000100;
 800293c:	4a15      	ldr	r2, [pc, #84]	; (8002994 <SystemInit+0x5c>)
 800293e:	4b15      	ldr	r3, [pc, #84]	; (8002994 <SystemInit+0x5c>)
 8002940:	681b      	ldr	r3, [r3, #0]
 8002942:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8002946:	6013      	str	r3, [r2, #0]

  /*!< Reset SW[1:0], HPRE[3:0], PPRE1[2:0], PPRE2[2:0], MCOSEL[2:0] and MCOPRE[2:0] bits */
  RCC->CFGR &= (uint32_t)0x88FFC00C;
 8002948:	4912      	ldr	r1, [pc, #72]	; (8002994 <SystemInit+0x5c>)
 800294a:	4b12      	ldr	r3, [pc, #72]	; (8002994 <SystemInit+0x5c>)
 800294c:	689a      	ldr	r2, [r3, #8]
 800294e:	4b12      	ldr	r3, [pc, #72]	; (8002998 <SystemInit+0x60>)
 8002950:	4013      	ands	r3, r2
 8002952:	608b      	str	r3, [r1, #8]
  
  /*!< Reset HSION, HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xEEFEFFFE;
 8002954:	4a0f      	ldr	r2, [pc, #60]	; (8002994 <SystemInit+0x5c>)
 8002956:	4b0f      	ldr	r3, [pc, #60]	; (8002994 <SystemInit+0x5c>)
 8002958:	681b      	ldr	r3, [r3, #0]
 800295a:	f023 5388 	bic.w	r3, r3, #285212672	; 0x11000000
 800295e:	f023 1301 	bic.w	r3, r3, #65537	; 0x10001
 8002962:	6013      	str	r3, [r2, #0]

  /*!< Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8002964:	4a0b      	ldr	r2, [pc, #44]	; (8002994 <SystemInit+0x5c>)
 8002966:	4b0b      	ldr	r3, [pc, #44]	; (8002994 <SystemInit+0x5c>)
 8002968:	681b      	ldr	r3, [r3, #0]
 800296a:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 800296e:	6013      	str	r3, [r2, #0]

  /*!< Reset PLLSRC, PLLMUL[3:0] and PLLDIV[1:0] bits */
  RCC->CFGR &= (uint32_t)0xFF02FFFF;
 8002970:	4a08      	ldr	r2, [pc, #32]	; (8002994 <SystemInit+0x5c>)
 8002972:	4b08      	ldr	r3, [pc, #32]	; (8002994 <SystemInit+0x5c>)
 8002974:	689b      	ldr	r3, [r3, #8]
 8002976:	f423 037d 	bic.w	r3, r3, #16580608	; 0xfd0000
 800297a:	6093      	str	r3, [r2, #8]

  /*!< Disable all interrupts */
  RCC->CIR = 0x00000000;
 800297c:	4b05      	ldr	r3, [pc, #20]	; (8002994 <SystemInit+0x5c>)
 800297e:	2200      	movs	r2, #0
 8002980:	60da      	str	r2, [r3, #12]
#ifdef DATA_IN_ExtSRAM
  SystemInit_ExtMemCtl(); 
#endif /* DATA_IN_ExtSRAM */
    
  /* Configure the System clock frequency, AHB/APBx prescalers and Flash settings */
  SetSysClock();
 8002982:	f000 f80d 	bl	80029a0 <SetSysClock>

#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM. */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH. */
 8002986:	4b05      	ldr	r3, [pc, #20]	; (800299c <SystemInit+0x64>)
 8002988:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 800298c:	609a      	str	r2, [r3, #8]
#endif
}
 800298e:	bf00      	nop
 8002990:	bd80      	pop	{r7, pc}
 8002992:	bf00      	nop
 8002994:	40023800 	.word	0x40023800
 8002998:	88ffc00c 	.word	0x88ffc00c
 800299c:	e000ed00 	.word	0xe000ed00

080029a0 <SetSysClock>:
  *         is reset to the default reset state (done in SystemInit() function).
  * @param  None
  * @retval None
  */
static void SetSysClock(void)
{
 80029a0:	b480      	push	{r7}
 80029a2:	b083      	sub	sp, #12
 80029a4:	af00      	add	r7, sp, #0
  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
 80029a6:	2300      	movs	r3, #0
 80029a8:	607b      	str	r3, [r7, #4]
 80029aa:	2300      	movs	r3, #0
 80029ac:	603b      	str	r3, [r7, #0]
  
  /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/
  /* Enable HSE */
  RCC->CR |= ((uint32_t)RCC_CR_HSEON);
 80029ae:	4a41      	ldr	r2, [pc, #260]	; (8002ab4 <SetSysClock+0x114>)
 80029b0:	4b40      	ldr	r3, [pc, #256]	; (8002ab4 <SetSysClock+0x114>)
 80029b2:	681b      	ldr	r3, [r3, #0]
 80029b4:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80029b8:	6013      	str	r3, [r2, #0]
 
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSEStatus = RCC->CR & RCC_CR_HSERDY;
 80029ba:	4b3e      	ldr	r3, [pc, #248]	; (8002ab4 <SetSysClock+0x114>)
 80029bc:	681b      	ldr	r3, [r3, #0]
 80029be:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 80029c2:	603b      	str	r3, [r7, #0]
    StartUpCounter++;
 80029c4:	687b      	ldr	r3, [r7, #4]
 80029c6:	3301      	adds	r3, #1
 80029c8:	607b      	str	r3, [r7, #4]
  } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
 80029ca:	683b      	ldr	r3, [r7, #0]
 80029cc:	2b00      	cmp	r3, #0
 80029ce:	d103      	bne.n	80029d8 <SetSysClock+0x38>
 80029d0:	687b      	ldr	r3, [r7, #4]
 80029d2:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 80029d6:	d1f0      	bne.n	80029ba <SetSysClock+0x1a>

  if ((RCC->CR & RCC_CR_HSERDY) != RESET)
 80029d8:	4b36      	ldr	r3, [pc, #216]	; (8002ab4 <SetSysClock+0x114>)
 80029da:	681b      	ldr	r3, [r3, #0]
 80029dc:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 80029e0:	2b00      	cmp	r3, #0
 80029e2:	d002      	beq.n	80029ea <SetSysClock+0x4a>
  {
    HSEStatus = (uint32_t)0x01;
 80029e4:	2301      	movs	r3, #1
 80029e6:	603b      	str	r3, [r7, #0]
 80029e8:	e001      	b.n	80029ee <SetSysClock+0x4e>
  }
  else
  {
    HSEStatus = (uint32_t)0x00;
 80029ea:	2300      	movs	r3, #0
 80029ec:	603b      	str	r3, [r7, #0]
  }
  
  if (HSEStatus == (uint32_t)0x01)
 80029ee:	683b      	ldr	r3, [r7, #0]
 80029f0:	2b01      	cmp	r3, #1
 80029f2:	d15a      	bne.n	8002aaa <SetSysClock+0x10a>
  {
    /* Enable 64-bit access */
    FLASH->ACR |= FLASH_ACR_ACC64;
 80029f4:	4a30      	ldr	r2, [pc, #192]	; (8002ab8 <SetSysClock+0x118>)
 80029f6:	4b30      	ldr	r3, [pc, #192]	; (8002ab8 <SetSysClock+0x118>)
 80029f8:	681b      	ldr	r3, [r3, #0]
 80029fa:	f043 0304 	orr.w	r3, r3, #4
 80029fe:	6013      	str	r3, [r2, #0]
    
    /* Enable Prefetch Buffer */
    FLASH->ACR |= FLASH_ACR_PRFTEN;
 8002a00:	4a2d      	ldr	r2, [pc, #180]	; (8002ab8 <SetSysClock+0x118>)
 8002a02:	4b2d      	ldr	r3, [pc, #180]	; (8002ab8 <SetSysClock+0x118>)
 8002a04:	681b      	ldr	r3, [r3, #0]
 8002a06:	f043 0302 	orr.w	r3, r3, #2
 8002a0a:	6013      	str	r3, [r2, #0]

    /* Flash 1 wait state */
    FLASH->ACR |= FLASH_ACR_LATENCY;
 8002a0c:	4a2a      	ldr	r2, [pc, #168]	; (8002ab8 <SetSysClock+0x118>)
 8002a0e:	4b2a      	ldr	r3, [pc, #168]	; (8002ab8 <SetSysClock+0x118>)
 8002a10:	681b      	ldr	r3, [r3, #0]
 8002a12:	f043 0301 	orr.w	r3, r3, #1
 8002a16:	6013      	str	r3, [r2, #0]
    
    /* Power enable */
    RCC->APB1ENR |= RCC_APB1ENR_PWREN;
 8002a18:	4a26      	ldr	r2, [pc, #152]	; (8002ab4 <SetSysClock+0x114>)
 8002a1a:	4b26      	ldr	r3, [pc, #152]	; (8002ab4 <SetSysClock+0x114>)
 8002a1c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8002a1e:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8002a22:	6253      	str	r3, [r2, #36]	; 0x24
  
    /* Select the Voltage Range 1 (1.8 V) */
    PWR->CR = PWR_CR_VOS_0;
 8002a24:	4b25      	ldr	r3, [pc, #148]	; (8002abc <SetSysClock+0x11c>)
 8002a26:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8002a2a:	601a      	str	r2, [r3, #0]
  
    /* Wait Until the Voltage Regulator is ready */
    while((PWR->CSR & PWR_CSR_VOSF) != RESET)
 8002a2c:	bf00      	nop
 8002a2e:	4b23      	ldr	r3, [pc, #140]	; (8002abc <SetSysClock+0x11c>)
 8002a30:	685b      	ldr	r3, [r3, #4]
 8002a32:	f003 0310 	and.w	r3, r3, #16
 8002a36:	2b00      	cmp	r3, #0
 8002a38:	d1f9      	bne.n	8002a2e <SetSysClock+0x8e>
    {
    }
        
    /* HCLK = SYSCLK /1*/
    RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;
 8002a3a:	4a1e      	ldr	r2, [pc, #120]	; (8002ab4 <SetSysClock+0x114>)
 8002a3c:	4b1d      	ldr	r3, [pc, #116]	; (8002ab4 <SetSysClock+0x114>)
 8002a3e:	689b      	ldr	r3, [r3, #8]
 8002a40:	6093      	str	r3, [r2, #8]
  
    /* PCLK2 = HCLK /1*/
    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;
 8002a42:	4a1c      	ldr	r2, [pc, #112]	; (8002ab4 <SetSysClock+0x114>)
 8002a44:	4b1b      	ldr	r3, [pc, #108]	; (8002ab4 <SetSysClock+0x114>)
 8002a46:	689b      	ldr	r3, [r3, #8]
 8002a48:	6093      	str	r3, [r2, #8]
    
    /* PCLK1 = HCLK /1*/
    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV1;
 8002a4a:	4a1a      	ldr	r2, [pc, #104]	; (8002ab4 <SetSysClock+0x114>)
 8002a4c:	4b19      	ldr	r3, [pc, #100]	; (8002ab4 <SetSysClock+0x114>)
 8002a4e:	689b      	ldr	r3, [r3, #8]
 8002a50:	6093      	str	r3, [r2, #8]
    
    /*  PLL configuration */
    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLMUL |
 8002a52:	4a18      	ldr	r2, [pc, #96]	; (8002ab4 <SetSysClock+0x114>)
 8002a54:	4b17      	ldr	r3, [pc, #92]	; (8002ab4 <SetSysClock+0x114>)
 8002a56:	689b      	ldr	r3, [r3, #8]
 8002a58:	f423 037d 	bic.w	r3, r3, #16580608	; 0xfd0000
 8002a5c:	6093      	str	r3, [r2, #8]
                                        RCC_CFGR_PLLDIV));
    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_HSE | RCC_CFGR_PLLMUL12 | RCC_CFGR_PLLDIV3);
 8002a5e:	4a15      	ldr	r2, [pc, #84]	; (8002ab4 <SetSysClock+0x114>)
 8002a60:	4b14      	ldr	r3, [pc, #80]	; (8002ab4 <SetSysClock+0x114>)
 8002a62:	689b      	ldr	r3, [r3, #8]
 8002a64:	f443 0311 	orr.w	r3, r3, #9502720	; 0x910000
 8002a68:	6093      	str	r3, [r2, #8]

    /* Enable PLL */
    RCC->CR |= RCC_CR_PLLON;
 8002a6a:	4a12      	ldr	r2, [pc, #72]	; (8002ab4 <SetSysClock+0x114>)
 8002a6c:	4b11      	ldr	r3, [pc, #68]	; (8002ab4 <SetSysClock+0x114>)
 8002a6e:	681b      	ldr	r3, [r3, #0]
 8002a70:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8002a74:	6013      	str	r3, [r2, #0]

    /* Wait till PLL is ready */
    while((RCC->CR & RCC_CR_PLLRDY) == 0)
 8002a76:	bf00      	nop
 8002a78:	4b0e      	ldr	r3, [pc, #56]	; (8002ab4 <SetSysClock+0x114>)
 8002a7a:	681b      	ldr	r3, [r3, #0]
 8002a7c:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8002a80:	2b00      	cmp	r3, #0
 8002a82:	d0f9      	beq.n	8002a78 <SetSysClock+0xd8>
    {
    }
        
    /* Select PLL as system clock source */
    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
 8002a84:	4a0b      	ldr	r2, [pc, #44]	; (8002ab4 <SetSysClock+0x114>)
 8002a86:	4b0b      	ldr	r3, [pc, #44]	; (8002ab4 <SetSysClock+0x114>)
 8002a88:	689b      	ldr	r3, [r3, #8]
 8002a8a:	f023 0303 	bic.w	r3, r3, #3
 8002a8e:	6093      	str	r3, [r2, #8]
    RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;
 8002a90:	4a08      	ldr	r2, [pc, #32]	; (8002ab4 <SetSysClock+0x114>)
 8002a92:	4b08      	ldr	r3, [pc, #32]	; (8002ab4 <SetSysClock+0x114>)
 8002a94:	689b      	ldr	r3, [r3, #8]
 8002a96:	f043 0303 	orr.w	r3, r3, #3
 8002a9a:	6093      	str	r3, [r2, #8]

    /* Wait till PLL is used as system clock source */
    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)RCC_CFGR_SWS_PLL)
 8002a9c:	bf00      	nop
 8002a9e:	4b05      	ldr	r3, [pc, #20]	; (8002ab4 <SetSysClock+0x114>)
 8002aa0:	689b      	ldr	r3, [r3, #8]
 8002aa2:	f003 030c 	and.w	r3, r3, #12
 8002aa6:	2b0c      	cmp	r3, #12
 8002aa8:	d1f9      	bne.n	8002a9e <SetSysClock+0xfe>
  else
  {
    /* If HSE fails to start-up, the application will have wrong clock
       configuration. User can add here some code to deal with this error */
  }
}
 8002aaa:	bf00      	nop
 8002aac:	370c      	adds	r7, #12
 8002aae:	46bd      	mov	sp, r7
 8002ab0:	bc80      	pop	{r7}
 8002ab2:	4770      	bx	lr
 8002ab4:	40023800 	.word	0x40023800
 8002ab8:	40023c00 	.word	0x40023c00
 8002abc:	40007000 	.word	0x40007000

08002ac0 <__libc_init_array>:
 8002ac0:	4b0e      	ldr	r3, [pc, #56]	; (8002afc <__libc_init_array+0x3c>)
 8002ac2:	b570      	push	{r4, r5, r6, lr}
 8002ac4:	461e      	mov	r6, r3
 8002ac6:	4c0e      	ldr	r4, [pc, #56]	; (8002b00 <__libc_init_array+0x40>)
 8002ac8:	2500      	movs	r5, #0
 8002aca:	1ae4      	subs	r4, r4, r3
 8002acc:	10a4      	asrs	r4, r4, #2
 8002ace:	42a5      	cmp	r5, r4
 8002ad0:	d004      	beq.n	8002adc <__libc_init_array+0x1c>
 8002ad2:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8002ad6:	4798      	blx	r3
 8002ad8:	3501      	adds	r5, #1
 8002ada:	e7f8      	b.n	8002ace <__libc_init_array+0xe>
 8002adc:	f000 f8de 	bl	8002c9c <_init>
 8002ae0:	4b08      	ldr	r3, [pc, #32]	; (8002b04 <__libc_init_array+0x44>)
 8002ae2:	4c09      	ldr	r4, [pc, #36]	; (8002b08 <__libc_init_array+0x48>)
 8002ae4:	461e      	mov	r6, r3
 8002ae6:	1ae4      	subs	r4, r4, r3
 8002ae8:	10a4      	asrs	r4, r4, #2
 8002aea:	2500      	movs	r5, #0
 8002aec:	42a5      	cmp	r5, r4
 8002aee:	d004      	beq.n	8002afa <__libc_init_array+0x3a>
 8002af0:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8002af4:	4798      	blx	r3
 8002af6:	3501      	adds	r5, #1
 8002af8:	e7f8      	b.n	8002aec <__libc_init_array+0x2c>
 8002afa:	bd70      	pop	{r4, r5, r6, pc}
 8002afc:	08003330 	.word	0x08003330
 8002b00:	08003330 	.word	0x08003330
 8002b04:	08003330 	.word	0x08003330
 8002b08:	08003334 	.word	0x08003334

08002b0c <malloc>:
 8002b0c:	4b02      	ldr	r3, [pc, #8]	; (8002b18 <malloc+0xc>)
 8002b0e:	4601      	mov	r1, r0
 8002b10:	6818      	ldr	r0, [r3, #0]
 8002b12:	f000 b80b 	b.w	8002b2c <_malloc_r>
 8002b16:	bf00      	nop
 8002b18:	20000064 	.word	0x20000064

08002b1c <memset>:
 8002b1c:	4603      	mov	r3, r0
 8002b1e:	4402      	add	r2, r0
 8002b20:	4293      	cmp	r3, r2
 8002b22:	d002      	beq.n	8002b2a <memset+0xe>
 8002b24:	f803 1b01 	strb.w	r1, [r3], #1
 8002b28:	e7fa      	b.n	8002b20 <memset+0x4>
 8002b2a:	4770      	bx	lr

08002b2c <_malloc_r>:
 8002b2c:	b570      	push	{r4, r5, r6, lr}
 8002b2e:	1ccd      	adds	r5, r1, #3
 8002b30:	f025 0503 	bic.w	r5, r5, #3
 8002b34:	3508      	adds	r5, #8
 8002b36:	2d0c      	cmp	r5, #12
 8002b38:	bf38      	it	cc
 8002b3a:	250c      	movcc	r5, #12
 8002b3c:	2d00      	cmp	r5, #0
 8002b3e:	4606      	mov	r6, r0
 8002b40:	db01      	blt.n	8002b46 <_malloc_r+0x1a>
 8002b42:	42a9      	cmp	r1, r5
 8002b44:	d902      	bls.n	8002b4c <_malloc_r+0x20>
 8002b46:	230c      	movs	r3, #12
 8002b48:	6033      	str	r3, [r6, #0]
 8002b4a:	e046      	b.n	8002bda <_malloc_r+0xae>
 8002b4c:	f000 f896 	bl	8002c7c <__malloc_lock>
 8002b50:	4b23      	ldr	r3, [pc, #140]	; (8002be0 <_malloc_r+0xb4>)
 8002b52:	681c      	ldr	r4, [r3, #0]
 8002b54:	461a      	mov	r2, r3
 8002b56:	4621      	mov	r1, r4
 8002b58:	b1a1      	cbz	r1, 8002b84 <_malloc_r+0x58>
 8002b5a:	680b      	ldr	r3, [r1, #0]
 8002b5c:	1b5b      	subs	r3, r3, r5
 8002b5e:	d40e      	bmi.n	8002b7e <_malloc_r+0x52>
 8002b60:	2b0b      	cmp	r3, #11
 8002b62:	d903      	bls.n	8002b6c <_malloc_r+0x40>
 8002b64:	600b      	str	r3, [r1, #0]
 8002b66:	18cc      	adds	r4, r1, r3
 8002b68:	50cd      	str	r5, [r1, r3]
 8002b6a:	e01e      	b.n	8002baa <_malloc_r+0x7e>
 8002b6c:	428c      	cmp	r4, r1
 8002b6e:	bf0b      	itete	eq
 8002b70:	6863      	ldreq	r3, [r4, #4]
 8002b72:	684b      	ldrne	r3, [r1, #4]
 8002b74:	6013      	streq	r3, [r2, #0]
 8002b76:	6063      	strne	r3, [r4, #4]
 8002b78:	bf18      	it	ne
 8002b7a:	460c      	movne	r4, r1
 8002b7c:	e015      	b.n	8002baa <_malloc_r+0x7e>
 8002b7e:	460c      	mov	r4, r1
 8002b80:	6849      	ldr	r1, [r1, #4]
 8002b82:	e7e9      	b.n	8002b58 <_malloc_r+0x2c>
 8002b84:	4c17      	ldr	r4, [pc, #92]	; (8002be4 <_malloc_r+0xb8>)
 8002b86:	6823      	ldr	r3, [r4, #0]
 8002b88:	b91b      	cbnz	r3, 8002b92 <_malloc_r+0x66>
 8002b8a:	4630      	mov	r0, r6
 8002b8c:	f000 f866 	bl	8002c5c <_sbrk_r>
 8002b90:	6020      	str	r0, [r4, #0]
 8002b92:	4629      	mov	r1, r5
 8002b94:	4630      	mov	r0, r6
 8002b96:	f000 f861 	bl	8002c5c <_sbrk_r>
 8002b9a:	1c43      	adds	r3, r0, #1
 8002b9c:	d018      	beq.n	8002bd0 <_malloc_r+0xa4>
 8002b9e:	1cc4      	adds	r4, r0, #3
 8002ba0:	f024 0403 	bic.w	r4, r4, #3
 8002ba4:	42a0      	cmp	r0, r4
 8002ba6:	d10d      	bne.n	8002bc4 <_malloc_r+0x98>
 8002ba8:	6025      	str	r5, [r4, #0]
 8002baa:	4630      	mov	r0, r6
 8002bac:	f000 f867 	bl	8002c7e <__malloc_unlock>
 8002bb0:	f104 000b 	add.w	r0, r4, #11
 8002bb4:	1d23      	adds	r3, r4, #4
 8002bb6:	f020 0007 	bic.w	r0, r0, #7
 8002bba:	1ac3      	subs	r3, r0, r3
 8002bbc:	d00e      	beq.n	8002bdc <_malloc_r+0xb0>
 8002bbe:	425a      	negs	r2, r3
 8002bc0:	50e2      	str	r2, [r4, r3]
 8002bc2:	bd70      	pop	{r4, r5, r6, pc}
 8002bc4:	1a21      	subs	r1, r4, r0
 8002bc6:	4630      	mov	r0, r6
 8002bc8:	f000 f848 	bl	8002c5c <_sbrk_r>
 8002bcc:	3001      	adds	r0, #1
 8002bce:	d1eb      	bne.n	8002ba8 <_malloc_r+0x7c>
 8002bd0:	230c      	movs	r3, #12
 8002bd2:	6033      	str	r3, [r6, #0]
 8002bd4:	4630      	mov	r0, r6
 8002bd6:	f000 f852 	bl	8002c7e <__malloc_unlock>
 8002bda:	2000      	movs	r0, #0
 8002bdc:	bd70      	pop	{r4, r5, r6, pc}
 8002bde:	bf00      	nop
 8002be0:	20000098 	.word	0x20000098
 8002be4:	20000094 	.word	0x20000094

08002be8 <rand>:
 8002be8:	4b19      	ldr	r3, [pc, #100]	; (8002c50 <rand+0x68>)
 8002bea:	b510      	push	{r4, lr}
 8002bec:	681c      	ldr	r4, [r3, #0]
 8002bee:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8002bf0:	b9d3      	cbnz	r3, 8002c28 <rand+0x40>
 8002bf2:	2018      	movs	r0, #24
 8002bf4:	f7ff ff8a 	bl	8002b0c <malloc>
 8002bf8:	f243 330e 	movw	r3, #13070	; 0x330e
 8002bfc:	63a0      	str	r0, [r4, #56]	; 0x38
 8002bfe:	8003      	strh	r3, [r0, #0]
 8002c00:	f64a 33cd 	movw	r3, #43981	; 0xabcd
 8002c04:	8043      	strh	r3, [r0, #2]
 8002c06:	f241 2334 	movw	r3, #4660	; 0x1234
 8002c0a:	8083      	strh	r3, [r0, #4]
 8002c0c:	f24e 636d 	movw	r3, #58989	; 0xe66d
 8002c10:	80c3      	strh	r3, [r0, #6]
 8002c12:	f64d 63ec 	movw	r3, #57068	; 0xdeec
 8002c16:	8103      	strh	r3, [r0, #8]
 8002c18:	2305      	movs	r3, #5
 8002c1a:	8143      	strh	r3, [r0, #10]
 8002c1c:	230b      	movs	r3, #11
 8002c1e:	8183      	strh	r3, [r0, #12]
 8002c20:	2201      	movs	r2, #1
 8002c22:	2300      	movs	r3, #0
 8002c24:	e9c0 2304 	strd	r2, r3, [r0, #16]
 8002c28:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 8002c2a:	4c0a      	ldr	r4, [pc, #40]	; (8002c54 <rand+0x6c>)
 8002c2c:	690b      	ldr	r3, [r1, #16]
 8002c2e:	6948      	ldr	r0, [r1, #20]
 8002c30:	435c      	muls	r4, r3
 8002c32:	4a09      	ldr	r2, [pc, #36]	; (8002c58 <rand+0x70>)
 8002c34:	fb02 4000 	mla	r0, r2, r0, r4
 8002c38:	fba3 2302 	umull	r2, r3, r3, r2
 8002c3c:	3201      	adds	r2, #1
 8002c3e:	4403      	add	r3, r0
 8002c40:	f143 0300 	adc.w	r3, r3, #0
 8002c44:	e9c1 2304 	strd	r2, r3, [r1, #16]
 8002c48:	f023 4000 	bic.w	r0, r3, #2147483648	; 0x80000000
 8002c4c:	bd10      	pop	{r4, pc}
 8002c4e:	bf00      	nop
 8002c50:	20000064 	.word	0x20000064
 8002c54:	5851f42d 	.word	0x5851f42d
 8002c58:	4c957f2d 	.word	0x4c957f2d

08002c5c <_sbrk_r>:
 8002c5c:	b538      	push	{r3, r4, r5, lr}
 8002c5e:	4c06      	ldr	r4, [pc, #24]	; (8002c78 <_sbrk_r+0x1c>)
 8002c60:	2300      	movs	r3, #0
 8002c62:	4605      	mov	r5, r0
 8002c64:	4608      	mov	r0, r1
 8002c66:	6023      	str	r3, [r4, #0]
 8002c68:	f000 f80a 	bl	8002c80 <_sbrk>
 8002c6c:	1c43      	adds	r3, r0, #1
 8002c6e:	d102      	bne.n	8002c76 <_sbrk_r+0x1a>
 8002c70:	6823      	ldr	r3, [r4, #0]
 8002c72:	b103      	cbz	r3, 8002c76 <_sbrk_r+0x1a>
 8002c74:	602b      	str	r3, [r5, #0]
 8002c76:	bd38      	pop	{r3, r4, r5, pc}
 8002c78:	200000a4 	.word	0x200000a4

08002c7c <__malloc_lock>:
 8002c7c:	4770      	bx	lr

08002c7e <__malloc_unlock>:
 8002c7e:	4770      	bx	lr

08002c80 <_sbrk>:
 8002c80:	4b04      	ldr	r3, [pc, #16]	; (8002c94 <_sbrk+0x14>)
 8002c82:	4602      	mov	r2, r0
 8002c84:	6819      	ldr	r1, [r3, #0]
 8002c86:	b909      	cbnz	r1, 8002c8c <_sbrk+0xc>
 8002c88:	4903      	ldr	r1, [pc, #12]	; (8002c98 <_sbrk+0x18>)
 8002c8a:	6019      	str	r1, [r3, #0]
 8002c8c:	6818      	ldr	r0, [r3, #0]
 8002c8e:	4402      	add	r2, r0
 8002c90:	601a      	str	r2, [r3, #0]
 8002c92:	4770      	bx	lr
 8002c94:	2000009c 	.word	0x2000009c
 8002c98:	200000a8 	.word	0x200000a8

08002c9c <_init>:
 8002c9c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002c9e:	bf00      	nop
 8002ca0:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8002ca2:	bc08      	pop	{r3}
 8002ca4:	469e      	mov	lr, r3
 8002ca6:	4770      	bx	lr

08002ca8 <_fini>:
 8002ca8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002caa:	bf00      	nop
 8002cac:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8002cae:	bc08      	pop	{r3}
 8002cb0:	469e      	mov	lr, r3
 8002cb2:	4770      	bx	lr
